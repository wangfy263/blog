{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决.md","hash":"373a16de25ee1b99d0f5150997595fe059bf070b","modified":1534760735097},{"_id":"source/_posts/gitflow工作流程使用经验.md","hash":"35c709c4c65fd09a1018eb935d03af75b44bfea4","modified":1529491461707},{"_id":"source/_posts/javascript异常总结.md","hash":"34d941692ab28ce6f531c8b5298bfebdcbb1c23b","modified":1547024440314},{"_id":"source/_posts/javascript执行机制.md","hash":"949c863ade7ee32bf22541bc0d7e78a99d346bc4","modified":1544671530994},{"_id":"source/_posts/javascript实现继承的几种方式.md","hash":"730d7d85260563d746030b4c2ce60036de143ff1","modified":1546564940709},{"_id":"source/_posts/vue多页面-history路由模式的nginx配置.md","hash":"5e71869ded2657be771ed390d76647fab3c6bfe9","modified":1541500265688},{"_id":"source/_posts/vue渲染机制.md","hash":"71c66c902a4981ca04aa85cd26629cd3eeb0c3d4","modified":1539520864775},{"_id":"source/_posts/jenkins持续集成前端项目实践.md","hash":"286b5f1ad9200380dfc7e365c2232a2714a0d0a4","modified":1546225917740},{"_id":"source/_posts/加密签名与解密验签总结.md","hash":"a75aeab49292c23c9026a776cf57dc1ed05ed2ae","modified":1547018485973},{"_id":"source/_posts/nginx配置踩坑-rewrite.md","hash":"f324eff02aa91ee27976e8d9dd454740d78fe372","modified":1536144856453},{"_id":"source/_posts/可视化编辑系统实践.md","hash":"d4fb2bab12f71b104abbb7c2a0a8abf11ad7443f","modified":1529486795379},{"_id":"source/_posts/前端导出csv.md","hash":"643ec0dc6f81ffd0450f36bd0b7d7647b0ddac14","modified":1529998748915},{"_id":"source/_posts/基于vue的埋点方案.md","hash":"c83935dbeb3d5497565fbed690ed5e4188dbd5e5","modified":1525656736535},{"_id":"source/_posts/基于vue的管理系统权限管控方案.md","hash":"fb366a5afbbf00bff3ef715fea7ee8de73a76c03","modified":1527767396687},{"_id":"source/_posts/手动实现一个promise-A.md","hash":"68d8ecd85ab190e3de41a1e10f5f030909ea5f42","modified":1548033553498},{"_id":"source/_posts/营销活动数据采集方案.md","hash":"116faae52b1f491e945dd5392c297fc6ad08b33f","modified":1541398939858},{"_id":"source/_posts/易问web版浏览器支持方案分析.md","hash":"500277de680bc67249e7c162ed77f03796c78941","modified":1548402514247},{"_id":"source/_posts/拼团购活动开发总结.md","hash":"652765322b5e61f8189af5b9bf46c1f8b59617e9","modified":1541501955380},{"_id":"source/_posts/神经网络梯度下降训练模型.md","hash":"88fe45bfe1e869a5a1c5b21e0d3a5e323dacf979","modified":1533115760349},{"_id":"source/_posts/首页在部分机型下白屏原因分析.md","hash":"876baf42d96f2ee39a05fd098e361750a9e60bad","modified":1531812990003},{"_id":"source/uploads/avatar.jpg","hash":"6a95b7a5c59314de4dfbc371998151842af48ad5","modified":1466995710468},{"_id":"source/_posts/规则配置界面设计.md","hash":"deaeb7489d408c6e255b74ddeb9b6caea9f75b3e","modified":1535108224193},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1526970279241},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1526970279242},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1526970279244},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1526970279250},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1526970279249},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1526970279252},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1526970279252},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1526970279255},{"_id":"themes/next/_config.yml","hash":"57081dfc3502a2c111d129d37d9799174c1ddc0c","modified":1526971262845},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1526970279254},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1526970279258},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1526970279259},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1526970279373},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1526970279253},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1526970279256},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/require引入方式.jpg","hash":"66cef0c781cf91e77704be5b59f6605aad43cdbe","modified":1533890134632},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译前.jpg","hash":"86805d901a8d83dbc73650c94b3a882020db6f16","modified":1533888791381},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译后.jpg","hash":"e3e8d2ff86107ab61d3db267b57e7538e5361e64","modified":1533889325652},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/md5戳不一致.jpg","hash":"ce0d2d3cf70733b8c239edfa48f4d5330a82cac2","modified":1533886834376},{"_id":"source/_posts/gitflow工作流程使用经验/gitBranch.jpg","hash":"698021c663df461786ad5f073b6a09e9816f8e8a","modified":1529487341285},{"_id":"source/_posts/gitflow工作流程使用经验/gitBash.jpg","hash":"7848ac10a4d350fbc553bc8c10e71f13ea6acc0e","modified":1528350629119},{"_id":"source/_posts/前端导出csv/table.jpg","hash":"f17b7bb7592841cb301b377ebf73313a62e6d73d","modified":1529998247239},{"_id":"source/_posts/前端导出csv/excel打开.jpg","hash":"3234c504954a81e6209be90b302bc6bc6d4bff6f","modified":1529978889965},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/修正后.jpg","hash":"dc0212d0795fd3020dc31943364073289abfde9c","modified":1533891324991},{"_id":"source/_posts/前端导出csv/test.jpg","hash":"b26e47d5d238dff2cceda03e1fd922bda2ad506b","modified":1529978821060},{"_id":"source/_posts/vue渲染机制/$mount使用方法.jpg","hash":"e5af2d64ced4af0b7c1110b9820a072f8747da7f","modified":1539520220428},{"_id":"source/_posts/vue渲染机制/vue渲染机制.png","hash":"b5b492b0c141b1f923eba675c2a9b4e789265e5b","modified":1539509239534},{"_id":"source/_posts/vue渲染机制/效果图.jpg","hash":"7c1e91a61d8a9ba47a17fecd0c660fd17a851bb6","modified":1539510204106},{"_id":"source/_posts/基于vue的管理系统权限管控方案/SequenceDiagram.png","hash":"0845ad0cd31c49612e1232b6b8627c6d27eb55ee","modified":1526981580225},{"_id":"source/_posts/基于vue的管理系统权限管控方案/menu.jpg","hash":"759f70c1e8924ebc906aef71f111c3a1d83bc480","modified":1527767224197},{"_id":"source/_posts/可视化编辑系统实践/approvalProcess.jpg","hash":"297c4c0e7722cd8e00ee144c8bd3b1a14aaa0df8","modified":1527767224174},{"_id":"source/_posts/可视化编辑系统实践/approval.jpg","hash":"177e0b7baf132f48bddb2dcac35a14da36447d72","modified":1527767224173},{"_id":"source/_posts/可视化编辑系统实践/flow.jpg","hash":"5540e8b00ce54c95ee027cf5a5d0e522437fc1a3","modified":1529485754002},{"_id":"source/_posts/可视化编辑系统实践/qrcode.jpg","hash":"fdad1b48fac00e3516b5ae2d0a3b8656496cf5ee","modified":1528603380173},{"_id":"source/_posts/可视化编辑系统实践/imageManage.jpg","hash":"7aa4c5e80d10b4cfb35b2959a0adf086c34a0114","modified":1528609519685},{"_id":"source/_posts/可视化编辑系统实践/preview2.jpg","hash":"2228b1e8fef8990de625e3704669d0c44752842c","modified":1528335576226},{"_id":"source/_posts/首页在部分机型下白屏原因分析/generators兼容性.jpg","hash":"155ea5cec7d4e9fab24d7e9cc30c5b3cc28fce5e","modified":1531790663340},{"_id":"source/_posts/可视化编辑系统实践/preview.jpg","hash":"765bfa3080969b2b331f3776eb4cb9307b6a3551","modified":1528335538689},{"_id":"source/_posts/首页在部分机型下白屏原因分析/class兼容性.jpg","hash":"4ca1e11069206456f648f1a58783fed6d8975697","modified":1531790303069},{"_id":"source/_posts/首页在部分机型下白屏原因分析/ios10报错.jpg","hash":"cb1a187188cc8872ab42c9c22e1843bbe9a6b10d","modified":1531789061511},{"_id":"source/_posts/首页在部分机型下白屏原因分析/let兼容性.jpg","hash":"621093f5b5f664eddc1043aaa7cf21aa0f58e3f2","modified":1531790349676},{"_id":"source/_posts/首页在部分机型下白屏原因分析/webpack配置.jpg","hash":"cb091059d41141411fe0fc102ad6ad2f5ae100b8","modified":1531791015158},{"_id":"source/_posts/首页在部分机型下白屏原因分析/说明2.jpg","hash":"214900fadcb712fc16eff932e14c7a4dee9a0ae4","modified":1531789636335},{"_id":"source/_posts/首页在部分机型下白屏原因分析/说明1.jpg","hash":"e7087ff5e4ad41e626236a5306df1569e6f912c2","modified":1531789457085},{"_id":"source/_posts/首页在部分机型下白屏原因分析/箭头函数兼容性.jpg","hash":"f20cf3d006b8d4d5bfb020424a64d17c2f5fad60","modified":1531790412771},{"_id":"source/_posts/规则配置界面设计/规则列表查询接口.png","hash":"6bba9a1aff728f996b08921cf123f95ce66a5eed","modified":1535098052770},{"_id":"source/_posts/可视化编辑系统实践/workflow.png","hash":"7cf3b89ca91db956ceac0040cf67b7ce5fdae2ba","modified":1527832467427},{"_id":"source/_posts/规则配置界面设计/父子组件交互设计.jpg","hash":"c6fcf94b46c1337eb7bf2a32076a8abe39338924","modified":1535101125075},{"_id":"source/_posts/规则配置界面设计/规则配置保存接口.png","hash":"759e787667429aefef3da85af6680fd685d3d862","modified":1535098114297},{"_id":"source/_posts/可视化编辑系统实践/workflow.jpg","hash":"44f019a3bb6a11e0dd6003110ef8ea3b54627e61","modified":1528601862268},{"_id":"source/_posts/可视化编辑系统实践/snapshot.jpg","hash":"9f90db4c8c3350fdfc57b7951f54fe557e4aa6c8","modified":1529484752843},{"_id":"source/_posts/规则配置界面设计/规则配置流程.jpg","hash":"2b42c562937c567c9810897574af082e9cf2a53b","modified":1535105177209},{"_id":"source/_posts/jenkins持续集成前端项目实践/FTP任务配置.jpg","hash":"e7ceef82e4948a4e0a16673ebc373d4e5552072e","modified":1529913937962},{"_id":"source/_posts/jenkins持续集成前端项目实践/git配置.jpg","hash":"19c95790be75ee565373cf1f7515ee39595b0dca","modified":1529897616908},{"_id":"source/_posts/规则配置界面设计/语境图.jpg","hash":"1c37e7c4f1fbd04e1099768de209fb2447cab94f","modified":1535106706420},{"_id":"source/_posts/jenkins持续集成前端项目实践/FTP配置.jpg","hash":"65e0ae53290cd020c42ab8f88ed1d342cf4c6a5c","modified":1529898298995},{"_id":"source/_posts/jenkins持续集成前端项目实践/nodejs配置.jpg","hash":"8d216ffd9bd3e6432f120c8f8cf3f61dbb24c54a","modified":1529913099105},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建.jpg","hash":"47704beabad124f7f16e716dbebb5fd1972123c3","modified":1529913642418},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建环境.jpg","hash":"89c2f20be1f8636de716083e750a226d2067e00f","modified":1529913559368},{"_id":"source/_posts/jenkins持续集成前端项目实践/邮件配置.jpg","hash":"a9a1792e20229b3aef524c95abe1dddb6f926d95","modified":1529898679291},{"_id":"source/_posts/jenkins持续集成前端项目实践/源码管理.jpg","hash":"e94a74b9f915a6be4c0b75bd59109ce416f65641","modified":1529913457783},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"e5fa44f2b31c1fb553b6021e7360d07d5d91ff5e","modified":1526974925768},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1526970225253},{"_id":"themes/next/.git/config","hash":"340cff4364d9733a32042fdb93097c334a781c93","modified":1526970279229},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1526970279213},{"_id":"source/_posts/jenkins持续集成前端项目实践/邮件提醒.jpg","hash":"9c00aada4b96fc505e90fc3274fe5c417f182ed3","modified":1529913907404},{"_id":"source/_posts/jenkins持续集成前端项目实践/界面化操作.jpg","hash":"81793fa00cd60d39ae104c1d84f3a8da426f092a","modified":1529916898331},{"_id":"themes/next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1526970279200},{"_id":"themes/next/.git/index","hash":"9652b53e779eabac146c8824e293f777c895078e","modified":1526974925766},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1526970279245},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1526970279247},{"_id":"themes/next/scripts/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1526970279251},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1526970279375},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1526970279377},{"_id":"source/_posts/gitflow工作流程使用经验/gitflow.png","hash":"64f53127384364b18c894babba9ea91df276c56e","modified":1527767220155},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1526970279246},{"_id":"source/_posts/可视化编辑系统实践/issue.jpg","hash":"1eea26f155dad2c4ebc4b73c9eef38eaae556ccd","modified":1527767224190},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1526970279248},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1526970279261},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1526970279262},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1526970279264},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1526970279264},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1526970279267},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1526970279268},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1526970279269},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1526970279266},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1526970279270},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1526970279271},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1526970279272},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1526970279273},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1526970279263},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1526970279275},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1526970279701},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1526970279276},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1526970279277},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1526970279702},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1526970279704},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程.jpg","hash":"a5b708666f8e6c5a591904b9d581db99032c7e54","modified":1546995775891},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程--应对大量数据传输时的加密效率问题.jpg","hash":"306b20065b57b0653f9422fa53780acab4283034","modified":1546998975179},{"_id":"source/_posts/前端导出csv/保存.jpg","hash":"b2aba23e28346137fe343f5142229c7d5ec6c07d","modified":1529998314812},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1526970279369},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1526970279370},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1526970279281},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1526970279371},{"_id":"source/_posts/vue渲染机制/事件循环.png","hash":"5c32fb57c81a693eb6989d09d509f02aa06be94e","modified":1539508016380},{"_id":"source/_posts/前端导出csv/导出excel.jpg","hash":"3953c7db0440511519c2e7f23dd58d1c6fcf6b01","modified":1529998354741},{"_id":"source/_posts/可视化编辑系统实践/history.jpg","hash":"5c89d900d35aa377493cf66c110ed6d46e9cdd2e","modified":1528609362613},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1526970279372},{"_id":"source/_posts/规则配置界面设计/规则配置界面设计.jpg","hash":"e17d0cb2b0c55622511d662dc0701d1415efe6f2","modified":1535106446619},{"_id":"source/_posts/jenkins持续集成前端项目实践/git配置异常.jpg","hash":"ef47458fc9ae77fc325c130631316484e7d0fa1c","modified":1529897864729},{"_id":"source/_posts/jenkins持续集成前端项目实践/jenkins插件.jpg","hash":"82f969c97b71fb10949475261fdb24488e61e53f","modified":1529897438382},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建日志.jpg","hash":"5c3798104b331bf1c561a851a9e173a292a35149","modified":1529916853421},{"_id":"source/_posts/jenkins持续集成前端项目实践/新建任务.jpg","hash":"9cfefcb569eea7bc9e04c26d7131ef28ff63782a","modified":1529913334920},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279517},{"_id":"source/_posts/gitflow工作流程使用经验/sourceTree.jpg","hash":"3bfe713183a94125df3746ea106639ca816361a4","modified":1528343993258},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1526970279365},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1526970279367},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1526970279368},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程--增加数字证书流程.jpg","hash":"7ec41421ab5528a9a942f809a553b88fc3910102","modified":1547015865694},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1526970225271},{"_id":"themes/next/.git/logs/HEAD","hash":"f3a7037f41917bfd38b065508647e16b5010f6a5","modified":1526974925771},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1526970279379},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1526970279379},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1526970279381},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1526970279382},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1526970279383},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1526970279384},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1526970279386},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1526970279387},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1526970279388},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1526970279520},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1526970279515},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1526970279521},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1526970279523},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1526970279518},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1526970279526},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1526970279524},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1526970279528},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1526970279527},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1526970279531},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1526970279529},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1526970279530},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526970279533},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526970279535},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1526970279534},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1526970279536},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1526970279532},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1526970279537},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1526970225255},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1526970225259},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1526970225260},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1526970279538},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1526970225264},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1526970225267},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1526970225257},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1526970279279},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1526970279280},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1526970279283},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1526970225262},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1526970279284},{"_id":"themes/next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1526970225268},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1526970279289},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1526970279290},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1526970225265},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1526970279286},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1526970279288},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1526970279292},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1526970279301},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1526970279300},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1526970279302},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1526970279350},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1526970279351},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1526970279298},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1526970279352},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1526970279353},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1526970279291},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1526970279356},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1526970279314},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1526970279315},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1526970279323},{"_id":"source/_posts/jenkins持续集成前端项目实践/jenkins配置图.png","hash":"cd2340c336048cfd8c95f9d5da0c60847e107b5b","modified":1529913874623},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1526970279354},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279475},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279476},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279479},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1526970279355},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279511},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279514},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1526970279295},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279320},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526970279320},{"_id":"themes/next/.git/refs/heads/master","hash":"8d98b46b14cd1e912997dd12e8ebf8711cb50563","modified":1526974925770},{"_id":"themes/next/.git/objects/0b/9a1e9a2121d41519681677f074dc03239fd62b","hash":"b447395909ef8fe96508afa6364aa02de4fcbf9d","modified":1526974925769},{"_id":"themes/next/.git/objects/ba/306d5d438dd15d30bf13e369f5f32c6e1d9649","hash":"f33c745812ef25a8e9d9959f4e7f354e7f6f2c79","modified":1526974925654},{"_id":"themes/next/.git/objects/64/f6e4b551773cd4f03f98f013d76f7e80c87f5a","hash":"26579a7a8e043d354fa90e3b414de365528628cb","modified":1526974925765},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1526970279474},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1526970279477},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1526970279473},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1526970279510},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1526970279512},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1526970279509},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1526970279540},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1526970279513},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1526970279541},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1526970279478},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1526970279545},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1526970279544},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1526970279542},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1526970279546},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1526970279548},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1526970279551},{"_id":"source/_posts/拼团购活动开发总结/拼团购活动模型.png","hash":"806f2a437d3c27b2b7e011abefc0fc09b14ab421","modified":1541498144461},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1526970279552},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1526970279547},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1526970279554},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1526970279571},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1526970279582},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1526970279581},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1526970279577},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1526970279614},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1526970279612},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1526970279615},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1526970279616},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1526970279642},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1526970279611},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1526970279579},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1526970279655},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1526970279689},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1526970279654},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1526970279696},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1526970279691},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1526970279646},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1526970279647},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1526970279657},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1526970279650},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1526970279699},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1526970279651},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1526970279296},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1526970279297},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1526970279303},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1526970279305},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1526970279306},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1526970279676},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1526970279677},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1526970279698},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1526970279678},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1526970279659},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1526970279660},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1526970279662},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1526970279652},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1526970279664},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1526970279666},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1526970279667},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1526970279669},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1526970279649},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1526970279667},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1526970279670},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1526970279673},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1526970279663},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1526970279307},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1526970279309},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1526970279310},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1526970279674},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1526970279360},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1526970279312},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1526970279672},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1526970279364},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1526970279317},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1526970279326},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1526970279362},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1526970279328},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1526970279671},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1526970279330},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1526970279363},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1526970279331},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1526970279333},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1526970279334},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1526970279332},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1526970279336},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1526970279338},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1526970279327},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1526970279319},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1526970279322},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1526970279329},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1526970279335},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1526970279341},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1526970279340},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1526970279338},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1526970279345},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1526970279342},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1526970279344},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1526970279348},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1526970279603},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1526970279343},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1526970279346},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1526970279607},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1526970279347},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1526970279604},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1526970279645},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1526970279605},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1526970279205},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"f3a7037f41917bfd38b065508647e16b5010f6a5","modified":1526974925770},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1526970279465},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1526970279391},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1526970279394},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1526970279396},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1526970279414},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1526970279392},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1526970279394},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1526970279441},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1526970279494},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1526970279496},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1526970279497},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1526970279498},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1526970279499},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1526970279481},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1526970279470},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1526970279471},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1526970279467},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1526970279469},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1526970279502},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1526970279466},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1526970279471},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1526970279506},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1526970279503},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1526970279508},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1526970279483},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1526970279550},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1526970279486},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1526970279484},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1526970279487},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1526970279489},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1526970279507},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1526970279504},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1526970279488},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1526970279490},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1526970279563},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1526970279566},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1526970279568},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1526970279688},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1526970279687},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1526970279618},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1526970279621},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1526970279584},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1526970279619},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1526970279586},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1526970279588},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1526970279589},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1526970279358},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1526970279360},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1526970279585},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1526970279590},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1526970279600},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1526970279598},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1526970279695},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1526970279565},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"831be34320d247dcc87370369fceb0849974dd97","modified":1526970279211},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1526970279397},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1526970279639},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1526970279416},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1526970279609},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1526970279420},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1526970279418},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1526970279422},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1526970279419},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1526970279421},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1526970279417},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1526970279423},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1526970279426},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1526970279427},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1526970279425},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1526970279428},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1526970279430},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1526970279429},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1526970279424},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1526970279400},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1526970279401},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1526970279404},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1526970279431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1526970279432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1526970279434},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1526970279399},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1526970279435},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1526970279436},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1526970279437},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1526970279439},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1526970279608},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1526970279601},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1526970279402},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1526970279407},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1526970279405},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1526970279406},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1526970279444},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1526970279445},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1526970279440},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1526970279441},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1526970279448},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1526970279451},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1526970279447},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1526970279452},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1526970279450},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1526970279410},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1526970279411},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1526970279409},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1526970279443},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1526970279412},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1526970279501},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1526970279640},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1526970279491},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1526970279493},{"_id":"themes/next/.git/objects/pack/pack-0df40285cfd6ba61cd77b9db468522fa4a3564d9.idx","hash":"9bd7aefeb87914ecfb289a7b609bfefc37dd28e3","modified":1526970279135},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1526970279413},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1526970279438},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1526970279591},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1526970279449},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1526970279594},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1526970279596},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1526970279592},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1526970279594},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1526970279597},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1526970279556},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1526970279558},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1526970279559},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1526970279454},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1526970279456},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1526970279453},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1526970279458},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1526970279459},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1526970279460},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1526970279457},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1526970279462},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1526970279463},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1526970279627},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1526970279624},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1526970279637},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1526970279575},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1526970279684},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1526970279562},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1526970279634},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1526970279461},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1526970279560},{"_id":"themes/next/.git/objects/pack/pack-0df40285cfd6ba61cd77b9db468522fa4a3564d9.pack","hash":"b7b9af2417976ae7eab57dc0584d64df5654085a","modified":1526974925000},{"_id":"public/2019/01/08/加密签名与解密验签总结/index.html","hash":"0be35c8458011e137fb2fa6eb0d86c43e663dc95","modified":1548402776519},{"_id":"public/2019/01/10/javascript异常总结/index.html","hash":"9cef6f3446f0f0095dad1a69572a753261217850","modified":1548402776682},{"_id":"public/2018/12/13/javascript执行机制/index.html","hash":"1a6abdfa3584e8e647b074e86e65dbfd95070b39","modified":1548402776683},{"_id":"public/2018/07/28/神经网络梯度下降训练模型/index.html","hash":"4c66921fde4cad10501af6cf8441b8e949552f42","modified":1548402776683},{"_id":"public/2018/12/03/手动实现一个promise-A/index.html","hash":"78d85a0298539966507728e2143b3d22b9e6a404","modified":1548402776683},{"_id":"public/2018/11/02/营销活动数据采集方案/index.html","hash":"d93e9b7c67d03eaa2aef246c2a5aae835c497518","modified":1548402776683},{"_id":"public/2018/05/07/基于vue的埋点方案/index.html","hash":"bd787565fca874ff1fffaef7bff9e34cd8790de8","modified":1548402776683},{"_id":"public/archives/2018/06/index.html","hash":"c772eeeb8d2b98c879c90964129be9eec040cc24","modified":1548402776683},{"_id":"public/archives/2018/05/index.html","hash":"7b0ae3ceaac61c5167e4f85f9f87d19228c0fa45","modified":1548402776683},{"_id":"public/archives/2018/page/2/index.html","hash":"3dc38d8f132aacb9c06cd0c8941a385840e64637","modified":1548402776683},{"_id":"public/archives/2018/07/index.html","hash":"78ee5f5d6b591c0b49337aa67266faa441e9c1db","modified":1548402776684},{"_id":"public/archives/2018/09/index.html","hash":"06e1df9c727df03f26f6a0c6b4e02a9fa49c2770","modified":1548402776684},{"_id":"public/archives/2018/08/index.html","hash":"cad0730af85d761c735e244fea96ef942a2aea05","modified":1548402776684},{"_id":"public/archives/2019/index.html","hash":"db4b26db094aef9d75d18ef480c640e7ae50cf93","modified":1548402776684},{"_id":"public/archives/2019/01/index.html","hash":"10fe65bcfacfbecb6c657711052cb9860f70416a","modified":1548402776684},{"_id":"public/archives/2018/10/index.html","hash":"0cd584ecb0b026be4dcf41bf29bb2ded8a12d1b3","modified":1548402776684},{"_id":"public/archives/2018/11/index.html","hash":"73b7ea542455e4a5089f7b17d331fcb98f4962c6","modified":1548402776684},{"_id":"public/archives/2018/12/index.html","hash":"b4931080496ba2d5a3a7e58477bb3015e7aadfc8","modified":1548402776684},{"_id":"public/2019/01/25/易问web版浏览器支持方案分析/index.html","hash":"fe600529b9853517e811bcb9fc583ff22f798d7e","modified":1548402776684},{"_id":"public/2018/12/31/javascript实现继承的几种方式/index.html","hash":"0bef2b5d9a6e9e32f751208e4036880a38ff494a","modified":1548402776684},{"_id":"public/2018/11/05/拼团购活动开发总结/index.html","hash":"97c8400e1e8501452409252c54886d9f1371741f","modified":1548402776684},{"_id":"public/2018/10/12/vue渲染机制/index.html","hash":"517b602b0543f842dcdceb8eb97dca17236efbde","modified":1548402776684},{"_id":"public/2018/11/07/vue多页面-history路由模式的nginx配置/index.html","hash":"d97c47f08eee8603dbf36703c4b511ab09eb4807","modified":1548402776685},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/index.html","hash":"599ed04ea81940d0735fef70b631efa4a72c2958","modified":1548402776685},{"_id":"public/2018/08/03/规则配置界面设计/index.html","hash":"d2d2857db1503be1f992da837eb0291a587cce62","modified":1548402776685},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/index.html","hash":"09cf80b773e826a0e3536d26aea2ad111e96fc44","modified":1548402776685},{"_id":"public/2018/06/26/前端导出csv/index.html","hash":"ef361217c62c344c9006f5b5ca4fa436fb76e727","modified":1548402776685},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/index.html","hash":"a53fc24d53e3a56c42054d86bd1d462904113ca4","modified":1548402776685},{"_id":"public/2018/05/30/可视化编辑系统实践/index.html","hash":"3dfe396eb212bf53002f04f2f0d0504f364a7281","modified":1548402776685},{"_id":"public/2018/05/16/gitflow工作流程使用经验/index.html","hash":"0499b88a411f5ca90a550156ad7a345b665d2f7c","modified":1548402776685},{"_id":"public/2018/05/14/基于vue的管理系统权限管控方案/index.html","hash":"6917c41d2a0dc6edc09745c2960ff34428b58c09","modified":1548402776685},{"_id":"public/2018/09/06/nginx配置踩坑-rewrite/index.html","hash":"60578ecbe40468341e745b76bb9410e9f9b14974","modified":1548402776685},{"_id":"public/archives/index.html","hash":"6087cefd1ffe4fff7652ef1c7c0c01d6610f9863","modified":1548402776686},{"_id":"public/archives/2018/index.html","hash":"3bbd8da2ef858014ccc8de3d98f4d18a93487d6b","modified":1548402776686},{"_id":"public/archives/page/2/index.html","hash":"8ad9bfc7ccf25e303467c39b49ba97f3fa600203","modified":1548402776686},{"_id":"public/index.html","hash":"2a9711a56c46cd775f824dc9f59e48641bd88174","modified":1548402776686},{"_id":"public/page/2/index.html","hash":"d78f0a5b42f038b5815ad5d9928dd7a06faf5dbc","modified":1548402776686},{"_id":"public/archives/page/3/index.html","hash":"d9f22c7b4694f29f60386401b5639ebbb3706a21","modified":1548402776701},{"_id":"public/page/3/index.html","hash":"0680b3297fadf0d802aa3c288ccb5ee79c97f6f6","modified":1548402776701},{"_id":"public/uploads/avatar.jpg","hash":"6a95b7a5c59314de4dfbc371998151842af48ad5","modified":1548402776701},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1548402776701},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1548402776701},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1548402776701},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1548402776702},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1548402776702},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1548402776702},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1548402776702},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1548402776702},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1548402776702},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1548402776702},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1548402776702},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548402776702},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1548402776702},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1548402776702},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1548402776702},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548402776702},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1548402776703},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1548402776703},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1548402776703},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1548402776703},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1548402776703},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1548402776703},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1548402776703},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1548402776703},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1548402776703},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1548402776703},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1548402776703},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1548402776703},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1548402776703},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1548402776704},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1548402776704},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1548402776704},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1548402776704},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/md5戳不一致.jpg","hash":"ce0d2d3cf70733b8c239edfa48f4d5330a82cac2","modified":1548402776704},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/require引入方式.jpg","hash":"66cef0c781cf91e77704be5b59f6605aad43cdbe","modified":1548402776704},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译前.jpg","hash":"86805d901a8d83dbc73650c94b3a882020db6f16","modified":1548402776704},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/修正后.jpg","hash":"dc0212d0795fd3020dc31943364073289abfde9c","modified":1548402776704},{"_id":"public/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译后.jpg","hash":"e3e8d2ff86107ab61d3db267b57e7538e5361e64","modified":1548402776704},{"_id":"public/2018/05/16/gitflow工作流程使用经验/gitBash.jpg","hash":"7848ac10a4d350fbc553bc8c10e71f13ea6acc0e","modified":1548402776704},{"_id":"public/2018/05/16/gitflow工作流程使用经验/gitBranch.jpg","hash":"698021c663df461786ad5f073b6a09e9816f8e8a","modified":1548402776705},{"_id":"public/2018/10/12/vue渲染机制/$mount使用方法.jpg","hash":"e5af2d64ced4af0b7c1110b9820a072f8747da7f","modified":1548402776705},{"_id":"public/2018/10/12/vue渲染机制/vue渲染机制.png","hash":"b5b492b0c141b1f923eba675c2a9b4e789265e5b","modified":1548402776705},{"_id":"public/2019/01/08/加密签名与解密验签总结/签名验签流程--应对大量数据传输时的加密效率问题.jpg","hash":"306b20065b57b0653f9422fa53780acab4283034","modified":1548402776705},{"_id":"public/2019/01/08/加密签名与解密验签总结/签名验签流程.jpg","hash":"a5b708666f8e6c5a591904b9d581db99032c7e54","modified":1548402776705},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/FTP任务配置.jpg","hash":"e7ceef82e4948a4e0a16673ebc373d4e5552072e","modified":1548402776705},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/FTP配置.jpg","hash":"65e0ae53290cd020c42ab8f88ed1d342cf4c6a5c","modified":1548402776705},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/git配置.jpg","hash":"19c95790be75ee565373cf1f7515ee39595b0dca","modified":1548402776705},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/nodejs配置.jpg","hash":"8d216ffd9bd3e6432f120c8f8cf3f61dbb24c54a","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/构建.jpg","hash":"47704beabad124f7f16e716dbebb5fd1972123c3","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/构建环境.jpg","hash":"89c2f20be1f8636de716083e750a226d2067e00f","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/源码管理.jpg","hash":"e94a74b9f915a6be4c0b75bd59109ce416f65641","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/邮件提醒.jpg","hash":"9c00aada4b96fc505e90fc3274fe5c417f182ed3","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/邮件配置.jpg","hash":"a9a1792e20229b3aef524c95abe1dddb6f926d95","modified":1548402776706},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/界面化操作.jpg","hash":"81793fa00cd60d39ae104c1d84f3a8da426f092a","modified":1548402776707},{"_id":"public/2018/06/26/前端导出csv/table.jpg","hash":"f17b7bb7592841cb301b377ebf73313a62e6d73d","modified":1548402776707},{"_id":"public/2018/06/26/前端导出csv/test.jpg","hash":"b26e47d5d238dff2cceda03e1fd922bda2ad506b","modified":1548402776707},{"_id":"public/2018/06/26/前端导出csv/excel打开.jpg","hash":"3234c504954a81e6209be90b302bc6bc6d4bff6f","modified":1548402776707},{"_id":"public/2018/08/03/规则配置界面设计/父子组件交互设计.jpg","hash":"c6fcf94b46c1337eb7bf2a32076a8abe39338924","modified":1548402776707},{"_id":"public/2018/10/12/vue渲染机制/效果图.jpg","hash":"7c1e91a61d8a9ba47a17fecd0c660fd17a851bb6","modified":1548402776708},{"_id":"public/2018/08/03/规则配置界面设计/规则配置保存接口.png","hash":"759e787667429aefef3da85af6680fd685d3d862","modified":1548402776708},{"_id":"public/2018/08/03/规则配置界面设计/规则列表查询接口.png","hash":"6bba9a1aff728f996b08921cf123f95ce66a5eed","modified":1548402776708},{"_id":"public/2018/08/03/规则配置界面设计/规则配置流程.jpg","hash":"2b42c562937c567c9810897574af082e9cf2a53b","modified":1548402776708},{"_id":"public/2018/08/03/规则配置界面设计/语境图.jpg","hash":"1c37e7c4f1fbd04e1099768de209fb2447cab94f","modified":1548402776708},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/class兼容性.jpg","hash":"4ca1e11069206456f648f1a58783fed6d8975697","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/ios10报错.jpg","hash":"cb1a187188cc8872ab42c9c22e1843bbe9a6b10d","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/generators兼容性.jpg","hash":"155ea5cec7d4e9fab24d7e9cc30c5b3cc28fce5e","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/webpack配置.jpg","hash":"cb091059d41141411fe0fc102ad6ad2f5ae100b8","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/let兼容性.jpg","hash":"621093f5b5f664eddc1043aaa7cf21aa0f58e3f2","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/说明1.jpg","hash":"e7087ff5e4ad41e626236a5306df1569e6f912c2","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/说明2.jpg","hash":"214900fadcb712fc16eff932e14c7a4dee9a0ae4","modified":1548402776709},{"_id":"public/2018/07/17/首页在部分机型下白屏原因分析/箭头函数兼容性.jpg","hash":"f20cf3d006b8d4d5bfb020424a64d17c2f5fad60","modified":1548402776709},{"_id":"public/2018/05/14/基于vue的管理系统权限管控方案/SequenceDiagram.png","hash":"0845ad0cd31c49612e1232b6b8627c6d27eb55ee","modified":1548402776710},{"_id":"public/2018/05/14/基于vue的管理系统权限管控方案/menu.jpg","hash":"759f70c1e8924ebc906aef71f111c3a1d83bc480","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/approval.jpg","hash":"177e0b7baf132f48bddb2dcac35a14da36447d72","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/imageManage.jpg","hash":"7aa4c5e80d10b4cfb35b2959a0adf086c34a0114","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/approvalProcess.jpg","hash":"297c4c0e7722cd8e00ee144c8bd3b1a14aaa0df8","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/issue.jpg","hash":"1eea26f155dad2c4ebc4b73c9eef38eaae556ccd","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/flow.jpg","hash":"5540e8b00ce54c95ee027cf5a5d0e522437fc1a3","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/preview.jpg","hash":"765bfa3080969b2b331f3776eb4cb9307b6a3551","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/preview2.jpg","hash":"2228b1e8fef8990de625e3704669d0c44752842c","modified":1548402776710},{"_id":"public/2018/05/30/可视化编辑系统实践/workflow.jpg","hash":"44f019a3bb6a11e0dd6003110ef8ea3b54627e61","modified":1548402776711},{"_id":"public/2018/05/30/可视化编辑系统实践/qrcode.jpg","hash":"fdad1b48fac00e3516b5ae2d0a3b8656496cf5ee","modified":1548402776711},{"_id":"public/2018/05/30/可视化编辑系统实践/snapshot.jpg","hash":"9f90db4c8c3350fdfc57b7951f54fe557e4aa6c8","modified":1548402776711},{"_id":"public/2018/05/30/可视化编辑系统实践/workflow.png","hash":"7cf3b89ca91db956ceac0040cf67b7ce5fdae2ba","modified":1548402779891},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1548402779892},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1548402779906},{"_id":"public/2019/01/08/加密签名与解密验签总结/签名验签流程--增加数字证书流程.jpg","hash":"7ec41421ab5528a9a942f809a553b88fc3910102","modified":1548402779906},{"_id":"public/2018/05/16/gitflow工作流程使用经验/gitflow.png","hash":"64f53127384364b18c894babba9ea91df276c56e","modified":1548402779906},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/git配置异常.jpg","hash":"ef47458fc9ae77fc325c130631316484e7d0fa1c","modified":1548402779906},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/jenkins插件.jpg","hash":"82f969c97b71fb10949475261fdb24488e61e53f","modified":1548402779906},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/新建任务.jpg","hash":"9cfefcb569eea7bc9e04c26d7131ef28ff63782a","modified":1548402779906},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/构建日志.jpg","hash":"5c3798104b331bf1c561a851a9e173a292a35149","modified":1548402779906},{"_id":"public/2018/10/12/vue渲染机制/事件循环.png","hash":"5c32fb57c81a693eb6989d09d509f02aa06be94e","modified":1548402779907},{"_id":"public/2018/06/26/前端导出csv/导出excel.jpg","hash":"3953c7db0440511519c2e7f23dd58d1c6fcf6b01","modified":1548402779907},{"_id":"public/2018/08/03/规则配置界面设计/规则配置界面设计.jpg","hash":"e17d0cb2b0c55622511d662dc0701d1415efe6f2","modified":1548402779907},{"_id":"public/2018/06/26/前端导出csv/保存.jpg","hash":"b2aba23e28346137fe343f5142229c7d5ec6c07d","modified":1548402779907},{"_id":"public/2018/05/30/可视化编辑系统实践/history.jpg","hash":"5c89d900d35aa377493cf66c110ed6d46e9cdd2e","modified":1548402779907},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1548402779916},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1548402779916},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1548402779916},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1548402779916},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1548402779916},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1548402779916},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1548402779916},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1548402779916},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1548402779916},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1548402779916},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1548402779916},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1548402779916},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1548402779916},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1548402779917},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1548402779917},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1548402779917},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1548402779917},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1548402779917},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1548402779917},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1548402779917},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1548402779917},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1548402779917},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1548402779918},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1548402779918},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1548402779918},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1548402779918},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1548402779918},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1548402779918},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1548402779918},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1548402779918},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1548402779918},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1548402779918},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1548402779919},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1548402779919},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1548402779919},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1548402779919},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1548402779919},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1548402779919},{"_id":"public/css/main.css","hash":"f0caad38c0d29db8870ae78c698b1e5945f58d35","modified":1548402779919},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1548402779919},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1548402779919},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1548402779919},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1548402779919},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1548402779919},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1548402779919},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1548402779919},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1548402779920},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1548402779920},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1548402779920},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1548402779920},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1548402779920},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1548402779920},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1548402779920},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1548402779920},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1548402779920},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1548402779920},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1548402779920},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1548402779921},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1548402779921},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1548402779921},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1548402779921},{"_id":"public/2018/05/16/gitflow工作流程使用经验/sourceTree.jpg","hash":"3bfe713183a94125df3746ea106639ca816361a4","modified":1548402779921},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1548402779921},{"_id":"public/2018/06/21/jenkins持续集成前端项目实践/jenkins配置图.png","hash":"cd2340c336048cfd8c95f9d5da0c60847e107b5b","modified":1548402779978},{"_id":"public/2018/11/05/拼团购活动开发总结/拼团购活动模型.png","hash":"806f2a437d3c27b2b7e011abefc0fc09b14ab421","modified":1548402779985},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1548402779998}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决","date":"2018-08-10T15:32:11.000Z","_content":"背景\n---\n昨晚与shenjb讨论fis发布过程中，增加为资源文件增加md5戳的配置后，生成的文件与编辑过程中引用的位置所加的md5戳不相同，导致访问时，文件找不到；\n\n现象\n---\n当引入的js中使用模板引擎tpl时，就会出现md5戳不一致的情况，当js中不依赖tpl模板时，则不会出现这种现象\n\n分析\n---\n拿到简易版工程运行，出现md5戳不一致的问题：如下图\n![md5戳不一致](md5戳不一致.jpg)\n可以看到经过编译后生成的login.js的md5戳，与html中引用的不一致；\n\nfis的relase过程是先进行单文件编译，然后打包，最后生成文件；\n\n找到fis的源码，在relase命令的入口，找到增加md5戳的位置：\nrelease命令的入口在fis\\node_modules\\fis-kernel\\lib\\release.js文件中\n```\nvar res = ret.map.res[id] = {\n    uri  : file.getUrl(opt.hash, opt.domain),\n    type : file.rExt.replace(/^\\./, '')\n};\n```\n上面的代码中file.getUrl方法中会给当前文件增加md5戳，实际调用方法是file.getHash(),位于fis\\node_modules\\fis-kernel\\lib\\file.js中：\n```\ngetHash : function(){\n    if(typeof this._md5 === 'undefined'){\n        Object.defineProperty(this, '_md5', {\n            value : fis.util.md5(this.getContent()),\n            writable : true\n        });\n    }\n    return this._md5;\n},\n```\n这个方法根据文件的内容生成唯一的md5戳，内容有变化则md5戳也不同；\n\n那么我们就把文件内容和md5戳都打印出来：\n```\nif (file.id === \"portal-op-web-view/apps/serviceapps/login/js/login.js\") {\n    console.log(\"=============================\")\n    console.log(file._content)\n    console.log(file.getHash())\n    console.log(\"=============================\")\n}\nvar res = ret.map.res[id] = {\n    uri  : file.getUrl(opt.hash, opt.domain),\n    type : file.rExt.replace(/^\\./, '')\n};\n```\n打印结果：\n![编译前](编译前.jpg)\n\n然后找到生成文件的代码位于fis\\node_modules\\fis-command-release\\lib\\deploy.js\n在prepareDeploy方法中找到：\n```\nif (file.useHash && dest.opt.md5 > 0) {\n    release = file.getHashRelease(release);\n}\n```\n在getHashRelease方法中调用了getHash()来生成md5戳\n```\nfunction addHash(path, file){\n    var rExt  = file.rExt,\n        qRExt = fis.util.escapeReg(rExt),\n        qExt = fis.util.escapeReg(file.ext),\n        hash = file.getHash(),\n        onnector = fis.config.get('project.md5Connector', '_'),\n        reg = new RegExp(qRExt + '$|' + qExt + '$', 'i');\n    return path.replace(reg, '') + onnector + hash + rExt;\n}\n```\n接着在deploy中打印出md5值\n![编译后](编译后.jpg)\n\n\n可以看到，编译前的md5戳就是第一张图中，html引用的路径中出现的md5戳，而编译后的md5戳则是实际生成的文件所带有的md5戳\n\n在上面两张图中还同时标出了，文件内容变化的部分，也就是引用tpl模板的位置；\n\n提出假设\n---\n结合上述分析，我们可以提出一个相对靠谱的假设：\n由于js中依赖了tpl模板，在编译过程中，tpl被编译成js文件，并且在require中变为了绝对路径，这个变化导致login.js文件内容与之前不同，而生成文件的过程中，又根据文件内容再次获取md5加密值，所以二者不同；\n\n但是，在之前的使用中，也常常使用tpl模板，为什么没有出现这个的问题？\n\n比对之前的工程发现：\n原来的使用方式是：在html中通过require的方式引入js\n这次出问题的方式是：直接在html中通过script标签引入依赖了tpl的js文件\n![require引入方式](require引入方式.jpg)\n\n可以看到，改成require引入后，md5戳变一直了\n\n\n验证假设\n---\n可以明确，出问题的地方在tpl模板的编译过程，tpl模板编译在插件fis-postpackager-requiretpl中\n\n插件的逻辑是：在postpackager阶段（打包完成后）执行，循环所有经过编译的文件，当文件是html文件或是js文件时，执行parseFileD方法\n\n下面就是parseFileD方法的代码\n\n```\n    function parseFileD(file, ret, f) {\n        var content = file.getContent();\n        var reg = /define\\(([\\\"|\\']\\w*[\\\"|\\'],)?(\\[[^\\[]*\\])/g;\n        content = content.replace(reg, function(m, m1, m2) {\n            m1 = m1 ? m1 : \"\";\n            var m2 = eval('(' + m2 + ')');\n            for (var k = 0; k < m2.length; k++) {\n                if (m2[0] == \"template\" || m2[k].indexOf(\"tpl\") > -1) {;\n                    m2[k] = getHashPath(ret, m2[k], file, f);\n                }\n            }\n            return \"define(\" + m1 + JSON.stringify(m2);\n        });\n        var reg = /require\\((\\[[^\\[]*?\\])/g;\n        content = content.replace(reg, function(m, m1) {\n            var m1 = eval('(' + m1 + ')');\n            for (var k = 0; k < m1.length; k++) {\n                // if(m1[k].indexOf(\"tpl\")>-1){\n                m1[k] = getHashPath(ret, m1[k], file, f);\n                // }\n            }\n            return \"require(\" + JSON.stringify(m1);\n        });\n        var reg = /require\\([\"|'](.*?)[\"|']\\)/g;\n        content = content.replace(reg, function(m, m1) {\n            m1 = getHashPath(ret, m1, file, f);\n            return m1 = \"require('\" + m1 + \"')\";\n        });\n\n        if (file.getContent() != content) {\n            file._md5 = undefined;\n        }\n        file.setContent(content);\n        return content;\n    }\n```\n\n可以看到，parseFileD方法中有三个正则表达式，分别匹配define引入语句和require引入语句，require引入语句分为两种，引入单个文件或是多个文件\n\n当在文件内容中匹配到以上三个表达式时：\n1. 会根据引入路径，找到文件；\n2. 并根据当前的文件内容生成md5戳;\n3. 然后把md5戳加在引入路径的后面；\n4. 替换会文件内容中\n\n因此，当使用require引入js时，即使js文件内容因为tpl的原因，有所变换，这里会根据变化后的内容生成新的md5戳，并保存到相应的引入位置；\n\n而通过script标签引入的文件，在这里并没有处理，所以script标签引入的js文件md5戳，依然是变化前的；所以出现引入位置和实际文件的md5戳不同的问题；\n\n解决方案\n---\n知道了具体原因很容易就能想到解决方案：\n这要在fis-recommand-requiretpl的逻辑中，对script标签引入的js也进行正则匹配，修改成新的md5戳就好了\n\n```\nvar reg = /script(.*?)src=[\"|'](.*?)[_](.*?)[\"|']/g\ncontent = content.replace(reg, function (m, m1, m2, m3) {\n    m2 = getHashPath(ret, m2, file, f);\n    return \"script\" + m1 + \"src='\" + m2 + \"'\";\n});\n```\n\n这里存在两个问题：\n1、按照插件的逻辑，所有的html、js文件都会进行正则匹配，实际上js文件没有并不需要进行script标签的匹配；\n2、当html中引入的其他文件名中含有同样的连接符时(下划线)，会被错误匹配处理；\n\n为了解决这两个问题，把匹配script标签的逻辑单独抽离为独立的方法，并且只对html文件进行匹配，同时，当不需要md5戳时，也不需要进行匹配\n```\nif (file.isHtmlLike && opt.md5 === 1) { // html类文件，并且配置中存在md5戳时对script标签进行处理\n    parseFileHtmlScript(file, ret,file)\n}\n```\nparseFileHtmlScript方法中，对匹配内容进行二次处理，当文件名中存在与fis默认的连接符相同的字符时，找到最后一个连接符进行处理，避免影响到公共文件的引入\n```\nfunction parseFileHtmlScript(file, ret, f) {\n    var content = file.getContent();\n    var md5Connector = fis.config.get('project.md5Connector', '_')\n    var reg = new RegExp(\"script(.*?)src=[\\\"|\\'](.*?)[\"+ md5Connector +\"](.*?)[\\\"|\\']\", 'g')\n    content = content.replace(reg, function (m, m1, m2, m3) {\n        if (m3.indexOf(md5Connector) > -1) {\n            var index = m3.lastIndexOf(md5Connector)\n            m2 =  m2 + md5Connector + m3.substring(0,index)\n        }\n        var contextPath = fis.config.get('context_path')\n        if (opt.domain && m2.startsWith(contextPath)) {\n           m2 = m2.substring(contextPath.length)\n        }\n        var info = fis.uri(m2 + '.js', file.dirname);\n        if (info.file){\n            m2 = getHashPath(ret, m2, file, f);\n            return \"script\" + m1 + \"src='\" + m2 + \"'\";\n        }\n        return m\n    });\n    if (file.getContent() != content) {\n        file._md5 = undefined;\n    }\n    file.setContent(content);\n    return content;\n}\n```\n\n运行结果：\n![修正后](修正后.jpg)\n\n\n\n\n","source":"_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决.md","raw":"---\ntitle: fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决\ndate: 2018-08-10 15:32:11\ntags:\n---\n背景\n---\n昨晚与shenjb讨论fis发布过程中，增加为资源文件增加md5戳的配置后，生成的文件与编辑过程中引用的位置所加的md5戳不相同，导致访问时，文件找不到；\n\n现象\n---\n当引入的js中使用模板引擎tpl时，就会出现md5戳不一致的情况，当js中不依赖tpl模板时，则不会出现这种现象\n\n分析\n---\n拿到简易版工程运行，出现md5戳不一致的问题：如下图\n![md5戳不一致](md5戳不一致.jpg)\n可以看到经过编译后生成的login.js的md5戳，与html中引用的不一致；\n\nfis的relase过程是先进行单文件编译，然后打包，最后生成文件；\n\n找到fis的源码，在relase命令的入口，找到增加md5戳的位置：\nrelease命令的入口在fis\\node_modules\\fis-kernel\\lib\\release.js文件中\n```\nvar res = ret.map.res[id] = {\n    uri  : file.getUrl(opt.hash, opt.domain),\n    type : file.rExt.replace(/^\\./, '')\n};\n```\n上面的代码中file.getUrl方法中会给当前文件增加md5戳，实际调用方法是file.getHash(),位于fis\\node_modules\\fis-kernel\\lib\\file.js中：\n```\ngetHash : function(){\n    if(typeof this._md5 === 'undefined'){\n        Object.defineProperty(this, '_md5', {\n            value : fis.util.md5(this.getContent()),\n            writable : true\n        });\n    }\n    return this._md5;\n},\n```\n这个方法根据文件的内容生成唯一的md5戳，内容有变化则md5戳也不同；\n\n那么我们就把文件内容和md5戳都打印出来：\n```\nif (file.id === \"portal-op-web-view/apps/serviceapps/login/js/login.js\") {\n    console.log(\"=============================\")\n    console.log(file._content)\n    console.log(file.getHash())\n    console.log(\"=============================\")\n}\nvar res = ret.map.res[id] = {\n    uri  : file.getUrl(opt.hash, opt.domain),\n    type : file.rExt.replace(/^\\./, '')\n};\n```\n打印结果：\n![编译前](编译前.jpg)\n\n然后找到生成文件的代码位于fis\\node_modules\\fis-command-release\\lib\\deploy.js\n在prepareDeploy方法中找到：\n```\nif (file.useHash && dest.opt.md5 > 0) {\n    release = file.getHashRelease(release);\n}\n```\n在getHashRelease方法中调用了getHash()来生成md5戳\n```\nfunction addHash(path, file){\n    var rExt  = file.rExt,\n        qRExt = fis.util.escapeReg(rExt),\n        qExt = fis.util.escapeReg(file.ext),\n        hash = file.getHash(),\n        onnector = fis.config.get('project.md5Connector', '_'),\n        reg = new RegExp(qRExt + '$|' + qExt + '$', 'i');\n    return path.replace(reg, '') + onnector + hash + rExt;\n}\n```\n接着在deploy中打印出md5值\n![编译后](编译后.jpg)\n\n\n可以看到，编译前的md5戳就是第一张图中，html引用的路径中出现的md5戳，而编译后的md5戳则是实际生成的文件所带有的md5戳\n\n在上面两张图中还同时标出了，文件内容变化的部分，也就是引用tpl模板的位置；\n\n提出假设\n---\n结合上述分析，我们可以提出一个相对靠谱的假设：\n由于js中依赖了tpl模板，在编译过程中，tpl被编译成js文件，并且在require中变为了绝对路径，这个变化导致login.js文件内容与之前不同，而生成文件的过程中，又根据文件内容再次获取md5加密值，所以二者不同；\n\n但是，在之前的使用中，也常常使用tpl模板，为什么没有出现这个的问题？\n\n比对之前的工程发现：\n原来的使用方式是：在html中通过require的方式引入js\n这次出问题的方式是：直接在html中通过script标签引入依赖了tpl的js文件\n![require引入方式](require引入方式.jpg)\n\n可以看到，改成require引入后，md5戳变一直了\n\n\n验证假设\n---\n可以明确，出问题的地方在tpl模板的编译过程，tpl模板编译在插件fis-postpackager-requiretpl中\n\n插件的逻辑是：在postpackager阶段（打包完成后）执行，循环所有经过编译的文件，当文件是html文件或是js文件时，执行parseFileD方法\n\n下面就是parseFileD方法的代码\n\n```\n    function parseFileD(file, ret, f) {\n        var content = file.getContent();\n        var reg = /define\\(([\\\"|\\']\\w*[\\\"|\\'],)?(\\[[^\\[]*\\])/g;\n        content = content.replace(reg, function(m, m1, m2) {\n            m1 = m1 ? m1 : \"\";\n            var m2 = eval('(' + m2 + ')');\n            for (var k = 0; k < m2.length; k++) {\n                if (m2[0] == \"template\" || m2[k].indexOf(\"tpl\") > -1) {;\n                    m2[k] = getHashPath(ret, m2[k], file, f);\n                }\n            }\n            return \"define(\" + m1 + JSON.stringify(m2);\n        });\n        var reg = /require\\((\\[[^\\[]*?\\])/g;\n        content = content.replace(reg, function(m, m1) {\n            var m1 = eval('(' + m1 + ')');\n            for (var k = 0; k < m1.length; k++) {\n                // if(m1[k].indexOf(\"tpl\")>-1){\n                m1[k] = getHashPath(ret, m1[k], file, f);\n                // }\n            }\n            return \"require(\" + JSON.stringify(m1);\n        });\n        var reg = /require\\([\"|'](.*?)[\"|']\\)/g;\n        content = content.replace(reg, function(m, m1) {\n            m1 = getHashPath(ret, m1, file, f);\n            return m1 = \"require('\" + m1 + \"')\";\n        });\n\n        if (file.getContent() != content) {\n            file._md5 = undefined;\n        }\n        file.setContent(content);\n        return content;\n    }\n```\n\n可以看到，parseFileD方法中有三个正则表达式，分别匹配define引入语句和require引入语句，require引入语句分为两种，引入单个文件或是多个文件\n\n当在文件内容中匹配到以上三个表达式时：\n1. 会根据引入路径，找到文件；\n2. 并根据当前的文件内容生成md5戳;\n3. 然后把md5戳加在引入路径的后面；\n4. 替换会文件内容中\n\n因此，当使用require引入js时，即使js文件内容因为tpl的原因，有所变换，这里会根据变化后的内容生成新的md5戳，并保存到相应的引入位置；\n\n而通过script标签引入的文件，在这里并没有处理，所以script标签引入的js文件md5戳，依然是变化前的；所以出现引入位置和实际文件的md5戳不同的问题；\n\n解决方案\n---\n知道了具体原因很容易就能想到解决方案：\n这要在fis-recommand-requiretpl的逻辑中，对script标签引入的js也进行正则匹配，修改成新的md5戳就好了\n\n```\nvar reg = /script(.*?)src=[\"|'](.*?)[_](.*?)[\"|']/g\ncontent = content.replace(reg, function (m, m1, m2, m3) {\n    m2 = getHashPath(ret, m2, file, f);\n    return \"script\" + m1 + \"src='\" + m2 + \"'\";\n});\n```\n\n这里存在两个问题：\n1、按照插件的逻辑，所有的html、js文件都会进行正则匹配，实际上js文件没有并不需要进行script标签的匹配；\n2、当html中引入的其他文件名中含有同样的连接符时(下划线)，会被错误匹配处理；\n\n为了解决这两个问题，把匹配script标签的逻辑单独抽离为独立的方法，并且只对html文件进行匹配，同时，当不需要md5戳时，也不需要进行匹配\n```\nif (file.isHtmlLike && opt.md5 === 1) { // html类文件，并且配置中存在md5戳时对script标签进行处理\n    parseFileHtmlScript(file, ret,file)\n}\n```\nparseFileHtmlScript方法中，对匹配内容进行二次处理，当文件名中存在与fis默认的连接符相同的字符时，找到最后一个连接符进行处理，避免影响到公共文件的引入\n```\nfunction parseFileHtmlScript(file, ret, f) {\n    var content = file.getContent();\n    var md5Connector = fis.config.get('project.md5Connector', '_')\n    var reg = new RegExp(\"script(.*?)src=[\\\"|\\'](.*?)[\"+ md5Connector +\"](.*?)[\\\"|\\']\", 'g')\n    content = content.replace(reg, function (m, m1, m2, m3) {\n        if (m3.indexOf(md5Connector) > -1) {\n            var index = m3.lastIndexOf(md5Connector)\n            m2 =  m2 + md5Connector + m3.substring(0,index)\n        }\n        var contextPath = fis.config.get('context_path')\n        if (opt.domain && m2.startsWith(contextPath)) {\n           m2 = m2.substring(contextPath.length)\n        }\n        var info = fis.uri(m2 + '.js', file.dirname);\n        if (info.file){\n            m2 = getHashPath(ret, m2, file, f);\n            return \"script\" + m1 + \"src='\" + m2 + \"'\";\n        }\n        return m\n    });\n    if (file.getContent() != content) {\n        file._md5 = undefined;\n    }\n    file.setContent(content);\n    return content;\n}\n```\n\n运行结果：\n![修正后](修正后.jpg)\n\n\n\n\n","slug":"fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决","published":1,"updated":"2018-08-20T10:25:35.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11ng00002om2gcbsclmj","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>昨晚与shenjb讨论fis发布过程中，增加为资源文件增加md5戳的配置后，生成的文件与编辑过程中引用的位置所加的md5戳不相同，导致访问时，文件找不到；</p>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当引入的js中使用模板引擎tpl时，就会出现md5戳不一致的情况，当js中不依赖tpl模板时，则不会出现这种现象</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>拿到简易版工程运行，出现md5戳不一致的问题：如下图<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/md5戳不一致.jpg\" alt=\"md5戳不一致\"><br>可以看到经过编译后生成的login.js的md5戳，与html中引用的不一致；</p>\n<p>fis的relase过程是先进行单文件编译，然后打包，最后生成文件；</p>\n<p>找到fis的源码，在relase命令的入口，找到增加md5戳的位置：<br>release命令的入口在fis\\node_modules\\fis-kernel\\lib\\release.js文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var res = ret.map.res[id] = &#123;</span><br><span class=\"line\">    uri  : file.getUrl(opt.hash, opt.domain),</span><br><span class=\"line\">    type : file.rExt.replace(/^\\./, &apos;&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中file.getUrl方法中会给当前文件增加md5戳，实际调用方法是file.getHash(),位于fis\\node_modules\\fis-kernel\\lib\\file.js中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getHash : function()&#123;</span><br><span class=\"line\">    if(typeof this._md5 === &apos;undefined&apos;)&#123;</span><br><span class=\"line\">        Object.defineProperty(this, &apos;_md5&apos;, &#123;</span><br><span class=\"line\">            value : fis.util.md5(this.getContent()),</span><br><span class=\"line\">            writable : true</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this._md5;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>这个方法根据文件的内容生成唯一的md5戳，内容有变化则md5戳也不同；</p>\n<p>那么我们就把文件内容和md5戳都打印出来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.id === &quot;portal-op-web-view/apps/serviceapps/login/js/login.js&quot;) &#123;</span><br><span class=\"line\">    console.log(&quot;=============================&quot;)</span><br><span class=\"line\">    console.log(file._content)</span><br><span class=\"line\">    console.log(file.getHash())</span><br><span class=\"line\">    console.log(&quot;=============================&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var res = ret.map.res[id] = &#123;</span><br><span class=\"line\">    uri  : file.getUrl(opt.hash, opt.domain),</span><br><span class=\"line\">    type : file.rExt.replace(/^\\./, &apos;&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>打印结果：<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译前.jpg\" alt=\"编译前\"></p>\n<p>然后找到生成文件的代码位于fis\\node_modules\\fis-command-release\\lib\\deploy.js<br>在prepareDeploy方法中找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.useHash &amp;&amp; dest.opt.md5 &gt; 0) &#123;</span><br><span class=\"line\">    release = file.getHashRelease(release);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在getHashRelease方法中调用了getHash()来生成md5戳<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addHash(path, file)&#123;</span><br><span class=\"line\">    var rExt  = file.rExt,</span><br><span class=\"line\">        qRExt = fis.util.escapeReg(rExt),</span><br><span class=\"line\">        qExt = fis.util.escapeReg(file.ext),</span><br><span class=\"line\">        hash = file.getHash(),</span><br><span class=\"line\">        onnector = fis.config.get(&apos;project.md5Connector&apos;, &apos;_&apos;),</span><br><span class=\"line\">        reg = new RegExp(qRExt + &apos;$|&apos; + qExt + &apos;$&apos;, &apos;i&apos;);</span><br><span class=\"line\">    return path.replace(reg, &apos;&apos;) + onnector + hash + rExt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着在deploy中打印出md5值<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译后.jpg\" alt=\"编译后\"></p>\n<p>可以看到，编译前的md5戳就是第一张图中，html引用的路径中出现的md5戳，而编译后的md5戳则是实际生成的文件所带有的md5戳</p>\n<p>在上面两张图中还同时标出了，文件内容变化的部分，也就是引用tpl模板的位置；</p>\n<h2 id=\"提出假设\"><a href=\"#提出假设\" class=\"headerlink\" title=\"提出假设\"></a>提出假设</h2><p>结合上述分析，我们可以提出一个相对靠谱的假设：<br>由于js中依赖了tpl模板，在编译过程中，tpl被编译成js文件，并且在require中变为了绝对路径，这个变化导致login.js文件内容与之前不同，而生成文件的过程中，又根据文件内容再次获取md5加密值，所以二者不同；</p>\n<p>但是，在之前的使用中，也常常使用tpl模板，为什么没有出现这个的问题？</p>\n<p>比对之前的工程发现：<br>原来的使用方式是：在html中通过require的方式引入js<br>这次出问题的方式是：直接在html中通过script标签引入依赖了tpl的js文件<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/require引入方式.jpg\" alt=\"require引入方式\"></p>\n<p>可以看到，改成require引入后，md5戳变一直了</p>\n<h2 id=\"验证假设\"><a href=\"#验证假设\" class=\"headerlink\" title=\"验证假设\"></a>验证假设</h2><p>可以明确，出问题的地方在tpl模板的编译过程，tpl模板编译在插件fis-postpackager-requiretpl中</p>\n<p>插件的逻辑是：在postpackager阶段（打包完成后）执行，循环所有经过编译的文件，当文件是html文件或是js文件时，执行parseFileD方法</p>\n<p>下面就是parseFileD方法的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function parseFileD(file, ret, f) &#123;</span><br><span class=\"line\">    var content = file.getContent();</span><br><span class=\"line\">    var reg = /define\\(([\\&quot;|\\&apos;]\\w*[\\&quot;|\\&apos;],)?(\\[[^\\[]*\\])/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1, m2) &#123;</span><br><span class=\"line\">        m1 = m1 ? m1 : &quot;&quot;;</span><br><span class=\"line\">        var m2 = eval(&apos;(&apos; + m2 + &apos;)&apos;);</span><br><span class=\"line\">        for (var k = 0; k &lt; m2.length; k++) &#123;</span><br><span class=\"line\">            if (m2[0] == &quot;template&quot; || m2[k].indexOf(&quot;tpl&quot;) &gt; -1) &#123;;</span><br><span class=\"line\">                m2[k] = getHashPath(ret, m2[k], file, f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;define(&quot; + m1 + JSON.stringify(m2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    var reg = /require\\((\\[[^\\[]*?\\])/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1) &#123;</span><br><span class=\"line\">        var m1 = eval(&apos;(&apos; + m1 + &apos;)&apos;);</span><br><span class=\"line\">        for (var k = 0; k &lt; m1.length; k++) &#123;</span><br><span class=\"line\">            // if(m1[k].indexOf(&quot;tpl&quot;)&gt;-1)&#123;</span><br><span class=\"line\">            m1[k] = getHashPath(ret, m1[k], file, f);</span><br><span class=\"line\">            // &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;require(&quot; + JSON.stringify(m1);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    var reg = /require\\([&quot;|&apos;](.*?)[&quot;|&apos;]\\)/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1) &#123;</span><br><span class=\"line\">        m1 = getHashPath(ret, m1, file, f);</span><br><span class=\"line\">        return m1 = &quot;require(&apos;&quot; + m1 + &quot;&apos;)&quot;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (file.getContent() != content) &#123;</span><br><span class=\"line\">        file._md5 = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.setContent(content);</span><br><span class=\"line\">    return content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，parseFileD方法中有三个正则表达式，分别匹配define引入语句和require引入语句，require引入语句分为两种，引入单个文件或是多个文件</p>\n<p>当在文件内容中匹配到以上三个表达式时：</p>\n<ol>\n<li>会根据引入路径，找到文件；</li>\n<li>并根据当前的文件内容生成md5戳;</li>\n<li>然后把md5戳加在引入路径的后面；</li>\n<li>替换会文件内容中</li>\n</ol>\n<p>因此，当使用require引入js时，即使js文件内容因为tpl的原因，有所变换，这里会根据变化后的内容生成新的md5戳，并保存到相应的引入位置；</p>\n<p>而通过script标签引入的文件，在这里并没有处理，所以script标签引入的js文件md5戳，依然是变化前的；所以出现引入位置和实际文件的md5戳不同的问题；</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>知道了具体原因很容易就能想到解决方案：<br>这要在fis-recommand-requiretpl的逻辑中，对script标签引入的js也进行正则匹配，修改成新的md5戳就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = /script(.*?)src=[&quot;|&apos;](.*?)[_](.*?)[&quot;|&apos;]/g</span><br><span class=\"line\">content = content.replace(reg, function (m, m1, m2, m3) &#123;</span><br><span class=\"line\">    m2 = getHashPath(ret, m2, file, f);</span><br><span class=\"line\">    return &quot;script&quot; + m1 + &quot;src=&apos;&quot; + m2 + &quot;&apos;&quot;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里存在两个问题：<br>1、按照插件的逻辑，所有的html、js文件都会进行正则匹配，实际上js文件没有并不需要进行script标签的匹配；<br>2、当html中引入的其他文件名中含有同样的连接符时(下划线)，会被错误匹配处理；</p>\n<p>为了解决这两个问题，把匹配script标签的逻辑单独抽离为独立的方法，并且只对html文件进行匹配，同时，当不需要md5戳时，也不需要进行匹配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.isHtmlLike &amp;&amp; opt.md5 === 1) &#123; // html类文件，并且配置中存在md5戳时对script标签进行处理</span><br><span class=\"line\">    parseFileHtmlScript(file, ret,file)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>parseFileHtmlScript方法中，对匹配内容进行二次处理，当文件名中存在与fis默认的连接符相同的字符时，找到最后一个连接符进行处理，避免影响到公共文件的引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function parseFileHtmlScript(file, ret, f) &#123;</span><br><span class=\"line\">    var content = file.getContent();</span><br><span class=\"line\">    var md5Connector = fis.config.get(&apos;project.md5Connector&apos;, &apos;_&apos;)</span><br><span class=\"line\">    var reg = new RegExp(&quot;script(.*?)src=[\\&quot;|\\&apos;](.*?)[&quot;+ md5Connector +&quot;](.*?)[\\&quot;|\\&apos;]&quot;, &apos;g&apos;)</span><br><span class=\"line\">    content = content.replace(reg, function (m, m1, m2, m3) &#123;</span><br><span class=\"line\">        if (m3.indexOf(md5Connector) &gt; -1) &#123;</span><br><span class=\"line\">            var index = m3.lastIndexOf(md5Connector)</span><br><span class=\"line\">            m2 =  m2 + md5Connector + m3.substring(0,index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var contextPath = fis.config.get(&apos;context_path&apos;)</span><br><span class=\"line\">        if (opt.domain &amp;&amp; m2.startsWith(contextPath)) &#123;</span><br><span class=\"line\">           m2 = m2.substring(contextPath.length)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var info = fis.uri(m2 + &apos;.js&apos;, file.dirname);</span><br><span class=\"line\">        if (info.file)&#123;</span><br><span class=\"line\">            m2 = getHashPath(ret, m2, file, f);</span><br><span class=\"line\">            return &quot;script&quot; + m1 + &quot;src=&apos;&quot; + m2 + &quot;&apos;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return m</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (file.getContent() != content) &#123;</span><br><span class=\"line\">        file._md5 = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.setContent(content);</span><br><span class=\"line\">    return content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/修正后.jpg\" alt=\"修正后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>昨晚与shenjb讨论fis发布过程中，增加为资源文件增加md5戳的配置后，生成的文件与编辑过程中引用的位置所加的md5戳不相同，导致访问时，文件找不到；</p>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>当引入的js中使用模板引擎tpl时，就会出现md5戳不一致的情况，当js中不依赖tpl模板时，则不会出现这种现象</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>拿到简易版工程运行，出现md5戳不一致的问题：如下图<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/md5戳不一致.jpg\" alt=\"md5戳不一致\"><br>可以看到经过编译后生成的login.js的md5戳，与html中引用的不一致；</p>\n<p>fis的relase过程是先进行单文件编译，然后打包，最后生成文件；</p>\n<p>找到fis的源码，在relase命令的入口，找到增加md5戳的位置：<br>release命令的入口在fis\\node_modules\\fis-kernel\\lib\\release.js文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var res = ret.map.res[id] = &#123;</span><br><span class=\"line\">    uri  : file.getUrl(opt.hash, opt.domain),</span><br><span class=\"line\">    type : file.rExt.replace(/^\\./, &apos;&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中file.getUrl方法中会给当前文件增加md5戳，实际调用方法是file.getHash(),位于fis\\node_modules\\fis-kernel\\lib\\file.js中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getHash : function()&#123;</span><br><span class=\"line\">    if(typeof this._md5 === &apos;undefined&apos;)&#123;</span><br><span class=\"line\">        Object.defineProperty(this, &apos;_md5&apos;, &#123;</span><br><span class=\"line\">            value : fis.util.md5(this.getContent()),</span><br><span class=\"line\">            writable : true</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this._md5;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>这个方法根据文件的内容生成唯一的md5戳，内容有变化则md5戳也不同；</p>\n<p>那么我们就把文件内容和md5戳都打印出来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.id === &quot;portal-op-web-view/apps/serviceapps/login/js/login.js&quot;) &#123;</span><br><span class=\"line\">    console.log(&quot;=============================&quot;)</span><br><span class=\"line\">    console.log(file._content)</span><br><span class=\"line\">    console.log(file.getHash())</span><br><span class=\"line\">    console.log(&quot;=============================&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var res = ret.map.res[id] = &#123;</span><br><span class=\"line\">    uri  : file.getUrl(opt.hash, opt.domain),</span><br><span class=\"line\">    type : file.rExt.replace(/^\\./, &apos;&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>打印结果：<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译前.jpg\" alt=\"编译前\"></p>\n<p>然后找到生成文件的代码位于fis\\node_modules\\fis-command-release\\lib\\deploy.js<br>在prepareDeploy方法中找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.useHash &amp;&amp; dest.opt.md5 &gt; 0) &#123;</span><br><span class=\"line\">    release = file.getHashRelease(release);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在getHashRelease方法中调用了getHash()来生成md5戳<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addHash(path, file)&#123;</span><br><span class=\"line\">    var rExt  = file.rExt,</span><br><span class=\"line\">        qRExt = fis.util.escapeReg(rExt),</span><br><span class=\"line\">        qExt = fis.util.escapeReg(file.ext),</span><br><span class=\"line\">        hash = file.getHash(),</span><br><span class=\"line\">        onnector = fis.config.get(&apos;project.md5Connector&apos;, &apos;_&apos;),</span><br><span class=\"line\">        reg = new RegExp(qRExt + &apos;$|&apos; + qExt + &apos;$&apos;, &apos;i&apos;);</span><br><span class=\"line\">    return path.replace(reg, &apos;&apos;) + onnector + hash + rExt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着在deploy中打印出md5值<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译后.jpg\" alt=\"编译后\"></p>\n<p>可以看到，编译前的md5戳就是第一张图中，html引用的路径中出现的md5戳，而编译后的md5戳则是实际生成的文件所带有的md5戳</p>\n<p>在上面两张图中还同时标出了，文件内容变化的部分，也就是引用tpl模板的位置；</p>\n<h2 id=\"提出假设\"><a href=\"#提出假设\" class=\"headerlink\" title=\"提出假设\"></a>提出假设</h2><p>结合上述分析，我们可以提出一个相对靠谱的假设：<br>由于js中依赖了tpl模板，在编译过程中，tpl被编译成js文件，并且在require中变为了绝对路径，这个变化导致login.js文件内容与之前不同，而生成文件的过程中，又根据文件内容再次获取md5加密值，所以二者不同；</p>\n<p>但是，在之前的使用中，也常常使用tpl模板，为什么没有出现这个的问题？</p>\n<p>比对之前的工程发现：<br>原来的使用方式是：在html中通过require的方式引入js<br>这次出问题的方式是：直接在html中通过script标签引入依赖了tpl的js文件<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/require引入方式.jpg\" alt=\"require引入方式\"></p>\n<p>可以看到，改成require引入后，md5戳变一直了</p>\n<h2 id=\"验证假设\"><a href=\"#验证假设\" class=\"headerlink\" title=\"验证假设\"></a>验证假设</h2><p>可以明确，出问题的地方在tpl模板的编译过程，tpl模板编译在插件fis-postpackager-requiretpl中</p>\n<p>插件的逻辑是：在postpackager阶段（打包完成后）执行，循环所有经过编译的文件，当文件是html文件或是js文件时，执行parseFileD方法</p>\n<p>下面就是parseFileD方法的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function parseFileD(file, ret, f) &#123;</span><br><span class=\"line\">    var content = file.getContent();</span><br><span class=\"line\">    var reg = /define\\(([\\&quot;|\\&apos;]\\w*[\\&quot;|\\&apos;],)?(\\[[^\\[]*\\])/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1, m2) &#123;</span><br><span class=\"line\">        m1 = m1 ? m1 : &quot;&quot;;</span><br><span class=\"line\">        var m2 = eval(&apos;(&apos; + m2 + &apos;)&apos;);</span><br><span class=\"line\">        for (var k = 0; k &lt; m2.length; k++) &#123;</span><br><span class=\"line\">            if (m2[0] == &quot;template&quot; || m2[k].indexOf(&quot;tpl&quot;) &gt; -1) &#123;;</span><br><span class=\"line\">                m2[k] = getHashPath(ret, m2[k], file, f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;define(&quot; + m1 + JSON.stringify(m2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    var reg = /require\\((\\[[^\\[]*?\\])/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1) &#123;</span><br><span class=\"line\">        var m1 = eval(&apos;(&apos; + m1 + &apos;)&apos;);</span><br><span class=\"line\">        for (var k = 0; k &lt; m1.length; k++) &#123;</span><br><span class=\"line\">            // if(m1[k].indexOf(&quot;tpl&quot;)&gt;-1)&#123;</span><br><span class=\"line\">            m1[k] = getHashPath(ret, m1[k], file, f);</span><br><span class=\"line\">            // &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;require(&quot; + JSON.stringify(m1);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    var reg = /require\\([&quot;|&apos;](.*?)[&quot;|&apos;]\\)/g;</span><br><span class=\"line\">    content = content.replace(reg, function(m, m1) &#123;</span><br><span class=\"line\">        m1 = getHashPath(ret, m1, file, f);</span><br><span class=\"line\">        return m1 = &quot;require(&apos;&quot; + m1 + &quot;&apos;)&quot;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (file.getContent() != content) &#123;</span><br><span class=\"line\">        file._md5 = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.setContent(content);</span><br><span class=\"line\">    return content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，parseFileD方法中有三个正则表达式，分别匹配define引入语句和require引入语句，require引入语句分为两种，引入单个文件或是多个文件</p>\n<p>当在文件内容中匹配到以上三个表达式时：</p>\n<ol>\n<li>会根据引入路径，找到文件；</li>\n<li>并根据当前的文件内容生成md5戳;</li>\n<li>然后把md5戳加在引入路径的后面；</li>\n<li>替换会文件内容中</li>\n</ol>\n<p>因此，当使用require引入js时，即使js文件内容因为tpl的原因，有所变换，这里会根据变化后的内容生成新的md5戳，并保存到相应的引入位置；</p>\n<p>而通过script标签引入的文件，在这里并没有处理，所以script标签引入的js文件md5戳，依然是变化前的；所以出现引入位置和实际文件的md5戳不同的问题；</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>知道了具体原因很容易就能想到解决方案：<br>这要在fis-recommand-requiretpl的逻辑中，对script标签引入的js也进行正则匹配，修改成新的md5戳就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = /script(.*?)src=[&quot;|&apos;](.*?)[_](.*?)[&quot;|&apos;]/g</span><br><span class=\"line\">content = content.replace(reg, function (m, m1, m2, m3) &#123;</span><br><span class=\"line\">    m2 = getHashPath(ret, m2, file, f);</span><br><span class=\"line\">    return &quot;script&quot; + m1 + &quot;src=&apos;&quot; + m2 + &quot;&apos;&quot;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里存在两个问题：<br>1、按照插件的逻辑，所有的html、js文件都会进行正则匹配，实际上js文件没有并不需要进行script标签的匹配；<br>2、当html中引入的其他文件名中含有同样的连接符时(下划线)，会被错误匹配处理；</p>\n<p>为了解决这两个问题，把匹配script标签的逻辑单独抽离为独立的方法，并且只对html文件进行匹配，同时，当不需要md5戳时，也不需要进行匹配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (file.isHtmlLike &amp;&amp; opt.md5 === 1) &#123; // html类文件，并且配置中存在md5戳时对script标签进行处理</span><br><span class=\"line\">    parseFileHtmlScript(file, ret,file)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>parseFileHtmlScript方法中，对匹配内容进行二次处理，当文件名中存在与fis默认的连接符相同的字符时，找到最后一个连接符进行处理，避免影响到公共文件的引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function parseFileHtmlScript(file, ret, f) &#123;</span><br><span class=\"line\">    var content = file.getContent();</span><br><span class=\"line\">    var md5Connector = fis.config.get(&apos;project.md5Connector&apos;, &apos;_&apos;)</span><br><span class=\"line\">    var reg = new RegExp(&quot;script(.*?)src=[\\&quot;|\\&apos;](.*?)[&quot;+ md5Connector +&quot;](.*?)[\\&quot;|\\&apos;]&quot;, &apos;g&apos;)</span><br><span class=\"line\">    content = content.replace(reg, function (m, m1, m2, m3) &#123;</span><br><span class=\"line\">        if (m3.indexOf(md5Connector) &gt; -1) &#123;</span><br><span class=\"line\">            var index = m3.lastIndexOf(md5Connector)</span><br><span class=\"line\">            m2 =  m2 + md5Connector + m3.substring(0,index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var contextPath = fis.config.get(&apos;context_path&apos;)</span><br><span class=\"line\">        if (opt.domain &amp;&amp; m2.startsWith(contextPath)) &#123;</span><br><span class=\"line\">           m2 = m2.substring(contextPath.length)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var info = fis.uri(m2 + &apos;.js&apos;, file.dirname);</span><br><span class=\"line\">        if (info.file)&#123;</span><br><span class=\"line\">            m2 = getHashPath(ret, m2, file, f);</span><br><span class=\"line\">            return &quot;script&quot; + m1 + &quot;src=&apos;&quot; + m2 + &quot;&apos;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return m</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (file.getContent() != content) &#123;</span><br><span class=\"line\">        file._md5 = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.setContent(content);</span><br><span class=\"line\">    return content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"/blog/2018/08/10/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/修正后.jpg\" alt=\"修正后\"></p>\n"},{"title":"gitflow工作流程使用经验","date":"2018-05-15T21:13:21.000Z","_content":"背景：\n---\n公司一直使用svn做版本管控，项目一般只有两个分支，开发区和发布区，开发人员在开发过程中提交代码，然后在测试部署环境，测试通过后将代码同步至发布区，从发布区打包上线到生产环境；\n\n前端项目现在多采用MVVM架构，每次上线需要全量打包，再加上多人协作的场景下，svn的管控模式已经难以满足复杂的场景；\n\n先分析下问题所在：\n---\n1、开发人员多，每个人都在发布区提交代码，发布区的代码经常出现一更新就无法运行，只能先一一排错；同时测试环境沦为鸡肋，因为没有对应的稳定版本；\n2、并行开发的版本多，同时有3个以上的需求在开发，但上线的时间并不一致，导致开发区的代码无法作为测试版本，只能由开发人员自己提交发布区，测试人员在发布区打包上线并测试；发布区沦为测试区；\n3、前端项目无法增量上线，每次上线需要发布人全量打包，发布区版本由发布人员认为管控，上线日需要多次打包测试；\n\n因此考虑引入Git作为版本管理工具，对开发上线流程进行管理；\n\nGit的优点\n---\n1. 由于是分布式，所有本地库包含了远程库的所有内容。\n2. 优秀的分支模型，打分支以及合并分支，极其方便。\n3. 快速，Git由于代码都在本地，打分支和合并分支及其快速\n\n但即使是Git，没有一套规范约束，随着项目周期变长，参与人员变多，依旧会出现各种问题；\n\nGitflow\n---\n就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范\n\nGitflow工作流通过为功能开发, 发布准备和维护分配独立的分支, 让发布迭代过程更流畅. 严格的分支模型也为大型项目提供了一些非常必要的结构. \n\nGitflow工作流没有用超出功能分支工作流的概念和命令, 而是为不同的分支分配一个很明确的角色, 并定义分支之间如何和什么时候进行交互.\n![avatar](gitflow工作流程使用经验/gitflow.png)\n\n#### 主要分支:\n* Master(绿色): 主分支，保持稳定，不允许直接提交代码，只能从release分支和hotfix分支发起merge请求\n* Develop(橙色): 开发分支，相对稳定，代码优化以及功能性开发；\n\n#### 辅助分支:\n* Feature(蓝色): 开发新功能都从 develop 分支新建出来，完成后合并（merge）回 develop分支；\n* Release(黄色): 准备要 release 的版本，只修改 bug。从 develop 分支出来，完成后 merge 回 master 和 develop\n* Hotfix(灰色): 修复bug分支，等不及 release 版本就必须马上修复 master 赶上线的情况。会从 master 分支出来，完成后 merge 回 master 和 develop\n\n在实际使用中，根据现场的情况，做了一些调整：\n1. master分支，有版本管理人员负责，每次上线需要对master分支打版本tag；master需要时刻和生产环境保持一致，合并master分支由1-2个管理员负责，开发人员不可以直接提交到master分支；\n2. develop分支，与测试环境保持一致；不在develop分支直接开发，尽可能以功能分支合并的形式更新develop分支，保证develop分支可用性；后期将加入持续集成，develop分支的稳定是持续集成的前提条件；\n3. feature分支，是开发人员主要开发的分支，建议按照功能点来新建分支，每个功能是一个分支，开发人员自测要在feature分支完成，自测通过后，在上线周期内merge到develop分支，提交由测试人员测试；\n4. 测试人员在测试环境测试出bug，指定开发人员需要基于develop新建release分支，开发人员在release分支修复bug，而后merge回develop分支，测试人员再进行测试；\n5. 测试人员测试通过后，将release分支merge到master分支，进行上线发布；\n6. 上线后，再次出现bug，需要开发人员在master分支基础上，新建hotfix分支，修复bug，修复后，merge到develop分支测试，测试通过后再merge到master分支，重新上线发布；\n7. 如果上线失败（出现未能解决的bug，或者因为用户层面的原因）发布人员从master分支回退到上一个tag版本，然后执行上线回退；\n8. release分支和hotfix分支在bug修复后要删除，下次修复新bug时再新建分支，修复bug需要在最新的分支版本上进行；\n\n![分支列表](gitBranch.jpg)\n\n上图是我的分支列表，由于正在开发世界杯的相关功能，因此当前处在世界杯功能分支（feature/worldCup）,红色的部分是远程分支，可以看到feature分支有4个，对应的是正在开发的4个功能；\n\n##### gitFlow一些常用命令汇总\n1. 远程代码拉取到本地：\n```bash\n    git clone xxx\n    git checkout -b develop origin/develop\n```\n2. 新建feature分支，命名方式以feature/功能名\n```bash\n\tgit checkout -b [branch-name]\n\t/* 新建分支只是在本地，需要把分支提交到远程服务器 */\n\tgit push origin [branch-name]:[branch-name] \n```\n3. 开发人员提交代码到feature分支\n```bash\n\tgit add *\n    git commit -m '备注'\n```\n4. feature分支开发完成后，将本地的代码变更提交到远程\n```bash\n    /* 执行代码拉取操作，防止代码冲突 */\n\tgit pull -rebase\n\t/* 解决代码冲突后，推送代码到远程仓库*/\n\tgit push origin [branch-name] \n```\n5. 本地自测过之后，合并feature分支到develop分支\n```bash\n\tgit checkout develop\n\tgit merge [branch-name]\n```\n6. 合并完成后，删除对应的feature分支\n```bash\n\t/* 删除本地分支 */\n\tgit branch -d [branch-name]  \n\t/* 删除远程分支 */\n\tgit push origin --delete [branch-name]  \n```\n7. 打tag\n```bash\n\t/* 创建Tag */\n\tgit tag -m \"Task#003 v1.0.0 首版发布\" v1.0.0.170718\n\t/* 推送Tag到远程仓库 */\n\tgit push origin v1.0.0.170718\n```\n\n\nGit工具推荐\n---\ngit Bash：  window下用适用于git的命令行工具，建议熟悉git还是从命令行开始；\n![git Bash](gitBash.jpg)\nsourceTree：拥有可视化界面的项目版本控制软件，适用于git项目管理，可以一目了然的看到分支合并的情况，同时可以看到每次提交时的文件列表的修改情况\n![sourceTree](sourceTree.jpg)\n","source":"_posts/gitflow工作流程使用经验.md","raw":"---\ntitle: 'gitflow工作流程使用经验'\ndate: 2018-05-15 21:13:21\ntags:\n---\n背景：\n---\n公司一直使用svn做版本管控，项目一般只有两个分支，开发区和发布区，开发人员在开发过程中提交代码，然后在测试部署环境，测试通过后将代码同步至发布区，从发布区打包上线到生产环境；\n\n前端项目现在多采用MVVM架构，每次上线需要全量打包，再加上多人协作的场景下，svn的管控模式已经难以满足复杂的场景；\n\n先分析下问题所在：\n---\n1、开发人员多，每个人都在发布区提交代码，发布区的代码经常出现一更新就无法运行，只能先一一排错；同时测试环境沦为鸡肋，因为没有对应的稳定版本；\n2、并行开发的版本多，同时有3个以上的需求在开发，但上线的时间并不一致，导致开发区的代码无法作为测试版本，只能由开发人员自己提交发布区，测试人员在发布区打包上线并测试；发布区沦为测试区；\n3、前端项目无法增量上线，每次上线需要发布人全量打包，发布区版本由发布人员认为管控，上线日需要多次打包测试；\n\n因此考虑引入Git作为版本管理工具，对开发上线流程进行管理；\n\nGit的优点\n---\n1. 由于是分布式，所有本地库包含了远程库的所有内容。\n2. 优秀的分支模型，打分支以及合并分支，极其方便。\n3. 快速，Git由于代码都在本地，打分支和合并分支及其快速\n\n但即使是Git，没有一套规范约束，随着项目周期变长，参与人员变多，依旧会出现各种问题；\n\nGitflow\n---\n就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范\n\nGitflow工作流通过为功能开发, 发布准备和维护分配独立的分支, 让发布迭代过程更流畅. 严格的分支模型也为大型项目提供了一些非常必要的结构. \n\nGitflow工作流没有用超出功能分支工作流的概念和命令, 而是为不同的分支分配一个很明确的角色, 并定义分支之间如何和什么时候进行交互.\n![avatar](gitflow工作流程使用经验/gitflow.png)\n\n#### 主要分支:\n* Master(绿色): 主分支，保持稳定，不允许直接提交代码，只能从release分支和hotfix分支发起merge请求\n* Develop(橙色): 开发分支，相对稳定，代码优化以及功能性开发；\n\n#### 辅助分支:\n* Feature(蓝色): 开发新功能都从 develop 分支新建出来，完成后合并（merge）回 develop分支；\n* Release(黄色): 准备要 release 的版本，只修改 bug。从 develop 分支出来，完成后 merge 回 master 和 develop\n* Hotfix(灰色): 修复bug分支，等不及 release 版本就必须马上修复 master 赶上线的情况。会从 master 分支出来，完成后 merge 回 master 和 develop\n\n在实际使用中，根据现场的情况，做了一些调整：\n1. master分支，有版本管理人员负责，每次上线需要对master分支打版本tag；master需要时刻和生产环境保持一致，合并master分支由1-2个管理员负责，开发人员不可以直接提交到master分支；\n2. develop分支，与测试环境保持一致；不在develop分支直接开发，尽可能以功能分支合并的形式更新develop分支，保证develop分支可用性；后期将加入持续集成，develop分支的稳定是持续集成的前提条件；\n3. feature分支，是开发人员主要开发的分支，建议按照功能点来新建分支，每个功能是一个分支，开发人员自测要在feature分支完成，自测通过后，在上线周期内merge到develop分支，提交由测试人员测试；\n4. 测试人员在测试环境测试出bug，指定开发人员需要基于develop新建release分支，开发人员在release分支修复bug，而后merge回develop分支，测试人员再进行测试；\n5. 测试人员测试通过后，将release分支merge到master分支，进行上线发布；\n6. 上线后，再次出现bug，需要开发人员在master分支基础上，新建hotfix分支，修复bug，修复后，merge到develop分支测试，测试通过后再merge到master分支，重新上线发布；\n7. 如果上线失败（出现未能解决的bug，或者因为用户层面的原因）发布人员从master分支回退到上一个tag版本，然后执行上线回退；\n8. release分支和hotfix分支在bug修复后要删除，下次修复新bug时再新建分支，修复bug需要在最新的分支版本上进行；\n\n![分支列表](gitBranch.jpg)\n\n上图是我的分支列表，由于正在开发世界杯的相关功能，因此当前处在世界杯功能分支（feature/worldCup）,红色的部分是远程分支，可以看到feature分支有4个，对应的是正在开发的4个功能；\n\n##### gitFlow一些常用命令汇总\n1. 远程代码拉取到本地：\n```bash\n    git clone xxx\n    git checkout -b develop origin/develop\n```\n2. 新建feature分支，命名方式以feature/功能名\n```bash\n\tgit checkout -b [branch-name]\n\t/* 新建分支只是在本地，需要把分支提交到远程服务器 */\n\tgit push origin [branch-name]:[branch-name] \n```\n3. 开发人员提交代码到feature分支\n```bash\n\tgit add *\n    git commit -m '备注'\n```\n4. feature分支开发完成后，将本地的代码变更提交到远程\n```bash\n    /* 执行代码拉取操作，防止代码冲突 */\n\tgit pull -rebase\n\t/* 解决代码冲突后，推送代码到远程仓库*/\n\tgit push origin [branch-name] \n```\n5. 本地自测过之后，合并feature分支到develop分支\n```bash\n\tgit checkout develop\n\tgit merge [branch-name]\n```\n6. 合并完成后，删除对应的feature分支\n```bash\n\t/* 删除本地分支 */\n\tgit branch -d [branch-name]  \n\t/* 删除远程分支 */\n\tgit push origin --delete [branch-name]  \n```\n7. 打tag\n```bash\n\t/* 创建Tag */\n\tgit tag -m \"Task#003 v1.0.0 首版发布\" v1.0.0.170718\n\t/* 推送Tag到远程仓库 */\n\tgit push origin v1.0.0.170718\n```\n\n\nGit工具推荐\n---\ngit Bash：  window下用适用于git的命令行工具，建议熟悉git还是从命令行开始；\n![git Bash](gitBash.jpg)\nsourceTree：拥有可视化界面的项目版本控制软件，适用于git项目管理，可以一目了然的看到分支合并的情况，同时可以看到每次提交时的文件列表的修改情况\n![sourceTree](sourceTree.jpg)\n","slug":"gitflow工作流程使用经验","published":1,"updated":"2018-06-20T10:44:21.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11nv00012om2zqibxaid","content":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>公司一直使用svn做版本管控，项目一般只有两个分支，开发区和发布区，开发人员在开发过程中提交代码，然后在测试部署环境，测试通过后将代码同步至发布区，从发布区打包上线到生产环境；</p>\n<p>前端项目现在多采用MVVM架构，每次上线需要全量打包，再加上多人协作的场景下，svn的管控模式已经难以满足复杂的场景；</p>\n<h2 id=\"先分析下问题所在：\"><a href=\"#先分析下问题所在：\" class=\"headerlink\" title=\"先分析下问题所在：\"></a>先分析下问题所在：</h2><p>1、开发人员多，每个人都在发布区提交代码，发布区的代码经常出现一更新就无法运行，只能先一一排错；同时测试环境沦为鸡肋，因为没有对应的稳定版本；<br>2、并行开发的版本多，同时有3个以上的需求在开发，但上线的时间并不一致，导致开发区的代码无法作为测试版本，只能由开发人员自己提交发布区，测试人员在发布区打包上线并测试；发布区沦为测试区；<br>3、前端项目无法增量上线，每次上线需要发布人全量打包，发布区版本由发布人员认为管控，上线日需要多次打包测试；</p>\n<p>因此考虑引入Git作为版本管理工具，对开发上线流程进行管理；</p>\n<h2 id=\"Git的优点\"><a href=\"#Git的优点\" class=\"headerlink\" title=\"Git的优点\"></a>Git的优点</h2><ol>\n<li>由于是分布式，所有本地库包含了远程库的所有内容。</li>\n<li>优秀的分支模型，打分支以及合并分支，极其方便。</li>\n<li>快速，Git由于代码都在本地，打分支和合并分支及其快速</li>\n</ol>\n<p>但即使是Git，没有一套规范约束，随着项目周期变长，参与人员变多，依旧会出现各种问题；</p>\n<h2 id=\"Gitflow\"><a href=\"#Gitflow\" class=\"headerlink\" title=\"Gitflow\"></a>Gitflow</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范</p>\n<p>Gitflow工作流通过为功能开发, 发布准备和维护分配独立的分支, 让发布迭代过程更流畅. 严格的分支模型也为大型项目提供了一些非常必要的结构. </p>\n<p>Gitflow工作流没有用超出功能分支工作流的概念和命令, 而是为不同的分支分配一个很明确的角色, 并定义分支之间如何和什么时候进行交互.<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitflow.png\" alt=\"avatar\"></p>\n<h4 id=\"主要分支\"><a href=\"#主要分支\" class=\"headerlink\" title=\"主要分支:\"></a>主要分支:</h4><ul>\n<li>Master(绿色): 主分支，保持稳定，不允许直接提交代码，只能从release分支和hotfix分支发起merge请求</li>\n<li>Develop(橙色): 开发分支，相对稳定，代码优化以及功能性开发；</li>\n</ul>\n<h4 id=\"辅助分支\"><a href=\"#辅助分支\" class=\"headerlink\" title=\"辅助分支:\"></a>辅助分支:</h4><ul>\n<li>Feature(蓝色): 开发新功能都从 develop 分支新建出来，完成后合并（merge）回 develop分支；</li>\n<li>Release(黄色): 准备要 release 的版本，只修改 bug。从 develop 分支出来，完成后 merge 回 master 和 develop</li>\n<li>Hotfix(灰色): 修复bug分支，等不及 release 版本就必须马上修复 master 赶上线的情况。会从 master 分支出来，完成后 merge 回 master 和 develop</li>\n</ul>\n<p>在实际使用中，根据现场的情况，做了一些调整：</p>\n<ol>\n<li>master分支，有版本管理人员负责，每次上线需要对master分支打版本tag；master需要时刻和生产环境保持一致，合并master分支由1-2个管理员负责，开发人员不可以直接提交到master分支；</li>\n<li>develop分支，与测试环境保持一致；不在develop分支直接开发，尽可能以功能分支合并的形式更新develop分支，保证develop分支可用性；后期将加入持续集成，develop分支的稳定是持续集成的前提条件；</li>\n<li>feature分支，是开发人员主要开发的分支，建议按照功能点来新建分支，每个功能是一个分支，开发人员自测要在feature分支完成，自测通过后，在上线周期内merge到develop分支，提交由测试人员测试；</li>\n<li>测试人员在测试环境测试出bug，指定开发人员需要基于develop新建release分支，开发人员在release分支修复bug，而后merge回develop分支，测试人员再进行测试；</li>\n<li>测试人员测试通过后，将release分支merge到master分支，进行上线发布；</li>\n<li>上线后，再次出现bug，需要开发人员在master分支基础上，新建hotfix分支，修复bug，修复后，merge到develop分支测试，测试通过后再merge到master分支，重新上线发布；</li>\n<li>如果上线失败（出现未能解决的bug，或者因为用户层面的原因）发布人员从master分支回退到上一个tag版本，然后执行上线回退；</li>\n<li>release分支和hotfix分支在bug修复后要删除，下次修复新bug时再新建分支，修复bug需要在最新的分支版本上进行；</li>\n</ol>\n<p><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitBranch.jpg\" alt=\"分支列表\"></p>\n<p>上图是我的分支列表，由于正在开发世界杯的相关功能，因此当前处在世界杯功能分支（feature/worldCup）,红色的部分是远程分支，可以看到feature分支有4个，对应的是正在开发的4个功能；</p>\n<h5 id=\"gitFlow一些常用命令汇总\"><a href=\"#gitFlow一些常用命令汇总\" class=\"headerlink\" title=\"gitFlow一些常用命令汇总\"></a>gitFlow一些常用命令汇总</h5><ol>\n<li><p>远程代码拉取到本地：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> xxx</span><br><span class=\"line\">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建feature分支，命名方式以feature/功能名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch-name]</span><br><span class=\"line\">/* 新建分支只是在本地，需要把分支提交到远程服务器 */</span><br><span class=\"line\">git push origin [branch-name]:[branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开发人员提交代码到feature分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add *</span><br><span class=\"line\">   git commit -m <span class=\"string\">'备注'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>feature分支开发完成后，将本地的代码变更提交到远程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   /* 执行代码拉取操作，防止代码冲突 */</span><br><span class=\"line\">git pull -rebase</span><br><span class=\"line\">/* 解决代码冲突后，推送代码到远程仓库*/</span><br><span class=\"line\">git push origin [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地自测过之后，合并feature分支到develop分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并完成后，删除对应的feature分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 删除本地分支 */</span><br><span class=\"line\">git branch -d [branch-name]  </span><br><span class=\"line\">/* 删除远程分支 */</span><br><span class=\"line\">git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打tag</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 创建Tag */</span><br><span class=\"line\">git tag -m <span class=\"string\">\"Task#003 v1.0.0 首版发布\"</span> v1.0.0.170718</span><br><span class=\"line\">/* 推送Tag到远程仓库 */</span><br><span class=\"line\">git push origin v1.0.0.170718</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Git工具推荐\"><a href=\"#Git工具推荐\" class=\"headerlink\" title=\"Git工具推荐\"></a>Git工具推荐</h2><p>git Bash：  window下用适用于git的命令行工具，建议熟悉git还是从命令行开始；<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitBash.jpg\" alt=\"git Bash\"><br>sourceTree：拥有可视化界面的项目版本控制软件，适用于git项目管理，可以一目了然的看到分支合并的情况，同时可以看到每次提交时的文件列表的修改情况<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/sourceTree.jpg\" alt=\"sourceTree\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>公司一直使用svn做版本管控，项目一般只有两个分支，开发区和发布区，开发人员在开发过程中提交代码，然后在测试部署环境，测试通过后将代码同步至发布区，从发布区打包上线到生产环境；</p>\n<p>前端项目现在多采用MVVM架构，每次上线需要全量打包，再加上多人协作的场景下，svn的管控模式已经难以满足复杂的场景；</p>\n<h2 id=\"先分析下问题所在：\"><a href=\"#先分析下问题所在：\" class=\"headerlink\" title=\"先分析下问题所在：\"></a>先分析下问题所在：</h2><p>1、开发人员多，每个人都在发布区提交代码，发布区的代码经常出现一更新就无法运行，只能先一一排错；同时测试环境沦为鸡肋，因为没有对应的稳定版本；<br>2、并行开发的版本多，同时有3个以上的需求在开发，但上线的时间并不一致，导致开发区的代码无法作为测试版本，只能由开发人员自己提交发布区，测试人员在发布区打包上线并测试；发布区沦为测试区；<br>3、前端项目无法增量上线，每次上线需要发布人全量打包，发布区版本由发布人员认为管控，上线日需要多次打包测试；</p>\n<p>因此考虑引入Git作为版本管理工具，对开发上线流程进行管理；</p>\n<h2 id=\"Git的优点\"><a href=\"#Git的优点\" class=\"headerlink\" title=\"Git的优点\"></a>Git的优点</h2><ol>\n<li>由于是分布式，所有本地库包含了远程库的所有内容。</li>\n<li>优秀的分支模型，打分支以及合并分支，极其方便。</li>\n<li>快速，Git由于代码都在本地，打分支和合并分支及其快速</li>\n</ol>\n<p>但即使是Git，没有一套规范约束，随着项目周期变长，参与人员变多，依旧会出现各种问题；</p>\n<h2 id=\"Gitflow\"><a href=\"#Gitflow\" class=\"headerlink\" title=\"Gitflow\"></a>Gitflow</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范</p>\n<p>Gitflow工作流通过为功能开发, 发布准备和维护分配独立的分支, 让发布迭代过程更流畅. 严格的分支模型也为大型项目提供了一些非常必要的结构. </p>\n<p>Gitflow工作流没有用超出功能分支工作流的概念和命令, 而是为不同的分支分配一个很明确的角色, 并定义分支之间如何和什么时候进行交互.<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitflow.png\" alt=\"avatar\"></p>\n<h4 id=\"主要分支\"><a href=\"#主要分支\" class=\"headerlink\" title=\"主要分支:\"></a>主要分支:</h4><ul>\n<li>Master(绿色): 主分支，保持稳定，不允许直接提交代码，只能从release分支和hotfix分支发起merge请求</li>\n<li>Develop(橙色): 开发分支，相对稳定，代码优化以及功能性开发；</li>\n</ul>\n<h4 id=\"辅助分支\"><a href=\"#辅助分支\" class=\"headerlink\" title=\"辅助分支:\"></a>辅助分支:</h4><ul>\n<li>Feature(蓝色): 开发新功能都从 develop 分支新建出来，完成后合并（merge）回 develop分支；</li>\n<li>Release(黄色): 准备要 release 的版本，只修改 bug。从 develop 分支出来，完成后 merge 回 master 和 develop</li>\n<li>Hotfix(灰色): 修复bug分支，等不及 release 版本就必须马上修复 master 赶上线的情况。会从 master 分支出来，完成后 merge 回 master 和 develop</li>\n</ul>\n<p>在实际使用中，根据现场的情况，做了一些调整：</p>\n<ol>\n<li>master分支，有版本管理人员负责，每次上线需要对master分支打版本tag；master需要时刻和生产环境保持一致，合并master分支由1-2个管理员负责，开发人员不可以直接提交到master分支；</li>\n<li>develop分支，与测试环境保持一致；不在develop分支直接开发，尽可能以功能分支合并的形式更新develop分支，保证develop分支可用性；后期将加入持续集成，develop分支的稳定是持续集成的前提条件；</li>\n<li>feature分支，是开发人员主要开发的分支，建议按照功能点来新建分支，每个功能是一个分支，开发人员自测要在feature分支完成，自测通过后，在上线周期内merge到develop分支，提交由测试人员测试；</li>\n<li>测试人员在测试环境测试出bug，指定开发人员需要基于develop新建release分支，开发人员在release分支修复bug，而后merge回develop分支，测试人员再进行测试；</li>\n<li>测试人员测试通过后，将release分支merge到master分支，进行上线发布；</li>\n<li>上线后，再次出现bug，需要开发人员在master分支基础上，新建hotfix分支，修复bug，修复后，merge到develop分支测试，测试通过后再merge到master分支，重新上线发布；</li>\n<li>如果上线失败（出现未能解决的bug，或者因为用户层面的原因）发布人员从master分支回退到上一个tag版本，然后执行上线回退；</li>\n<li>release分支和hotfix分支在bug修复后要删除，下次修复新bug时再新建分支，修复bug需要在最新的分支版本上进行；</li>\n</ol>\n<p><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitBranch.jpg\" alt=\"分支列表\"></p>\n<p>上图是我的分支列表，由于正在开发世界杯的相关功能，因此当前处在世界杯功能分支（feature/worldCup）,红色的部分是远程分支，可以看到feature分支有4个，对应的是正在开发的4个功能；</p>\n<h5 id=\"gitFlow一些常用命令汇总\"><a href=\"#gitFlow一些常用命令汇总\" class=\"headerlink\" title=\"gitFlow一些常用命令汇总\"></a>gitFlow一些常用命令汇总</h5><ol>\n<li><p>远程代码拉取到本地：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> xxx</span><br><span class=\"line\">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建feature分支，命名方式以feature/功能名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch-name]</span><br><span class=\"line\">/* 新建分支只是在本地，需要把分支提交到远程服务器 */</span><br><span class=\"line\">git push origin [branch-name]:[branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开发人员提交代码到feature分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add *</span><br><span class=\"line\">   git commit -m <span class=\"string\">'备注'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>feature分支开发完成后，将本地的代码变更提交到远程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   /* 执行代码拉取操作，防止代码冲突 */</span><br><span class=\"line\">git pull -rebase</span><br><span class=\"line\">/* 解决代码冲突后，推送代码到远程仓库*/</span><br><span class=\"line\">git push origin [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地自测过之后，合并feature分支到develop分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并完成后，删除对应的feature分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 删除本地分支 */</span><br><span class=\"line\">git branch -d [branch-name]  </span><br><span class=\"line\">/* 删除远程分支 */</span><br><span class=\"line\">git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打tag</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 创建Tag */</span><br><span class=\"line\">git tag -m <span class=\"string\">\"Task#003 v1.0.0 首版发布\"</span> v1.0.0.170718</span><br><span class=\"line\">/* 推送Tag到远程仓库 */</span><br><span class=\"line\">git push origin v1.0.0.170718</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Git工具推荐\"><a href=\"#Git工具推荐\" class=\"headerlink\" title=\"Git工具推荐\"></a>Git工具推荐</h2><p>git Bash：  window下用适用于git的命令行工具，建议熟悉git还是从命令行开始；<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/gitBash.jpg\" alt=\"git Bash\"><br>sourceTree：拥有可视化界面的项目版本控制软件，适用于git项目管理，可以一目了然的看到分支合并的情况，同时可以看到每次提交时的文件列表的修改情况<br><img src=\"/blog/2018/05/16/gitflow工作流程使用经验/sourceTree.jpg\" alt=\"sourceTree\"></p>\n"},{"title":"javascript异常总结","date":"2019-01-09T16:24:37.000Z","_content":"\n写在前面\n---\n前端由于javascript特性，加上浏览器环境的复杂性，非常容易报错，又非常难以定位错误。最近在使用async/await语法时，捕获异常的部分总出问题。学习一下，在这里总结。\n\n\n大纲：\nError的基础\n\npromise和async/await捕获异常方式\n\n异常信息采集\n\n参考文章：https://segmentfault.com/a/1190000017708563","source":"_posts/javascript异常总结.md","raw":"---\ntitle: javascript异常总结\ndate: 2019-01-09 16:24:37\ntags:\n---\n\n写在前面\n---\n前端由于javascript特性，加上浏览器环境的复杂性，非常容易报错，又非常难以定位错误。最近在使用async/await语法时，捕获异常的部分总出问题。学习一下，在这里总结。\n\n\n大纲：\nError的基础\n\npromise和async/await捕获异常方式\n\n异常信息采集\n\n参考文章：https://segmentfault.com/a/1190000017708563","slug":"javascript异常总结","published":1,"updated":"2019-01-09T09:00:40.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11tu00022om2y93nhyv5","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>前端由于javascript特性，加上浏览器环境的复杂性，非常容易报错，又非常难以定位错误。最近在使用async/await语法时，捕获异常的部分总出问题。学习一下，在这里总结。</p>\n<p>大纲：<br>Error的基础</p>\n<p>promise和async/await捕获异常方式</p>\n<p>异常信息采集</p>\n<p>参考文章：<a href=\"https://segmentfault.com/a/1190000017708563\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017708563</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>前端由于javascript特性，加上浏览器环境的复杂性，非常容易报错，又非常难以定位错误。最近在使用async/await语法时，捕获异常的部分总出问题。学习一下，在这里总结。</p>\n<p>大纲：<br>Error的基础</p>\n<p>promise和async/await捕获异常方式</p>\n<p>异常信息采集</p>\n<p>参考文章：<a href=\"https://segmentfault.com/a/1190000017708563\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017708563</a></p>\n"},{"title":"javascript执行机制","date":"2018-12-13T11:25:30.000Z","_content":"","source":"_posts/javascript执行机制.md","raw":"---\ntitle: javascript执行机制\ndate: 2018-12-13 11:25:30\ntags:\n---\n","slug":"javascript执行机制","published":1,"updated":"2018-12-13T03:25:30.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11u000032om2tiadixox","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"javascript实现继承的几种方式","date":"2018-12-31T09:32:38.000Z","_content":"\n背景\n---\n近期的项目需要兼容IE8，很多ES5、ES6的属性无法使用；其中一部分用到了一些继承的思想，发现自己对js实现继承的几种方式理解还不够透彻，因此花了一晚上的时间，基于《javascript高级程序设计》和《javascript语言精粹》还有ES6的extends方法，重新梳理了所有的继承方式，以及他们的优缺点。\n\n原型链继承\n---\n原型链继承，借助原型链，将父类的属性和方法共享给子类；\n实现很简单：子类原型指向父类实例。\n```js\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tthis.subproperty = false;\n}\nSubType.prototype = new SuperType();\nvar instance = new SubType();\n```\ninstance可以访问到property属性和getSuperValue方法\n\n### 缺点\n1. 父类中的属性是所有子类实例共享的，如父类中有引用类型，例如数组，那么其中一个子类实例修改了数组元素，会影响到所有的子类实例；\n2. 父类的属性是在父类实例化时已经确定，子类实例化时无法向父类够高函数传参；\n\n借用构造函数\n---\n为了规避原型链继承的缺点，可以在子类构造函数中，借助父类的构造函数，把this指向子类构造函数\n```js\nfunction SubType(){\n\tSuperType.call(this)\n}\n```\n父类属性会随着构造函数被调用，加在子类的实例上（这样就不会出父类属性共享的问题，因为属性是子类实例自己的属性了）\n### new\n这里的实现依据是new操作符的行为，当对构造函数执行new操作符时，行为如下(以new SubType()为例)：\n```js\nvar obj = {};\nobj.__proto__ = SubType.prototype;\nSubType.call(obj);\nreturn obj;\n```\n### 缺点\n只能继承属性，在原型链上的方法不可见。\n\n组合继承\n---\n将原型链继承与借用构造函数继承组合在一起，既能共享原型链的属性，同时还能避免父类属性共享的问题。\n```js\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tSuperType.call(this);\n\tthis.subproperty = false;\n}\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;  // 这里需要重置构造器\nvar instance = new SubType();\n```\n以上代码把前面两种方式组合在一起，需要注意的是，重设子类构造函数的原型对象为父类实例后，子类原型对象丢失了constructor属性，这里必须补上（指向构造函数本身即可），原因是new的过程，需要从constructor中找到构造函数并调用执行；\n### 缺点\n父类构造函数被调用了两次，子类构造函数中调用一次，重置原型对象时又调用了一次。实际上，父类实例中仍然有属性，而子类实例也有同名的属性；父类中的属性实例化是多余的部分；\n\n原型式继承\n---\n本质上与原型链继承是一样的，只是通过类似Object.create()的方法，不需要单独为子类定义构造函数。还有一个优点，可以把对象字面量直接加入到原型链中；\n```js\nvar superType = {\n\tthis.property = true;\n}\nvar instance = Object.create(superType);\n```\n\n### Object.create()\nIE8以上（不包含）可以直接使用，IE8需要自行实现：\n```js\nfunction object(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\n```\n### 缺点\n新对象与原对象保持一致，可以说是原对象的副本，只是对于新对象来说，属性都在原型链上；\n与原型链继承存在的问题基本一样，父类中的引用类型仍然是共享的；\n\n寄生式继承\n---\n在原型式继承上，做了一点扩展，生成新对象后，对新对象进行增强，再返回新对象；\n```js\nfunction createAnother(original){\n\tvar clone = object(original);\n\tclone.sayHi = function(){\n\t\talert(\"hi\");\n\t}\n\treturn clone;\n}\n```\n### 缺点\nsayHi方法不能复用\n\n\n寄生组合式继承\n---\n寄生组合式继承，借鉴了寄生式继承的思路，解决了组合继承中父类实例两次实例化属性的问题。\n先上代码：\n```js\nfunction object(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\nfunction inheritPrototype(subType, superType){\n\tvar prototype = object(superType.prototype);  // prototype替代了new SuperType(),__proto__都指向SuperType.prototype,但是不需要实例化SuperType构造函数中的属性；\n\tprototype.constructor = subType;   // 替换成子类的构造函数，当执行new SubType()时，运行的是SubType的构造函数；\n\tsubType.prototype = prototype;\n}\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tSuperType.call(this);\n\tthis.subproperty = false;\n}\ninheritPrototype(SubType, SuperType);\nvar instance = new SubType();\n```\n寄生组合方式，通过使用一个新对象，替换掉原先组合继承方式中，父类的实例，达到原型链不变，但是不需要实例化父类属性.\n原型链如下:\n组合继承：   子类实例 --- 父类实例  ---  父类原型；\n寄生组合：   子类实例 --- 新对象    ---  父类原型；\n\n完美解决了两次实例化父类属性的问题；\n### 缺点\n唯一的缺点就是实现相对复杂，IE8以上可以通过Object.create()简化部分流程","source":"_posts/javascript实现继承的几种方式.md","raw":"---\ntitle: javascript实现继承的几种方式\ndate: 2018-12-31 09:32:38\ntags:\n---\n\n背景\n---\n近期的项目需要兼容IE8，很多ES5、ES6的属性无法使用；其中一部分用到了一些继承的思想，发现自己对js实现继承的几种方式理解还不够透彻，因此花了一晚上的时间，基于《javascript高级程序设计》和《javascript语言精粹》还有ES6的extends方法，重新梳理了所有的继承方式，以及他们的优缺点。\n\n原型链继承\n---\n原型链继承，借助原型链，将父类的属性和方法共享给子类；\n实现很简单：子类原型指向父类实例。\n```js\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tthis.subproperty = false;\n}\nSubType.prototype = new SuperType();\nvar instance = new SubType();\n```\ninstance可以访问到property属性和getSuperValue方法\n\n### 缺点\n1. 父类中的属性是所有子类实例共享的，如父类中有引用类型，例如数组，那么其中一个子类实例修改了数组元素，会影响到所有的子类实例；\n2. 父类的属性是在父类实例化时已经确定，子类实例化时无法向父类够高函数传参；\n\n借用构造函数\n---\n为了规避原型链继承的缺点，可以在子类构造函数中，借助父类的构造函数，把this指向子类构造函数\n```js\nfunction SubType(){\n\tSuperType.call(this)\n}\n```\n父类属性会随着构造函数被调用，加在子类的实例上（这样就不会出父类属性共享的问题，因为属性是子类实例自己的属性了）\n### new\n这里的实现依据是new操作符的行为，当对构造函数执行new操作符时，行为如下(以new SubType()为例)：\n```js\nvar obj = {};\nobj.__proto__ = SubType.prototype;\nSubType.call(obj);\nreturn obj;\n```\n### 缺点\n只能继承属性，在原型链上的方法不可见。\n\n组合继承\n---\n将原型链继承与借用构造函数继承组合在一起，既能共享原型链的属性，同时还能避免父类属性共享的问题。\n```js\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tSuperType.call(this);\n\tthis.subproperty = false;\n}\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;  // 这里需要重置构造器\nvar instance = new SubType();\n```\n以上代码把前面两种方式组合在一起，需要注意的是，重设子类构造函数的原型对象为父类实例后，子类原型对象丢失了constructor属性，这里必须补上（指向构造函数本身即可），原因是new的过程，需要从constructor中找到构造函数并调用执行；\n### 缺点\n父类构造函数被调用了两次，子类构造函数中调用一次，重置原型对象时又调用了一次。实际上，父类实例中仍然有属性，而子类实例也有同名的属性；父类中的属性实例化是多余的部分；\n\n原型式继承\n---\n本质上与原型链继承是一样的，只是通过类似Object.create()的方法，不需要单独为子类定义构造函数。还有一个优点，可以把对象字面量直接加入到原型链中；\n```js\nvar superType = {\n\tthis.property = true;\n}\nvar instance = Object.create(superType);\n```\n\n### Object.create()\nIE8以上（不包含）可以直接使用，IE8需要自行实现：\n```js\nfunction object(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\n```\n### 缺点\n新对象与原对象保持一致，可以说是原对象的副本，只是对于新对象来说，属性都在原型链上；\n与原型链继承存在的问题基本一样，父类中的引用类型仍然是共享的；\n\n寄生式继承\n---\n在原型式继承上，做了一点扩展，生成新对象后，对新对象进行增强，再返回新对象；\n```js\nfunction createAnother(original){\n\tvar clone = object(original);\n\tclone.sayHi = function(){\n\t\talert(\"hi\");\n\t}\n\treturn clone;\n}\n```\n### 缺点\nsayHi方法不能复用\n\n\n寄生组合式继承\n---\n寄生组合式继承，借鉴了寄生式继承的思路，解决了组合继承中父类实例两次实例化属性的问题。\n先上代码：\n```js\nfunction object(obj){\n\tfunction F(){};\n\tF.prototype = obj;\n\treturn new F();\n}\nfunction inheritPrototype(subType, superType){\n\tvar prototype = object(superType.prototype);  // prototype替代了new SuperType(),__proto__都指向SuperType.prototype,但是不需要实例化SuperType构造函数中的属性；\n\tprototype.constructor = subType;   // 替换成子类的构造函数，当执行new SubType()时，运行的是SubType的构造函数；\n\tsubType.prototype = prototype;\n}\nfunction SuperType(){\n\tthis.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n\treturn this.property;\n}\nfunction SubType(){\n\tSuperType.call(this);\n\tthis.subproperty = false;\n}\ninheritPrototype(SubType, SuperType);\nvar instance = new SubType();\n```\n寄生组合方式，通过使用一个新对象，替换掉原先组合继承方式中，父类的实例，达到原型链不变，但是不需要实例化父类属性.\n原型链如下:\n组合继承：   子类实例 --- 父类实例  ---  父类原型；\n寄生组合：   子类实例 --- 新对象    ---  父类原型；\n\n完美解决了两次实例化父类属性的问题；\n### 缺点\n唯一的缺点就是实现相对复杂，IE8以上可以通过Object.create()简化部分流程","slug":"javascript实现继承的几种方式","published":1,"updated":"2019-01-04T01:22:20.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11u300042om2xvr7do35","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期的项目需要兼容IE8，很多ES5、ES6的属性无法使用；其中一部分用到了一些继承的思想，发现自己对js实现继承的几种方式理解还不够透彻，因此花了一晚上的时间，基于《javascript高级程序设计》和《javascript语言精粹》还有ES6的extends方法，重新梳理了所有的继承方式，以及他们的优缺点。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>原型链继承，借助原型链，将父类的属性和方法共享给子类；<br>实现很简单：子类原型指向父类实例。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>instance可以访问到property属性和getSuperValue方法</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>父类中的属性是所有子类实例共享的，如父类中有引用类型，例如数组，那么其中一个子类实例修改了数组元素，会影响到所有的子类实例；</li>\n<li>父类的属性是在父类实例化时已经确定，子类实例化时无法向父类够高函数传参；</li>\n</ol>\n<h2 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h2><p>为了规避原型链继承的缺点，可以在子类构造函数中，借助父类的构造函数，把this指向子类构造函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>父类属性会随着构造函数被调用，加在子类的实例上（这样就不会出父类属性共享的问题，因为属性是子类实例自己的属性了）</p>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p>这里的实现依据是new操作符的行为，当对构造函数执行new操作符时，行为如下(以new SubType()为例)：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = SubType.prototype;</span><br><span class=\"line\">SubType.call(obj);</span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>只能继承属性，在原型链上的方法不可见。</p>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>将原型链继承与借用构造函数继承组合在一起，既能共享原型链的属性，同时还能避免父类属性共享的问题。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;  <span class=\"comment\">// 这里需要重置构造器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>以上代码把前面两种方式组合在一起，需要注意的是，重设子类构造函数的原型对象为父类实例后，子类原型对象丢失了constructor属性，这里必须补上（指向构造函数本身即可），原因是new的过程，需要从constructor中找到构造函数并调用执行；</p>\n<h3 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>父类构造函数被调用了两次，子类构造函数中调用一次，重置原型对象时又调用了一次。实际上，父类实例中仍然有属性，而子类实例也有同名的属性；父类中的属性实例化是多余的部分；</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><p>本质上与原型链继承是一样的，只是通过类似Object.create()的方法，不需要单独为子类定义构造函数。还有一个优点，可以把对象字面量直接加入到原型链中；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> superType = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"built_in\">Object</span>.create(superType);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><p>IE8以上（不包含）可以直接使用，IE8需要自行实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>新对象与原对象保持一致，可以说是原对象的副本，只是对于新对象来说，属性都在原型链上；<br>与原型链继承存在的问题基本一样，父类中的引用类型仍然是共享的；</p>\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><p>在原型式继承上，做了一点扩展，生成新对象后，对新对象进行增强，再返回新对象；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> clone = object(original);</span><br><span class=\"line\">\tclone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>sayHi方法不能复用</p>\n<h2 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h2><p>寄生组合式继承，借鉴了寄生式继承的思路，解决了组合继承中父类实例两次实例化属性的问题。<br>先上代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> prototype = object(superType.prototype);  <span class=\"comment\">// prototype替代了new SuperType(),__proto__都指向SuperType.prototype,但是不需要实例化SuperType构造函数中的属性；</span></span><br><span class=\"line\">\tprototype.constructor = subType;   <span class=\"comment\">// 替换成子类的构造函数，当执行new SubType()时，运行的是SubType的构造函数；</span></span><br><span class=\"line\">\tsubType.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>寄生组合方式，通过使用一个新对象，替换掉原先组合继承方式中，父类的实例，达到原型链不变，但是不需要实例化父类属性.<br>原型链如下:<br>组合继承：   子类实例 — 父类实例  —  父类原型；<br>寄生组合：   子类实例 — 新对象    —  父类原型；</p>\n<p>完美解决了两次实例化父类属性的问题；</p>\n<h3 id=\"缺点-5\"><a href=\"#缺点-5\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>唯一的缺点就是实现相对复杂，IE8以上可以通过Object.create()简化部分流程</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期的项目需要兼容IE8，很多ES5、ES6的属性无法使用；其中一部分用到了一些继承的思想，发现自己对js实现继承的几种方式理解还不够透彻，因此花了一晚上的时间，基于《javascript高级程序设计》和《javascript语言精粹》还有ES6的extends方法，重新梳理了所有的继承方式，以及他们的优缺点。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>原型链继承，借助原型链，将父类的属性和方法共享给子类；<br>实现很简单：子类原型指向父类实例。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>instance可以访问到property属性和getSuperValue方法</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>父类中的属性是所有子类实例共享的，如父类中有引用类型，例如数组，那么其中一个子类实例修改了数组元素，会影响到所有的子类实例；</li>\n<li>父类的属性是在父类实例化时已经确定，子类实例化时无法向父类够高函数传参；</li>\n</ol>\n<h2 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h2><p>为了规避原型链继承的缺点，可以在子类构造函数中，借助父类的构造函数，把this指向子类构造函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>父类属性会随着构造函数被调用，加在子类的实例上（这样就不会出父类属性共享的问题，因为属性是子类实例自己的属性了）</p>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p>这里的实现依据是new操作符的行为，当对构造函数执行new操作符时，行为如下(以new SubType()为例)：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = SubType.prototype;</span><br><span class=\"line\">SubType.call(obj);</span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>只能继承属性，在原型链上的方法不可见。</p>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>将原型链继承与借用构造函数继承组合在一起，既能共享原型链的属性，同时还能避免父类属性共享的问题。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;  <span class=\"comment\">// 这里需要重置构造器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>以上代码把前面两种方式组合在一起，需要注意的是，重设子类构造函数的原型对象为父类实例后，子类原型对象丢失了constructor属性，这里必须补上（指向构造函数本身即可），原因是new的过程，需要从constructor中找到构造函数并调用执行；</p>\n<h3 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>父类构造函数被调用了两次，子类构造函数中调用一次，重置原型对象时又调用了一次。实际上，父类实例中仍然有属性，而子类实例也有同名的属性；父类中的属性实例化是多余的部分；</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><p>本质上与原型链继承是一样的，只是通过类似Object.create()的方法，不需要单独为子类定义构造函数。还有一个优点，可以把对象字面量直接加入到原型链中；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> superType = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"built_in\">Object</span>.create(superType);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><p>IE8以上（不包含）可以直接使用，IE8需要自行实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>新对象与原对象保持一致，可以说是原对象的副本，只是对于新对象来说，属性都在原型链上；<br>与原型链继承存在的问题基本一样，父类中的引用类型仍然是共享的；</p>\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><p>在原型式继承上，做了一点扩展，生成新对象后，对新对象进行增强，再返回新对象；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> clone = object(original);</span><br><span class=\"line\">\tclone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>sayHi方法不能复用</p>\n<h2 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h2><p>寄生组合式继承，借鉴了寄生式继承的思路，解决了组合继承中父类实例两次实例化属性的问题。<br>先上代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> prototype = object(superType.prototype);  <span class=\"comment\">// prototype替代了new SuperType(),__proto__都指向SuperType.prototype,但是不需要实例化SuperType构造函数中的属性；</span></span><br><span class=\"line\">\tprototype.constructor = subType;   <span class=\"comment\">// 替换成子类的构造函数，当执行new SubType()时，运行的是SubType的构造函数；</span></span><br><span class=\"line\">\tsubType.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\tSuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br></pre></td></tr></table></figure></p>\n<p>寄生组合方式，通过使用一个新对象，替换掉原先组合继承方式中，父类的实例，达到原型链不变，但是不需要实例化父类属性.<br>原型链如下:<br>组合继承：   子类实例 — 父类实例  —  父类原型；<br>寄生组合：   子类实例 — 新对象    —  父类原型；</p>\n<p>完美解决了两次实例化父类属性的问题；</p>\n<h3 id=\"缺点-5\"><a href=\"#缺点-5\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>唯一的缺点就是实现相对复杂，IE8以上可以通过Object.create()简化部分流程</p>\n"},{"title":"vue多页面+history路由模式的nginx配置","date":"2018-11-06T18:17:56.000Z","_content":"\n背景\n---\n在拼团购业务中，遇到基于vue的多页面配置+history路由模式的场景，需要在nginx下进行配置\n\n\n多页面配置\n---\n多页面配置是指，在spa项目中，有些特殊的页面需要独立处理，例如特殊的业务，或者页面的缩放程度不同；\n配置多页面后，在前端项目中不再是只有1个html，那么需要在部署时，对nginx进行特别处理；\n\n\nhistory模式\n---\nvue-router默认是hash模式，同时也提供了history模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。\n\n当使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id\n\n所以，要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面\n\nnginx配置\n---\n如果多页面+history同时使用，该如何配置呢？\n\n这是单页面的history模式的配置\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n多页面的话就需要属于另一个页面的路由必须可以通过url识别出来，例如单页面路由/a开头，那么多页面可以是/b开头；\n但是由于我们场景，这个前端应用已经有一个统一的上下文/y，因此属于新页面的路由设计为/y/new\n\n这样通过nginx就可以把多页面的路由区分开，进而加载不同的页面；\n\n配置如下：\n```\nlocation /y {\n  try_files $uri $uri/ /index.html;\n}\n\nlocation ^~/y/new {\n  try_files $uri $uri/ /index2.html;\n}\n\n```\n#### 注意\n匹配新路由的location优先级要高于匹配原路由的location，因此加了^~","source":"_posts/vue多页面-history路由模式的nginx配置.md","raw":"---\ntitle: vue多页面+history路由模式的nginx配置\ndate: 2018-11-06 18:17:56\ntags:\n---\n\n背景\n---\n在拼团购业务中，遇到基于vue的多页面配置+history路由模式的场景，需要在nginx下进行配置\n\n\n多页面配置\n---\n多页面配置是指，在spa项目中，有些特殊的页面需要独立处理，例如特殊的业务，或者页面的缩放程度不同；\n配置多页面后，在前端项目中不再是只有1个html，那么需要在部署时，对nginx进行特别处理；\n\n\nhistory模式\n---\nvue-router默认是hash模式，同时也提供了history模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。\n\n当使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id\n\n所以，要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面\n\nnginx配置\n---\n如果多页面+history同时使用，该如何配置呢？\n\n这是单页面的history模式的配置\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n多页面的话就需要属于另一个页面的路由必须可以通过url识别出来，例如单页面路由/a开头，那么多页面可以是/b开头；\n但是由于我们场景，这个前端应用已经有一个统一的上下文/y，因此属于新页面的路由设计为/y/new\n\n这样通过nginx就可以把多页面的路由区分开，进而加载不同的页面；\n\n配置如下：\n```\nlocation /y {\n  try_files $uri $uri/ /index.html;\n}\n\nlocation ^~/y/new {\n  try_files $uri $uri/ /index2.html;\n}\n\n```\n#### 注意\n匹配新路由的location优先级要高于匹配原路由的location，因此加了^~","slug":"vue多页面-history路由模式的nginx配置","published":1,"updated":"2018-11-06T10:31:05.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11u500052om2dkieksjw","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在拼团购业务中，遇到基于vue的多页面配置+history路由模式的场景，需要在nginx下进行配置</p>\n<h2 id=\"多页面配置\"><a href=\"#多页面配置\" class=\"headerlink\" title=\"多页面配置\"></a>多页面配置</h2><p>多页面配置是指，在spa项目中，有些特殊的页面需要独立处理，例如特殊的业务，或者页面的缩放程度不同；<br>配置多页面后，在前端项目中不再是只有1个html，那么需要在部署时，对nginx进行特别处理；</p>\n<h2 id=\"history模式\"><a href=\"#history模式\" class=\"headerlink\" title=\"history模式\"></a>history模式</h2><p>vue-router默认是hash模式，同时也提供了history模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>\n<p>当使用 history 模式时，URL 就像正常的 url，例如 <a href=\"http://yoursite.com/user/id\" target=\"_blank\" rel=\"noopener\">http://yoursite.com/user/id</a></p>\n<p>所以，要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面</p>\n<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h2><p>如果多页面+history同时使用，该如何配置呢？</p>\n<p>这是单页面的history模式的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多页面的话就需要属于另一个页面的路由必须可以通过url识别出来，例如单页面路由/a开头，那么多页面可以是/b开头；<br>但是由于我们场景，这个前端应用已经有一个统一的上下文/y，因此属于新页面的路由设计为/y/new</p>\n<p>这样通过nginx就可以把多页面的路由区分开，进而加载不同的页面；</p>\n<p>配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /y &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ^~/y/new &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index2.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>匹配新路由的location优先级要高于匹配原路由的location，因此加了^~</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在拼团购业务中，遇到基于vue的多页面配置+history路由模式的场景，需要在nginx下进行配置</p>\n<h2 id=\"多页面配置\"><a href=\"#多页面配置\" class=\"headerlink\" title=\"多页面配置\"></a>多页面配置</h2><p>多页面配置是指，在spa项目中，有些特殊的页面需要独立处理，例如特殊的业务，或者页面的缩放程度不同；<br>配置多页面后，在前端项目中不再是只有1个html，那么需要在部署时，对nginx进行特别处理；</p>\n<h2 id=\"history模式\"><a href=\"#history模式\" class=\"headerlink\" title=\"history模式\"></a>history模式</h2><p>vue-router默认是hash模式，同时也提供了history模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>\n<p>当使用 history 模式时，URL 就像正常的 url，例如 <a href=\"http://yoursite.com/user/id\" target=\"_blank\" rel=\"noopener\">http://yoursite.com/user/id</a></p>\n<p>所以，要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面</p>\n<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h2><p>如果多页面+history同时使用，该如何配置呢？</p>\n<p>这是单页面的history模式的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多页面的话就需要属于另一个页面的路由必须可以通过url识别出来，例如单页面路由/a开头，那么多页面可以是/b开头；<br>但是由于我们场景，这个前端应用已经有一个统一的上下文/y，因此属于新页面的路由设计为/y/new</p>\n<p>这样通过nginx就可以把多页面的路由区分开，进而加载不同的页面；</p>\n<p>配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /y &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ^~/y/new &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index2.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>匹配新路由的location优先级要高于匹配原路由的location，因此加了^~</p>\n"},{"title":"从开发一个vue组件深入理解vue的渲染机制","date":"2018-10-12T15:33:22.000Z","_content":"\n背景\n---\n近期在做一个前端推荐的组件，类似与各个APP打开时弹出的推荐效果，效果如下：\n![效果图](效果图.jpg)\n同时需要支持推荐多个，UED给出的效果图是类似轮播图的实现。\n我需要将这个效果封装成一个独立的模块，提供给多个前端（和生活、营销）的多个位置使用（首页、营销活动页面。。）使用；\n\n组件设计\n---\n在vue中，任何一个独立的UI模块都可以封装成（.vue）的组件；一般情况下，vue的组件都对应一个html自定义标签，在编译过程中，把组件模板替换到标签位置。但这种方式不适合当前的场景，推荐组件应该是一个全局组件，类似于alert的效果， 不需要设置html标签；\n为了实现这种方式，需要先理解vue的组件是如何渲染的；\n\n渲染机制\n---\nvue是将el或template字段传入的内容编译成渲染函数，渲染函数会把模板编译成虚拟DOM节点，同时每个渲染函数都对应一个观察者（watcher), watcher会监听每个数据的get和set操作，这样就实现了当数据修改时能同步渲染DOM树；\n\n![渲染机制](vue渲染机制.png)\n\n这里我们重点关注前半部分，也就是el转换为template，template生成渲染函数；\n\n这部分的源码在src/platforms/web/entry-runtime-with-compiler.js中。\n\n大致的实现是这样的：\n* 如果 template 选项不存在，那么使用 el 元素的 outerHTML 作为模板内容\n* 如果 template 选项存在，且 template 的类型是字符串，有分两种情况：\n** 如果第一个字符是 #，那么会把该字符串作为 css 选择符去选中对应的元素，并把该元素的 innerHTML 作为模板\n** 如果第一个字符不是 #，那么什么都不做，就用 template 自身的字符串值作为模板\n* 如果 template 选项存在，且 template 的类型是元素节点(template.nodeType 存在)则使用该元素的 innerHTML 作为模板\n\n我们项目中常用的单文件组件（.vue文件）会在打包时通过vue-loader直接编译成渲染函数；\n\n这是通常我们组件的渲染流程，我们需要el作为挂载点把编译后的模板挂载在DOM树上；\n\n如果要实现类似alert的效果，还不够！\n\n$mount挂载函数\n---\n参考elementUI组件的设计，采用$mount函数实现异步挂载；\n\n![$mount官网介绍]($mount使用方法.jpg)\n\n实际上在vue实例化的过程中，就是通过$mount函数进行模板编译的，我们前面讨论的渲染过程就是在完整版vue的$mount函数中进行的；\n\n同时，$mount也是vue的实例方法，可通过vue的实例调用；\n\n回到组件的设计：\n1、组件本身是独立的vue实例，一个通过extend创建的Vue的‘子类’；\n```\nimport Vue from 'vue';\nimport Main from './main.vue';\nconst RecommondConstructor = Vue.extend(Main);\n```\n2、和创建普通vue实例一样,通过new的方式创建实例；\n```\ninstance = new RecommondConstructor({\n  data: { list: options },\n});\n```\n3、创建实例后，调用$mount挂载函数，创建实例的选项中不设置el，根据$mount官方说明，模板将被渲染为文档之外的的元素；\n```\ninstance.vm = instance.$mount();\n```\n4、在实例挂载之后，元素可以用 vm.$el 访问。再通过原生的DOM API添加到body中；\n```\ndocument.body.appendChild(instance.vm.$el);\n```\n5、最后通过插件的方式，把上面组件的实例化方法挂在vue的实例上；\n```\nimport recommond from './main';\nconst install = function install(Vue, opts = {}) {\n  Vue.component('recommondImage', recommond);\n  Vue.prototype.$recommond = {\n    show: recommond,\n  };\n};\n```\n这样通过，调用this.recommond.show()方法，就会显示推荐组件；\n\nDOM操作\n---\n前面提到了，推荐组件需要支持轮播效果，需要借助swiper来实现；\n\nswiper是直接通过操作DOM来实现效果的，因此需要在组件完全渲染到DOM树上之后再进行swiper的实例化；\n\n这里有一个问题，在组件的mounted生命周期里是否完成DOM的加载？\n\n一般来说，mounted生命周期中是可以操作DOM树的，但是在我们设计的推荐组件中，是不可以的！\n\n在这个例子中，组件在调用$mount时，没有传入el，因此模板将被渲染为文档之外的的元素；也就是说DOM文档树上还没有组件的节点；\n\n我们是通过DOM API异步加载在DOM树上的；\n\n因此mounted生命周期中直接操作DOM是不可行的；\n\n\nnextTick函数\n---\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\n先来看下nextTick的实现原理；\n\n#### 事件循环\n下图是js的事件循环机制：\n![事件循环机制](事件循环.png)\n\n#### 任务队列\njavascript中任务队列分为两类：microtask和（marco）task\n* microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，同一个事件循环中的microtask会按队列顺序，串行执行完毕；\n* macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，同一事件循环中，只执行一个。\n\n#### 更完整的事件循环\n* 每个任务循环，先执行主线程的任务->执行microtask队列中所有的任务->从marcotask中取一个任务；\n之后重复上述循环，而在microtask和marcotask之间会进行DOM树渲染，如果能在mircotask中更新完全部数据，那么只需要渲染一次就变更成最新的DOM了；\n* 属于microtask的任务：ES6的promise，MutationObserver，process.nextTick\n* 属于marcotask的任务：setTimeout，setInterval，setImmediate，MessageChannel，I/O，UIrending\n\n#### nextTick实现\nvue的$nextTick就是根据事件循环机制来实现的：\n1. 浏览器支持Promise优先使用Promise\n2. 其次选择setImmediate，缺点是，setImmediate只有部分高级IE浏览器支持的方法\n3. 再次采用MessageChannel，不需要做超时检测\n4. 最终选择setTimeout，最后才采用setTimeout的方式，是因为setTimeout将回调注册为task之前要不停的进行超时检测，有一定的性能损耗；\n\n回到组件开发上，只需要在nextTick方法中进行swpier的初始化就可以了\n```\nmounted () {\n\tthis.$nextTick(function() {\n\t\tif(this.isImgNull()) {\n\t\t\tconst mySwiper1 = new Swiper('#js_swiper2', {\n\t\t\t\tcenteredSlides: true,\n\t\t\t\tloop: true,\n\t            slidesPerView: 'auto',\n\t        \tautoplay: {\n\t            \tdelay: 2000\n\t        \t},\n\t        \tpagination: {\n\t            \tel: '.swiper-pagination'\n\t        \t}\n\t\t\t});\n\t\t\tthis.visible = true;\n\t\t}\n\t})\n},\n```\n总结\n---\n结合推荐组件的开发，梳理清楚了VUE的渲染机制，以及nextTick的底层实现；在以后开发设计中可以写出更有效率的代码；\n\n\n\n\n\n\n","source":"_posts/vue渲染机制.md","raw":"---\ntitle: 从开发一个vue组件深入理解vue的渲染机制\ndate: 2018-10-12 15:33:22\ntags:\n---\n\n背景\n---\n近期在做一个前端推荐的组件，类似与各个APP打开时弹出的推荐效果，效果如下：\n![效果图](效果图.jpg)\n同时需要支持推荐多个，UED给出的效果图是类似轮播图的实现。\n我需要将这个效果封装成一个独立的模块，提供给多个前端（和生活、营销）的多个位置使用（首页、营销活动页面。。）使用；\n\n组件设计\n---\n在vue中，任何一个独立的UI模块都可以封装成（.vue）的组件；一般情况下，vue的组件都对应一个html自定义标签，在编译过程中，把组件模板替换到标签位置。但这种方式不适合当前的场景，推荐组件应该是一个全局组件，类似于alert的效果， 不需要设置html标签；\n为了实现这种方式，需要先理解vue的组件是如何渲染的；\n\n渲染机制\n---\nvue是将el或template字段传入的内容编译成渲染函数，渲染函数会把模板编译成虚拟DOM节点，同时每个渲染函数都对应一个观察者（watcher), watcher会监听每个数据的get和set操作，这样就实现了当数据修改时能同步渲染DOM树；\n\n![渲染机制](vue渲染机制.png)\n\n这里我们重点关注前半部分，也就是el转换为template，template生成渲染函数；\n\n这部分的源码在src/platforms/web/entry-runtime-with-compiler.js中。\n\n大致的实现是这样的：\n* 如果 template 选项不存在，那么使用 el 元素的 outerHTML 作为模板内容\n* 如果 template 选项存在，且 template 的类型是字符串，有分两种情况：\n** 如果第一个字符是 #，那么会把该字符串作为 css 选择符去选中对应的元素，并把该元素的 innerHTML 作为模板\n** 如果第一个字符不是 #，那么什么都不做，就用 template 自身的字符串值作为模板\n* 如果 template 选项存在，且 template 的类型是元素节点(template.nodeType 存在)则使用该元素的 innerHTML 作为模板\n\n我们项目中常用的单文件组件（.vue文件）会在打包时通过vue-loader直接编译成渲染函数；\n\n这是通常我们组件的渲染流程，我们需要el作为挂载点把编译后的模板挂载在DOM树上；\n\n如果要实现类似alert的效果，还不够！\n\n$mount挂载函数\n---\n参考elementUI组件的设计，采用$mount函数实现异步挂载；\n\n![$mount官网介绍]($mount使用方法.jpg)\n\n实际上在vue实例化的过程中，就是通过$mount函数进行模板编译的，我们前面讨论的渲染过程就是在完整版vue的$mount函数中进行的；\n\n同时，$mount也是vue的实例方法，可通过vue的实例调用；\n\n回到组件的设计：\n1、组件本身是独立的vue实例，一个通过extend创建的Vue的‘子类’；\n```\nimport Vue from 'vue';\nimport Main from './main.vue';\nconst RecommondConstructor = Vue.extend(Main);\n```\n2、和创建普通vue实例一样,通过new的方式创建实例；\n```\ninstance = new RecommondConstructor({\n  data: { list: options },\n});\n```\n3、创建实例后，调用$mount挂载函数，创建实例的选项中不设置el，根据$mount官方说明，模板将被渲染为文档之外的的元素；\n```\ninstance.vm = instance.$mount();\n```\n4、在实例挂载之后，元素可以用 vm.$el 访问。再通过原生的DOM API添加到body中；\n```\ndocument.body.appendChild(instance.vm.$el);\n```\n5、最后通过插件的方式，把上面组件的实例化方法挂在vue的实例上；\n```\nimport recommond from './main';\nconst install = function install(Vue, opts = {}) {\n  Vue.component('recommondImage', recommond);\n  Vue.prototype.$recommond = {\n    show: recommond,\n  };\n};\n```\n这样通过，调用this.recommond.show()方法，就会显示推荐组件；\n\nDOM操作\n---\n前面提到了，推荐组件需要支持轮播效果，需要借助swiper来实现；\n\nswiper是直接通过操作DOM来实现效果的，因此需要在组件完全渲染到DOM树上之后再进行swiper的实例化；\n\n这里有一个问题，在组件的mounted生命周期里是否完成DOM的加载？\n\n一般来说，mounted生命周期中是可以操作DOM树的，但是在我们设计的推荐组件中，是不可以的！\n\n在这个例子中，组件在调用$mount时，没有传入el，因此模板将被渲染为文档之外的的元素；也就是说DOM文档树上还没有组件的节点；\n\n我们是通过DOM API异步加载在DOM树上的；\n\n因此mounted生命周期中直接操作DOM是不可行的；\n\n\nnextTick函数\n---\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\n先来看下nextTick的实现原理；\n\n#### 事件循环\n下图是js的事件循环机制：\n![事件循环机制](事件循环.png)\n\n#### 任务队列\njavascript中任务队列分为两类：microtask和（marco）task\n* microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，同一个事件循环中的microtask会按队列顺序，串行执行完毕；\n* macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，同一事件循环中，只执行一个。\n\n#### 更完整的事件循环\n* 每个任务循环，先执行主线程的任务->执行microtask队列中所有的任务->从marcotask中取一个任务；\n之后重复上述循环，而在microtask和marcotask之间会进行DOM树渲染，如果能在mircotask中更新完全部数据，那么只需要渲染一次就变更成最新的DOM了；\n* 属于microtask的任务：ES6的promise，MutationObserver，process.nextTick\n* 属于marcotask的任务：setTimeout，setInterval，setImmediate，MessageChannel，I/O，UIrending\n\n#### nextTick实现\nvue的$nextTick就是根据事件循环机制来实现的：\n1. 浏览器支持Promise优先使用Promise\n2. 其次选择setImmediate，缺点是，setImmediate只有部分高级IE浏览器支持的方法\n3. 再次采用MessageChannel，不需要做超时检测\n4. 最终选择setTimeout，最后才采用setTimeout的方式，是因为setTimeout将回调注册为task之前要不停的进行超时检测，有一定的性能损耗；\n\n回到组件开发上，只需要在nextTick方法中进行swpier的初始化就可以了\n```\nmounted () {\n\tthis.$nextTick(function() {\n\t\tif(this.isImgNull()) {\n\t\t\tconst mySwiper1 = new Swiper('#js_swiper2', {\n\t\t\t\tcenteredSlides: true,\n\t\t\t\tloop: true,\n\t            slidesPerView: 'auto',\n\t        \tautoplay: {\n\t            \tdelay: 2000\n\t        \t},\n\t        \tpagination: {\n\t            \tel: '.swiper-pagination'\n\t        \t}\n\t\t\t});\n\t\t\tthis.visible = true;\n\t\t}\n\t})\n},\n```\n总结\n---\n结合推荐组件的开发，梳理清楚了VUE的渲染机制，以及nextTick的底层实现；在以后开发设计中可以写出更有效率的代码；\n\n\n\n\n\n\n","slug":"vue渲染机制","published":1,"updated":"2018-10-14T12:41:04.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11u600062om2z3j2gu7m","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期在做一个前端推荐的组件，类似与各个APP打开时弹出的推荐效果，效果如下：<br><img src=\"/blog/2018/10/12/vue渲染机制/效果图.jpg\" alt=\"效果图\"><br>同时需要支持推荐多个，UED给出的效果图是类似轮播图的实现。<br>我需要将这个效果封装成一个独立的模块，提供给多个前端（和生活、营销）的多个位置使用（首页、营销活动页面。。）使用；</p>\n<h2 id=\"组件设计\"><a href=\"#组件设计\" class=\"headerlink\" title=\"组件设计\"></a>组件设计</h2><p>在vue中，任何一个独立的UI模块都可以封装成（.vue）的组件；一般情况下，vue的组件都对应一个html自定义标签，在编译过程中，把组件模板替换到标签位置。但这种方式不适合当前的场景，推荐组件应该是一个全局组件，类似于alert的效果， 不需要设置html标签；<br>为了实现这种方式，需要先理解vue的组件是如何渲染的；</p>\n<h2 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h2><p>vue是将el或template字段传入的内容编译成渲染函数，渲染函数会把模板编译成虚拟DOM节点，同时每个渲染函数都对应一个观察者（watcher), watcher会监听每个数据的get和set操作，这样就实现了当数据修改时能同步渲染DOM树；</p>\n<p><img src=\"/blog/2018/10/12/vue渲染机制/vue渲染机制.png\" alt=\"渲染机制\"></p>\n<p>这里我们重点关注前半部分，也就是el转换为template，template生成渲染函数；</p>\n<p>这部分的源码在src/platforms/web/entry-runtime-with-compiler.js中。</p>\n<p>大致的实现是这样的：</p>\n<ul>\n<li>如果 template 选项不存在，那么使用 el 元素的 outerHTML 作为模板内容</li>\n<li>如果 template 选项存在，且 template 的类型是字符串，有分两种情况：<br><strong> 如果第一个字符是 #，那么会把该字符串作为 css 选择符去选中对应的元素，并把该元素的 innerHTML 作为模板\n</strong> 如果第一个字符不是 #，那么什么都不做，就用 template 自身的字符串值作为模板</li>\n<li>如果 template 选项存在，且 template 的类型是元素节点(template.nodeType 存在)则使用该元素的 innerHTML 作为模板</li>\n</ul>\n<p>我们项目中常用的单文件组件（.vue文件）会在打包时通过vue-loader直接编译成渲染函数；</p>\n<p>这是通常我们组件的渲染流程，我们需要el作为挂载点把编译后的模板挂载在DOM树上；</p>\n<p>如果要实现类似alert的效果，还不够！</p>\n<h2 id=\"mount挂载函数\"><a href=\"#mount挂载函数\" class=\"headerlink\" title=\"$mount挂载函数\"></a>$mount挂载函数</h2><p>参考elementUI组件的设计，采用$mount函数实现异步挂载；</p>\n<p><img src=\"/blog/2018/10/12/vue渲染机制/$mount使用方法.jpg\" alt=\"$mount官网介绍\"></p>\n<p>实际上在vue实例化的过程中，就是通过$mount函数进行模板编译的，我们前面讨论的渲染过程就是在完整版vue的$mount函数中进行的；</p>\n<p>同时，$mount也是vue的实例方法，可通过vue的实例调用；</p>\n<p>回到组件的设计：<br>1、组件本身是独立的vue实例，一个通过extend创建的Vue的‘子类’；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;;</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">const RecommondConstructor = Vue.extend(Main);</span><br></pre></td></tr></table></figure></p>\n<p>2、和创建普通vue实例一样,通过new的方式创建实例；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance = new RecommondConstructor(&#123;</span><br><span class=\"line\">  data: &#123; list: options &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、创建实例后，调用$mount挂载函数，创建实例的选项中不设置el，根据$mount官方说明，模板将被渲染为文档之外的的元素；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance.vm = instance.$mount();</span><br></pre></td></tr></table></figure></p>\n<p>4、在实例挂载之后，元素可以用 vm.$el 访问。再通过原生的DOM API添加到body中；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild(instance.vm.$el);</span><br></pre></td></tr></table></figure></p>\n<p>5、最后通过插件的方式，把上面组件的实例化方法挂在vue的实例上；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import recommond from &apos;./main&apos;;</span><br><span class=\"line\">const install = function install(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">  Vue.component(&apos;recommondImage&apos;, recommond);</span><br><span class=\"line\">  Vue.prototype.$recommond = &#123;</span><br><span class=\"line\">    show: recommond,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样通过，调用this.recommond.show()方法，就会显示推荐组件；</p>\n<h2 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h2><p>前面提到了，推荐组件需要支持轮播效果，需要借助swiper来实现；</p>\n<p>swiper是直接通过操作DOM来实现效果的，因此需要在组件完全渲染到DOM树上之后再进行swiper的实例化；</p>\n<p>这里有一个问题，在组件的mounted生命周期里是否完成DOM的加载？</p>\n<p>一般来说，mounted生命周期中是可以操作DOM树的，但是在我们设计的推荐组件中，是不可以的！</p>\n<p>在这个例子中，组件在调用$mount时，没有传入el，因此模板将被渲染为文档之外的的元素；也就是说DOM文档树上还没有组件的节点；</p>\n<p>我们是通过DOM API异步加载在DOM树上的；</p>\n<p>因此mounted生命周期中直接操作DOM是不可行的；</p>\n<h2 id=\"nextTick函数\"><a href=\"#nextTick函数\" class=\"headerlink\" title=\"nextTick函数\"></a>nextTick函数</h2><p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>先来看下nextTick的实现原理；</p>\n<h4 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h4><p>下图是js的事件循环机制：<br><img src=\"/blog/2018/10/12/vue渲染机制/事件循环.png\" alt=\"事件循环机制\"></p>\n<h4 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h4><p>javascript中任务队列分为两类：microtask和（marco）task</p>\n<ul>\n<li>microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，同一个事件循环中的microtask会按队列顺序，串行执行完毕；</li>\n<li>macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，同一事件循环中，只执行一个。</li>\n</ul>\n<h4 id=\"更完整的事件循环\"><a href=\"#更完整的事件循环\" class=\"headerlink\" title=\"更完整的事件循环\"></a>更完整的事件循环</h4><ul>\n<li>每个任务循环，先执行主线程的任务-&gt;执行microtask队列中所有的任务-&gt;从marcotask中取一个任务；<br>之后重复上述循环，而在microtask和marcotask之间会进行DOM树渲染，如果能在mircotask中更新完全部数据，那么只需要渲染一次就变更成最新的DOM了；</li>\n<li>属于microtask的任务：ES6的promise，MutationObserver，process.nextTick</li>\n<li>属于marcotask的任务：setTimeout，setInterval，setImmediate，MessageChannel，I/O，UIrending</li>\n</ul>\n<h4 id=\"nextTick实现\"><a href=\"#nextTick实现\" class=\"headerlink\" title=\"nextTick实现\"></a>nextTick实现</h4><p>vue的$nextTick就是根据事件循环机制来实现的：</p>\n<ol>\n<li>浏览器支持Promise优先使用Promise</li>\n<li>其次选择setImmediate，缺点是，setImmediate只有部分高级IE浏览器支持的方法</li>\n<li>再次采用MessageChannel，不需要做超时检测</li>\n<li>最终选择setTimeout，最后才采用setTimeout的方式，是因为setTimeout将回调注册为task之前要不停的进行超时检测，有一定的性能损耗；</li>\n</ol>\n<p>回到组件开发上，只需要在nextTick方法中进行swpier的初始化就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">\tthis.$nextTick(function() &#123;</span><br><span class=\"line\">\t\tif(this.isImgNull()) &#123;</span><br><span class=\"line\">\t\t\tconst mySwiper1 = new Swiper(&apos;#js_swiper2&apos;, &#123;</span><br><span class=\"line\">\t\t\t\tcenteredSlides: true,</span><br><span class=\"line\">\t\t\t\tloop: true,</span><br><span class=\"line\">\t            slidesPerView: &apos;auto&apos;,</span><br><span class=\"line\">\t        \tautoplay: &#123;</span><br><span class=\"line\">\t            \tdelay: 2000</span><br><span class=\"line\">\t        \t&#125;,</span><br><span class=\"line\">\t        \tpagination: &#123;</span><br><span class=\"line\">\t            \tel: &apos;.swiper-pagination&apos;</span><br><span class=\"line\">\t        \t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tthis.visible = true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>结合推荐组件的开发，梳理清楚了VUE的渲染机制，以及nextTick的底层实现；在以后开发设计中可以写出更有效率的代码；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期在做一个前端推荐的组件，类似与各个APP打开时弹出的推荐效果，效果如下：<br><img src=\"/blog/2018/10/12/vue渲染机制/效果图.jpg\" alt=\"效果图\"><br>同时需要支持推荐多个，UED给出的效果图是类似轮播图的实现。<br>我需要将这个效果封装成一个独立的模块，提供给多个前端（和生活、营销）的多个位置使用（首页、营销活动页面。。）使用；</p>\n<h2 id=\"组件设计\"><a href=\"#组件设计\" class=\"headerlink\" title=\"组件设计\"></a>组件设计</h2><p>在vue中，任何一个独立的UI模块都可以封装成（.vue）的组件；一般情况下，vue的组件都对应一个html自定义标签，在编译过程中，把组件模板替换到标签位置。但这种方式不适合当前的场景，推荐组件应该是一个全局组件，类似于alert的效果， 不需要设置html标签；<br>为了实现这种方式，需要先理解vue的组件是如何渲染的；</p>\n<h2 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h2><p>vue是将el或template字段传入的内容编译成渲染函数，渲染函数会把模板编译成虚拟DOM节点，同时每个渲染函数都对应一个观察者（watcher), watcher会监听每个数据的get和set操作，这样就实现了当数据修改时能同步渲染DOM树；</p>\n<p><img src=\"/blog/2018/10/12/vue渲染机制/vue渲染机制.png\" alt=\"渲染机制\"></p>\n<p>这里我们重点关注前半部分，也就是el转换为template，template生成渲染函数；</p>\n<p>这部分的源码在src/platforms/web/entry-runtime-with-compiler.js中。</p>\n<p>大致的实现是这样的：</p>\n<ul>\n<li>如果 template 选项不存在，那么使用 el 元素的 outerHTML 作为模板内容</li>\n<li>如果 template 选项存在，且 template 的类型是字符串，有分两种情况：<br><strong> 如果第一个字符是 #，那么会把该字符串作为 css 选择符去选中对应的元素，并把该元素的 innerHTML 作为模板\n</strong> 如果第一个字符不是 #，那么什么都不做，就用 template 自身的字符串值作为模板</li>\n<li>如果 template 选项存在，且 template 的类型是元素节点(template.nodeType 存在)则使用该元素的 innerHTML 作为模板</li>\n</ul>\n<p>我们项目中常用的单文件组件（.vue文件）会在打包时通过vue-loader直接编译成渲染函数；</p>\n<p>这是通常我们组件的渲染流程，我们需要el作为挂载点把编译后的模板挂载在DOM树上；</p>\n<p>如果要实现类似alert的效果，还不够！</p>\n<h2 id=\"mount挂载函数\"><a href=\"#mount挂载函数\" class=\"headerlink\" title=\"$mount挂载函数\"></a>$mount挂载函数</h2><p>参考elementUI组件的设计，采用$mount函数实现异步挂载；</p>\n<p><img src=\"/blog/2018/10/12/vue渲染机制/$mount使用方法.jpg\" alt=\"$mount官网介绍\"></p>\n<p>实际上在vue实例化的过程中，就是通过$mount函数进行模板编译的，我们前面讨论的渲染过程就是在完整版vue的$mount函数中进行的；</p>\n<p>同时，$mount也是vue的实例方法，可通过vue的实例调用；</p>\n<p>回到组件的设计：<br>1、组件本身是独立的vue实例，一个通过extend创建的Vue的‘子类’；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;;</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">const RecommondConstructor = Vue.extend(Main);</span><br></pre></td></tr></table></figure></p>\n<p>2、和创建普通vue实例一样,通过new的方式创建实例；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance = new RecommondConstructor(&#123;</span><br><span class=\"line\">  data: &#123; list: options &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、创建实例后，调用$mount挂载函数，创建实例的选项中不设置el，根据$mount官方说明，模板将被渲染为文档之外的的元素；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance.vm = instance.$mount();</span><br></pre></td></tr></table></figure></p>\n<p>4、在实例挂载之后，元素可以用 vm.$el 访问。再通过原生的DOM API添加到body中；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild(instance.vm.$el);</span><br></pre></td></tr></table></figure></p>\n<p>5、最后通过插件的方式，把上面组件的实例化方法挂在vue的实例上；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import recommond from &apos;./main&apos;;</span><br><span class=\"line\">const install = function install(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">  Vue.component(&apos;recommondImage&apos;, recommond);</span><br><span class=\"line\">  Vue.prototype.$recommond = &#123;</span><br><span class=\"line\">    show: recommond,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样通过，调用this.recommond.show()方法，就会显示推荐组件；</p>\n<h2 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h2><p>前面提到了，推荐组件需要支持轮播效果，需要借助swiper来实现；</p>\n<p>swiper是直接通过操作DOM来实现效果的，因此需要在组件完全渲染到DOM树上之后再进行swiper的实例化；</p>\n<p>这里有一个问题，在组件的mounted生命周期里是否完成DOM的加载？</p>\n<p>一般来说，mounted生命周期中是可以操作DOM树的，但是在我们设计的推荐组件中，是不可以的！</p>\n<p>在这个例子中，组件在调用$mount时，没有传入el，因此模板将被渲染为文档之外的的元素；也就是说DOM文档树上还没有组件的节点；</p>\n<p>我们是通过DOM API异步加载在DOM树上的；</p>\n<p>因此mounted生命周期中直接操作DOM是不可行的；</p>\n<h2 id=\"nextTick函数\"><a href=\"#nextTick函数\" class=\"headerlink\" title=\"nextTick函数\"></a>nextTick函数</h2><p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>先来看下nextTick的实现原理；</p>\n<h4 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h4><p>下图是js的事件循环机制：<br><img src=\"/blog/2018/10/12/vue渲染机制/事件循环.png\" alt=\"事件循环机制\"></p>\n<h4 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h4><p>javascript中任务队列分为两类：microtask和（marco）task</p>\n<ul>\n<li>microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，同一个事件循环中的microtask会按队列顺序，串行执行完毕；</li>\n<li>macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，同一事件循环中，只执行一个。</li>\n</ul>\n<h4 id=\"更完整的事件循环\"><a href=\"#更完整的事件循环\" class=\"headerlink\" title=\"更完整的事件循环\"></a>更完整的事件循环</h4><ul>\n<li>每个任务循环，先执行主线程的任务-&gt;执行microtask队列中所有的任务-&gt;从marcotask中取一个任务；<br>之后重复上述循环，而在microtask和marcotask之间会进行DOM树渲染，如果能在mircotask中更新完全部数据，那么只需要渲染一次就变更成最新的DOM了；</li>\n<li>属于microtask的任务：ES6的promise，MutationObserver，process.nextTick</li>\n<li>属于marcotask的任务：setTimeout，setInterval，setImmediate，MessageChannel，I/O，UIrending</li>\n</ul>\n<h4 id=\"nextTick实现\"><a href=\"#nextTick实现\" class=\"headerlink\" title=\"nextTick实现\"></a>nextTick实现</h4><p>vue的$nextTick就是根据事件循环机制来实现的：</p>\n<ol>\n<li>浏览器支持Promise优先使用Promise</li>\n<li>其次选择setImmediate，缺点是，setImmediate只有部分高级IE浏览器支持的方法</li>\n<li>再次采用MessageChannel，不需要做超时检测</li>\n<li>最终选择setTimeout，最后才采用setTimeout的方式，是因为setTimeout将回调注册为task之前要不停的进行超时检测，有一定的性能损耗；</li>\n</ol>\n<p>回到组件开发上，只需要在nextTick方法中进行swpier的初始化就可以了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">\tthis.$nextTick(function() &#123;</span><br><span class=\"line\">\t\tif(this.isImgNull()) &#123;</span><br><span class=\"line\">\t\t\tconst mySwiper1 = new Swiper(&apos;#js_swiper2&apos;, &#123;</span><br><span class=\"line\">\t\t\t\tcenteredSlides: true,</span><br><span class=\"line\">\t\t\t\tloop: true,</span><br><span class=\"line\">\t            slidesPerView: &apos;auto&apos;,</span><br><span class=\"line\">\t        \tautoplay: &#123;</span><br><span class=\"line\">\t            \tdelay: 2000</span><br><span class=\"line\">\t        \t&#125;,</span><br><span class=\"line\">\t        \tpagination: &#123;</span><br><span class=\"line\">\t            \tel: &apos;.swiper-pagination&apos;</span><br><span class=\"line\">\t        \t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tthis.visible = true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>结合推荐组件的开发，梳理清楚了VUE的渲染机制，以及nextTick的底层实现；在以后开发设计中可以写出更有效率的代码；</p>\n"},{"title":"jenkins+Gitlab持续集成前端项目实践","date":"2018-06-21T08:56:48.000Z","_content":"\n安装插件\n---\n由于相关项目在gitLab上管理因此需要安装相关插件：\nGit plugin    \nGitLab Plugin\nPublish Over FTP\nNodeJS Plugin\n\n部署jenkins的机器如果有网络可通过jenkins管理界面直接安装：\n![Jenkins配置](jenkins插件.jpg)\n\n全局配置\n---\n#### git配置\n在系统管理--全局工具配置界面，配置git环境变量\n![git配置](git配置.jpg)\n\nPath to Git executable这里会从环境变量的配置中找git，找不到会提示：\n![git配置](git配置异常.jpg)\n\n填写完整路径也可以识别，但是在执行打包命令时会出现问题；\n\n#### FTP配置\n在系统管理--全局工具配置界面，配置FTP信息，配置用于构建完成后执行FTP操作的主机；\n![FTP配置](FTP配置.jpg)\n\n#### 邮件配置\n配置邮件通知，当构建失败后，通知项目相关人员\n![邮件配置](邮件配置.jpg)\n\n#### nodejs配置\n执行构建的命令需要借助nodejs\n![nodejs配置](nodejs配置.jpg)\n\n\n配置一个构建流程\n---\n新建任务选择，构建一个自由风格的软件项目\n![新建任务](新建任务.jpg)\n\n#### 源码管理\n源码管理采用Git\n![源码管理](源码管理.jpg)\n\n#### 构建环境\n![构建环境](构建环境.jpg)\n\n#### 构建\n部署jenkins的机器是windows系统，因此这里选择执行windows批处理命令；\n![构建](构建.jpg)\n\n#### 构建后操作\n构建后操作有两步\n##### 收件人配置\n![邮件提醒](邮件提醒.jpg)\n##### FTP任务\n![FTP任务配置](FTP任务配置.jpg)\n\n配置完成，现在我在执行上线操作，只需要登录jenkins的选择指定的项目，执行构建即可，构建过程也可以在页面中看到；\n![界面化操作](界面化操作.jpg)\n![构建日志](构建日志.jpg)\n\n来看看jenkins替代了多少操作：\n1、从git上develop分支下载最新的代码；\n2、执行构建操作，实际上就是执行npm run build\n3、FTP到指定主机的指定目录；\n\n实际上，jenkins可以做的更多；集成gitlab的插件，在gitlab中配置webhook后，回调jenkins执行持续集成，那么只要在指定分支上执行push操作后，就会自动执行持续集成操作；\n\n山西现场由于网络原因，jenkins和gitlab部署的主机网络不通，gitLab回调无法请求到jenkins，只能作罢；\n\n##### 部署集成环境遇到的坑：\n1、git要配置环境变量，否则执行构建时会提示找不到命令；\n2、首次配置需要在jenkins下载的项目中，先执行npm install，安装好相关模块；\n3、需要在jenkins中安装nodejs插件，否则即使主机上安装有nodejs和npm也无法执行npm命令\n","source":"_posts/jenkins持续集成前端项目实践.md","raw":"---\ntitle: jenkins+Gitlab持续集成前端项目实践\ndate: 2018-06-21 08:56:48\ntags:\n---\n\n安装插件\n---\n由于相关项目在gitLab上管理因此需要安装相关插件：\nGit plugin    \nGitLab Plugin\nPublish Over FTP\nNodeJS Plugin\n\n部署jenkins的机器如果有网络可通过jenkins管理界面直接安装：\n![Jenkins配置](jenkins插件.jpg)\n\n全局配置\n---\n#### git配置\n在系统管理--全局工具配置界面，配置git环境变量\n![git配置](git配置.jpg)\n\nPath to Git executable这里会从环境变量的配置中找git，找不到会提示：\n![git配置](git配置异常.jpg)\n\n填写完整路径也可以识别，但是在执行打包命令时会出现问题；\n\n#### FTP配置\n在系统管理--全局工具配置界面，配置FTP信息，配置用于构建完成后执行FTP操作的主机；\n![FTP配置](FTP配置.jpg)\n\n#### 邮件配置\n配置邮件通知，当构建失败后，通知项目相关人员\n![邮件配置](邮件配置.jpg)\n\n#### nodejs配置\n执行构建的命令需要借助nodejs\n![nodejs配置](nodejs配置.jpg)\n\n\n配置一个构建流程\n---\n新建任务选择，构建一个自由风格的软件项目\n![新建任务](新建任务.jpg)\n\n#### 源码管理\n源码管理采用Git\n![源码管理](源码管理.jpg)\n\n#### 构建环境\n![构建环境](构建环境.jpg)\n\n#### 构建\n部署jenkins的机器是windows系统，因此这里选择执行windows批处理命令；\n![构建](构建.jpg)\n\n#### 构建后操作\n构建后操作有两步\n##### 收件人配置\n![邮件提醒](邮件提醒.jpg)\n##### FTP任务\n![FTP任务配置](FTP任务配置.jpg)\n\n配置完成，现在我在执行上线操作，只需要登录jenkins的选择指定的项目，执行构建即可，构建过程也可以在页面中看到；\n![界面化操作](界面化操作.jpg)\n![构建日志](构建日志.jpg)\n\n来看看jenkins替代了多少操作：\n1、从git上develop分支下载最新的代码；\n2、执行构建操作，实际上就是执行npm run build\n3、FTP到指定主机的指定目录；\n\n实际上，jenkins可以做的更多；集成gitlab的插件，在gitlab中配置webhook后，回调jenkins执行持续集成，那么只要在指定分支上执行push操作后，就会自动执行持续集成操作；\n\n山西现场由于网络原因，jenkins和gitlab部署的主机网络不通，gitLab回调无法请求到jenkins，只能作罢；\n\n##### 部署集成环境遇到的坑：\n1、git要配置环境变量，否则执行构建时会提示找不到命令；\n2、首次配置需要在jenkins下载的项目中，先执行npm install，安装好相关模块；\n3、需要在jenkins中安装nodejs插件，否则即使主机上安装有nodejs和npm也无法执行npm命令\n","slug":"jenkins持续集成前端项目实践","published":1,"updated":"2018-12-31T03:11:57.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11uf00072om2fxwrjb9t","content":"<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>由于相关项目在gitLab上管理因此需要安装相关插件：<br>Git plugin<br>GitLab Plugin<br>Publish Over FTP<br>NodeJS Plugin</p>\n<p>部署jenkins的机器如果有网络可通过jenkins管理界面直接安装：<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/jenkins插件.jpg\" alt=\"Jenkins配置\"></p>\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><h4 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h4><p>在系统管理–全局工具配置界面，配置git环境变量<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/git配置.jpg\" alt=\"git配置\"></p>\n<p>Path to Git executable这里会从环境变量的配置中找git，找不到会提示：<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/git配置异常.jpg\" alt=\"git配置\"></p>\n<p>填写完整路径也可以识别，但是在执行打包命令时会出现问题；</p>\n<h4 id=\"FTP配置\"><a href=\"#FTP配置\" class=\"headerlink\" title=\"FTP配置\"></a>FTP配置</h4><p>在系统管理–全局工具配置界面，配置FTP信息，配置用于构建完成后执行FTP操作的主机；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/FTP配置.jpg\" alt=\"FTP配置\"></p>\n<h4 id=\"邮件配置\"><a href=\"#邮件配置\" class=\"headerlink\" title=\"邮件配置\"></a>邮件配置</h4><p>配置邮件通知，当构建失败后，通知项目相关人员<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/邮件配置.jpg\" alt=\"邮件配置\"></p>\n<h4 id=\"nodejs配置\"><a href=\"#nodejs配置\" class=\"headerlink\" title=\"nodejs配置\"></a>nodejs配置</h4><p>执行构建的命令需要借助nodejs<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/nodejs配置.jpg\" alt=\"nodejs配置\"></p>\n<h2 id=\"配置一个构建流程\"><a href=\"#配置一个构建流程\" class=\"headerlink\" title=\"配置一个构建流程\"></a>配置一个构建流程</h2><p>新建任务选择，构建一个自由风格的软件项目<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/新建任务.jpg\" alt=\"新建任务\"></p>\n<h4 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h4><p>源码管理采用Git<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/源码管理.jpg\" alt=\"源码管理\"></p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建环境.jpg\" alt=\"构建环境\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>部署jenkins的机器是windows系统，因此这里选择执行windows批处理命令；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建.jpg\" alt=\"构建\"></p>\n<h4 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h4><p>构建后操作有两步</p>\n<h5 id=\"收件人配置\"><a href=\"#收件人配置\" class=\"headerlink\" title=\"收件人配置\"></a>收件人配置</h5><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/邮件提醒.jpg\" alt=\"邮件提醒\"></p>\n<h5 id=\"FTP任务\"><a href=\"#FTP任务\" class=\"headerlink\" title=\"FTP任务\"></a>FTP任务</h5><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/FTP任务配置.jpg\" alt=\"FTP任务配置\"></p>\n<p>配置完成，现在我在执行上线操作，只需要登录jenkins的选择指定的项目，执行构建即可，构建过程也可以在页面中看到；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/界面化操作.jpg\" alt=\"界面化操作\"><br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建日志.jpg\" alt=\"构建日志\"></p>\n<p>来看看jenkins替代了多少操作：<br>1、从git上develop分支下载最新的代码；<br>2、执行构建操作，实际上就是执行npm run build<br>3、FTP到指定主机的指定目录；</p>\n<p>实际上，jenkins可以做的更多；集成gitlab的插件，在gitlab中配置webhook后，回调jenkins执行持续集成，那么只要在指定分支上执行push操作后，就会自动执行持续集成操作；</p>\n<p>山西现场由于网络原因，jenkins和gitlab部署的主机网络不通，gitLab回调无法请求到jenkins，只能作罢；</p>\n<h5 id=\"部署集成环境遇到的坑：\"><a href=\"#部署集成环境遇到的坑：\" class=\"headerlink\" title=\"部署集成环境遇到的坑：\"></a>部署集成环境遇到的坑：</h5><p>1、git要配置环境变量，否则执行构建时会提示找不到命令；<br>2、首次配置需要在jenkins下载的项目中，先执行npm install，安装好相关模块；<br>3、需要在jenkins中安装nodejs插件，否则即使主机上安装有nodejs和npm也无法执行npm命令</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>由于相关项目在gitLab上管理因此需要安装相关插件：<br>Git plugin<br>GitLab Plugin<br>Publish Over FTP<br>NodeJS Plugin</p>\n<p>部署jenkins的机器如果有网络可通过jenkins管理界面直接安装：<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/jenkins插件.jpg\" alt=\"Jenkins配置\"></p>\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><h4 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h4><p>在系统管理–全局工具配置界面，配置git环境变量<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/git配置.jpg\" alt=\"git配置\"></p>\n<p>Path to Git executable这里会从环境变量的配置中找git，找不到会提示：<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/git配置异常.jpg\" alt=\"git配置\"></p>\n<p>填写完整路径也可以识别，但是在执行打包命令时会出现问题；</p>\n<h4 id=\"FTP配置\"><a href=\"#FTP配置\" class=\"headerlink\" title=\"FTP配置\"></a>FTP配置</h4><p>在系统管理–全局工具配置界面，配置FTP信息，配置用于构建完成后执行FTP操作的主机；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/FTP配置.jpg\" alt=\"FTP配置\"></p>\n<h4 id=\"邮件配置\"><a href=\"#邮件配置\" class=\"headerlink\" title=\"邮件配置\"></a>邮件配置</h4><p>配置邮件通知，当构建失败后，通知项目相关人员<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/邮件配置.jpg\" alt=\"邮件配置\"></p>\n<h4 id=\"nodejs配置\"><a href=\"#nodejs配置\" class=\"headerlink\" title=\"nodejs配置\"></a>nodejs配置</h4><p>执行构建的命令需要借助nodejs<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/nodejs配置.jpg\" alt=\"nodejs配置\"></p>\n<h2 id=\"配置一个构建流程\"><a href=\"#配置一个构建流程\" class=\"headerlink\" title=\"配置一个构建流程\"></a>配置一个构建流程</h2><p>新建任务选择，构建一个自由风格的软件项目<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/新建任务.jpg\" alt=\"新建任务\"></p>\n<h4 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h4><p>源码管理采用Git<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/源码管理.jpg\" alt=\"源码管理\"></p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建环境.jpg\" alt=\"构建环境\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>部署jenkins的机器是windows系统，因此这里选择执行windows批处理命令；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建.jpg\" alt=\"构建\"></p>\n<h4 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h4><p>构建后操作有两步</p>\n<h5 id=\"收件人配置\"><a href=\"#收件人配置\" class=\"headerlink\" title=\"收件人配置\"></a>收件人配置</h5><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/邮件提醒.jpg\" alt=\"邮件提醒\"></p>\n<h5 id=\"FTP任务\"><a href=\"#FTP任务\" class=\"headerlink\" title=\"FTP任务\"></a>FTP任务</h5><p><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/FTP任务配置.jpg\" alt=\"FTP任务配置\"></p>\n<p>配置完成，现在我在执行上线操作，只需要登录jenkins的选择指定的项目，执行构建即可，构建过程也可以在页面中看到；<br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/界面化操作.jpg\" alt=\"界面化操作\"><br><img src=\"/blog/2018/06/21/jenkins持续集成前端项目实践/构建日志.jpg\" alt=\"构建日志\"></p>\n<p>来看看jenkins替代了多少操作：<br>1、从git上develop分支下载最新的代码；<br>2、执行构建操作，实际上就是执行npm run build<br>3、FTP到指定主机的指定目录；</p>\n<p>实际上，jenkins可以做的更多；集成gitlab的插件，在gitlab中配置webhook后，回调jenkins执行持续集成，那么只要在指定分支上执行push操作后，就会自动执行持续集成操作；</p>\n<p>山西现场由于网络原因，jenkins和gitlab部署的主机网络不通，gitLab回调无法请求到jenkins，只能作罢；</p>\n<h5 id=\"部署集成环境遇到的坑：\"><a href=\"#部署集成环境遇到的坑：\" class=\"headerlink\" title=\"部署集成环境遇到的坑：\"></a>部署集成环境遇到的坑：</h5><p>1、git要配置环境变量，否则执行构建时会提示找不到命令；<br>2、首次配置需要在jenkins下载的项目中，先执行npm install，安装好相关模块；<br>3、需要在jenkins中安装nodejs插件，否则即使主机上安装有nodejs和npm也无法执行npm命令</p>\n"},{"title":"加密签名与解密验签总结","date":"2019-01-08T14:51:30.000Z","_content":"\n背景\n---\n近期在做后台管理系统中，需要与其他系统交换信息，需要做加密和数字签名，发现对这部分还不甚了解，做了一些功课，总结一下。\n\n需求分析\n---\n应对场景是第三方系统与本系统进行数据交换时，确保数据传输过程没有被修改，并且由于在公网进行数据交换还必须保证交换数据中的敏感信息不能泄露。\n\n* 确保数据不被修改，可以采用数字签名方式，接收方需要对签名进行验签。\n* 敏感信息部分进行加密\n* 请求和响应都需要签名和加密\n* 加密方式选择更安全的非对称加密方式（RSA）\n\n基本设计方案\n---\n基本方案采用传统的签名验签流程\n能力使用方持有私钥，能开平台持有公钥\n\n签名验签流程：\n![签名验签流程](签名验签流程.jpg)\n\n实际使用中，每一个能力使用方，需要在能开平台录入公钥信息；\n\n性能问题\n---\n由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。\n\n因此当加密数据较大时，解密速率会严重影响交互性能。\n\n优化设计方案--应对大量数据加解密的性能问题\n---\n对大量数据采用性能更好的对称加密方式，使用非对称加密对密码进行加密，一起传递给接收方\n![签名验签流程](签名验签流程--应对大量数据传输时的加密效率问题.jpg)\n\n公钥证书的安全问题\n---\n上面的流程在传输过程中已经可以确保信息不被修改，不泄露敏感信息。唯一还可能存在的信息泄漏问题在于接收方的公钥存在被替换的可能（获取公钥的过程，或者人为替换），那么以上所有的加密都没有意义了。\n\n为了解决公钥的安全性问题，通常需要借助CA认证平台，进行公钥认证，获得“数据证书”。\n\n优化设计方案--数字证书方案\n---\n接入方需要把公钥在CA证书平台进行公证，拿到数字签名，同时，接受方需要获得CA平台的公钥。\n![签名验签流程](签名验签流程--增加数字证书流程.jpg)\n\n\n总结：\n---\n数据加密、签名是保障安全性的基础，越是需要保障数据安全的场景，加密签名的流程越复杂。\n\n附：常用加密算法\n---\n### 单秘钥密码（对称加密）\n加密和解密使用相同密钥的加密算法。\n优点：速度快，破译极其困难。适用于大量数据加密。\n缺点：加密的安全性依靠密钥保管的安全性。\n\n常用的对称加密算法是DES加密。\n\n#### DES加密\nDES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用\n* DES的原始思想可以参照二战德国的恩尼格玛机，其基本思想大致相同。传统的密码加密都是由古代的循环移位思想而来，恩尼格玛机在这个基础之上进行了扩散模糊。但是本质原理都是一样的。现代DES在二进制级别做着同样的事：替代模糊，增加分析的难度。\n* DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位（每组的第8位作为奇偶校验位），产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 轮循环，使用异或，置换，代换，移位操作四种基本运算。\n\n#### 3DES加密\n3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。\n\n#### AES加密\nAES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。\n\n\n### 消息摘要 （唯一性）\n一个消息摘要就是一个数据块的数字指纹。即对一个任意长度的一个数据块进行计算，产生一个唯一指印。\n优点：唯一性，两个不同的报文难以生成相同的摘要\n缺点：加密不可逆，难以而由数据指纹反推算出指定的摘要\n\n常用的消息摘要有：美国国家标准技术研究所的 SHA1 和麻省理工学院 Ronald Rivest 提出的 MD5\n\n#### SHA1加密算法\n安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。\n\n#### MD5加密算法\nMD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。\n\n#### Diffie-Hellman密钥协议算法\nDiffie-Hellman密钥协议算法是一种确保共享密钥KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分，由Whitefield与Martin Hellman在1976年提出。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。\n\n### 非对称算法与公钥体系\n在公钥体制中，加密密钥不同于解密密钥，加密密钥公之于众，谁都可以使用；解密密钥只有解密人自己知道。它们分别称为公开密钥（Public key）和秘密密钥（Private key）。\n\n常用的非对称加密算法是RSA\n\n#### RSA加密算法\nRSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。\n* 由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。\n* 比起DES和其它对称算法来说，RSA要慢得多。\n","source":"_posts/加密签名与解密验签总结.md","raw":"---\ntitle: 加密签名与解密验签总结\ndate: 2019-01-08 14:51:30\ntags:\n---\n\n背景\n---\n近期在做后台管理系统中，需要与其他系统交换信息，需要做加密和数字签名，发现对这部分还不甚了解，做了一些功课，总结一下。\n\n需求分析\n---\n应对场景是第三方系统与本系统进行数据交换时，确保数据传输过程没有被修改，并且由于在公网进行数据交换还必须保证交换数据中的敏感信息不能泄露。\n\n* 确保数据不被修改，可以采用数字签名方式，接收方需要对签名进行验签。\n* 敏感信息部分进行加密\n* 请求和响应都需要签名和加密\n* 加密方式选择更安全的非对称加密方式（RSA）\n\n基本设计方案\n---\n基本方案采用传统的签名验签流程\n能力使用方持有私钥，能开平台持有公钥\n\n签名验签流程：\n![签名验签流程](签名验签流程.jpg)\n\n实际使用中，每一个能力使用方，需要在能开平台录入公钥信息；\n\n性能问题\n---\n由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。\n\n因此当加密数据较大时，解密速率会严重影响交互性能。\n\n优化设计方案--应对大量数据加解密的性能问题\n---\n对大量数据采用性能更好的对称加密方式，使用非对称加密对密码进行加密，一起传递给接收方\n![签名验签流程](签名验签流程--应对大量数据传输时的加密效率问题.jpg)\n\n公钥证书的安全问题\n---\n上面的流程在传输过程中已经可以确保信息不被修改，不泄露敏感信息。唯一还可能存在的信息泄漏问题在于接收方的公钥存在被替换的可能（获取公钥的过程，或者人为替换），那么以上所有的加密都没有意义了。\n\n为了解决公钥的安全性问题，通常需要借助CA认证平台，进行公钥认证，获得“数据证书”。\n\n优化设计方案--数字证书方案\n---\n接入方需要把公钥在CA证书平台进行公证，拿到数字签名，同时，接受方需要获得CA平台的公钥。\n![签名验签流程](签名验签流程--增加数字证书流程.jpg)\n\n\n总结：\n---\n数据加密、签名是保障安全性的基础，越是需要保障数据安全的场景，加密签名的流程越复杂。\n\n附：常用加密算法\n---\n### 单秘钥密码（对称加密）\n加密和解密使用相同密钥的加密算法。\n优点：速度快，破译极其困难。适用于大量数据加密。\n缺点：加密的安全性依靠密钥保管的安全性。\n\n常用的对称加密算法是DES加密。\n\n#### DES加密\nDES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用\n* DES的原始思想可以参照二战德国的恩尼格玛机，其基本思想大致相同。传统的密码加密都是由古代的循环移位思想而来，恩尼格玛机在这个基础之上进行了扩散模糊。但是本质原理都是一样的。现代DES在二进制级别做着同样的事：替代模糊，增加分析的难度。\n* DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位（每组的第8位作为奇偶校验位），产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 轮循环，使用异或，置换，代换，移位操作四种基本运算。\n\n#### 3DES加密\n3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。\n\n#### AES加密\nAES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。\n\n\n### 消息摘要 （唯一性）\n一个消息摘要就是一个数据块的数字指纹。即对一个任意长度的一个数据块进行计算，产生一个唯一指印。\n优点：唯一性，两个不同的报文难以生成相同的摘要\n缺点：加密不可逆，难以而由数据指纹反推算出指定的摘要\n\n常用的消息摘要有：美国国家标准技术研究所的 SHA1 和麻省理工学院 Ronald Rivest 提出的 MD5\n\n#### SHA1加密算法\n安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。\n\n#### MD5加密算法\nMD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。\n\n#### Diffie-Hellman密钥协议算法\nDiffie-Hellman密钥协议算法是一种确保共享密钥KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分，由Whitefield与Martin Hellman在1976年提出。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。\n\n### 非对称算法与公钥体系\n在公钥体制中，加密密钥不同于解密密钥，加密密钥公之于众，谁都可以使用；解密密钥只有解密人自己知道。它们分别称为公开密钥（Public key）和秘密密钥（Private key）。\n\n常用的非对称加密算法是RSA\n\n#### RSA加密算法\nRSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。\n* 由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。\n* 比起DES和其它对称算法来说，RSA要慢得多。\n","slug":"加密签名与解密验签总结","published":1,"updated":"2019-01-09T07:21:25.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11ug00082om2rhbd5lqn","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期在做后台管理系统中，需要与其他系统交换信息，需要做加密和数字签名，发现对这部分还不甚了解，做了一些功课，总结一下。</p>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>应对场景是第三方系统与本系统进行数据交换时，确保数据传输过程没有被修改，并且由于在公网进行数据交换还必须保证交换数据中的敏感信息不能泄露。</p>\n<ul>\n<li>确保数据不被修改，可以采用数字签名方式，接收方需要对签名进行验签。</li>\n<li>敏感信息部分进行加密</li>\n<li>请求和响应都需要签名和加密</li>\n<li>加密方式选择更安全的非对称加密方式（RSA）</li>\n</ul>\n<h2 id=\"基本设计方案\"><a href=\"#基本设计方案\" class=\"headerlink\" title=\"基本设计方案\"></a>基本设计方案</h2><p>基本方案采用传统的签名验签流程<br>能力使用方持有私钥，能开平台持有公钥</p>\n<p>签名验签流程：<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程.jpg\" alt=\"签名验签流程\"></p>\n<p>实际使用中，每一个能力使用方，需要在能开平台录入公钥信息；</p>\n<h2 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h2><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。</p>\n<p>因此当加密数据较大时，解密速率会严重影响交互性能。</p>\n<h2 id=\"优化设计方案–应对大量数据加解密的性能问题\"><a href=\"#优化设计方案–应对大量数据加解密的性能问题\" class=\"headerlink\" title=\"优化设计方案–应对大量数据加解密的性能问题\"></a>优化设计方案–应对大量数据加解密的性能问题</h2><p>对大量数据采用性能更好的对称加密方式，使用非对称加密对密码进行加密，一起传递给接收方<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程--应对大量数据传输时的加密效率问题.jpg\" alt=\"签名验签流程\"></p>\n<h2 id=\"公钥证书的安全问题\"><a href=\"#公钥证书的安全问题\" class=\"headerlink\" title=\"公钥证书的安全问题\"></a>公钥证书的安全问题</h2><p>上面的流程在传输过程中已经可以确保信息不被修改，不泄露敏感信息。唯一还可能存在的信息泄漏问题在于接收方的公钥存在被替换的可能（获取公钥的过程，或者人为替换），那么以上所有的加密都没有意义了。</p>\n<p>为了解决公钥的安全性问题，通常需要借助CA认证平台，进行公钥认证，获得“数据证书”。</p>\n<h2 id=\"优化设计方案–数字证书方案\"><a href=\"#优化设计方案–数字证书方案\" class=\"headerlink\" title=\"优化设计方案–数字证书方案\"></a>优化设计方案–数字证书方案</h2><p>接入方需要把公钥在CA证书平台进行公证，拿到数字签名，同时，接受方需要获得CA平台的公钥。<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程--增加数字证书流程.jpg\" alt=\"签名验签流程\"></p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>数据加密、签名是保障安全性的基础，越是需要保障数据安全的场景，加密签名的流程越复杂。</p>\n<h2 id=\"附：常用加密算法\"><a href=\"#附：常用加密算法\" class=\"headerlink\" title=\"附：常用加密算法\"></a>附：常用加密算法</h2><h3 id=\"单秘钥密码（对称加密）\"><a href=\"#单秘钥密码（对称加密）\" class=\"headerlink\" title=\"单秘钥密码（对称加密）\"></a>单秘钥密码（对称加密）</h3><p>加密和解密使用相同密钥的加密算法。<br>优点：速度快，破译极其困难。适用于大量数据加密。<br>缺点：加密的安全性依靠密钥保管的安全性。</p>\n<p>常用的对称加密算法是DES加密。</p>\n<h4 id=\"DES加密\"><a href=\"#DES加密\" class=\"headerlink\" title=\"DES加密\"></a>DES加密</h4><p>DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用</p>\n<ul>\n<li>DES的原始思想可以参照二战德国的恩尼格玛机，其基本思想大致相同。传统的密码加密都是由古代的循环移位思想而来，恩尼格玛机在这个基础之上进行了扩散模糊。但是本质原理都是一样的。现代DES在二进制级别做着同样的事：替代模糊，增加分析的难度。</li>\n<li>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位（每组的第8位作为奇偶校验位），产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 轮循环，使用异或，置换，代换，移位操作四种基本运算。</li>\n</ul>\n<h4 id=\"3DES加密\"><a href=\"#3DES加密\" class=\"headerlink\" title=\"3DES加密\"></a>3DES加密</h4><p>3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。</p>\n<h4 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h4><p>AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。</p>\n<h3 id=\"消息摘要-（唯一性）\"><a href=\"#消息摘要-（唯一性）\" class=\"headerlink\" title=\"消息摘要 （唯一性）\"></a>消息摘要 （唯一性）</h3><p>一个消息摘要就是一个数据块的数字指纹。即对一个任意长度的一个数据块进行计算，产生一个唯一指印。<br>优点：唯一性，两个不同的报文难以生成相同的摘要<br>缺点：加密不可逆，难以而由数据指纹反推算出指定的摘要</p>\n<p>常用的消息摘要有：美国国家标准技术研究所的 SHA1 和麻省理工学院 Ronald Rivest 提出的 MD5</p>\n<h4 id=\"SHA1加密算法\"><a href=\"#SHA1加密算法\" class=\"headerlink\" title=\"SHA1加密算法\"></a>SHA1加密算法</h4><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</p>\n<h4 id=\"MD5加密算法\"><a href=\"#MD5加密算法\" class=\"headerlink\" title=\"MD5加密算法\"></a>MD5加密算法</h4><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。</p>\n<h4 id=\"Diffie-Hellman密钥协议算法\"><a href=\"#Diffie-Hellman密钥协议算法\" class=\"headerlink\" title=\"Diffie-Hellman密钥协议算法\"></a>Diffie-Hellman密钥协议算法</h4><p>Diffie-Hellman密钥协议算法是一种确保共享密钥KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分，由Whitefield与Martin Hellman在1976年提出。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。</p>\n<h3 id=\"非对称算法与公钥体系\"><a href=\"#非对称算法与公钥体系\" class=\"headerlink\" title=\"非对称算法与公钥体系\"></a>非对称算法与公钥体系</h3><p>在公钥体制中，加密密钥不同于解密密钥，加密密钥公之于众，谁都可以使用；解密密钥只有解密人自己知道。它们分别称为公开密钥（Public key）和秘密密钥（Private key）。</p>\n<p>常用的非对称加密算法是RSA</p>\n<h4 id=\"RSA加密算法\"><a href=\"#RSA加密算法\" class=\"headerlink\" title=\"RSA加密算法\"></a>RSA加密算法</h4><p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。</p>\n<ul>\n<li>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。</li>\n<li>比起DES和其它对称算法来说，RSA要慢得多。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近期在做后台管理系统中，需要与其他系统交换信息，需要做加密和数字签名，发现对这部分还不甚了解，做了一些功课，总结一下。</p>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>应对场景是第三方系统与本系统进行数据交换时，确保数据传输过程没有被修改，并且由于在公网进行数据交换还必须保证交换数据中的敏感信息不能泄露。</p>\n<ul>\n<li>确保数据不被修改，可以采用数字签名方式，接收方需要对签名进行验签。</li>\n<li>敏感信息部分进行加密</li>\n<li>请求和响应都需要签名和加密</li>\n<li>加密方式选择更安全的非对称加密方式（RSA）</li>\n</ul>\n<h2 id=\"基本设计方案\"><a href=\"#基本设计方案\" class=\"headerlink\" title=\"基本设计方案\"></a>基本设计方案</h2><p>基本方案采用传统的签名验签流程<br>能力使用方持有私钥，能开平台持有公钥</p>\n<p>签名验签流程：<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程.jpg\" alt=\"签名验签流程\"></p>\n<p>实际使用中，每一个能力使用方，需要在能开平台录入公钥信息；</p>\n<h2 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h2><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。</p>\n<p>因此当加密数据较大时，解密速率会严重影响交互性能。</p>\n<h2 id=\"优化设计方案–应对大量数据加解密的性能问题\"><a href=\"#优化设计方案–应对大量数据加解密的性能问题\" class=\"headerlink\" title=\"优化设计方案–应对大量数据加解密的性能问题\"></a>优化设计方案–应对大量数据加解密的性能问题</h2><p>对大量数据采用性能更好的对称加密方式，使用非对称加密对密码进行加密，一起传递给接收方<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程--应对大量数据传输时的加密效率问题.jpg\" alt=\"签名验签流程\"></p>\n<h2 id=\"公钥证书的安全问题\"><a href=\"#公钥证书的安全问题\" class=\"headerlink\" title=\"公钥证书的安全问题\"></a>公钥证书的安全问题</h2><p>上面的流程在传输过程中已经可以确保信息不被修改，不泄露敏感信息。唯一还可能存在的信息泄漏问题在于接收方的公钥存在被替换的可能（获取公钥的过程，或者人为替换），那么以上所有的加密都没有意义了。</p>\n<p>为了解决公钥的安全性问题，通常需要借助CA认证平台，进行公钥认证，获得“数据证书”。</p>\n<h2 id=\"优化设计方案–数字证书方案\"><a href=\"#优化设计方案–数字证书方案\" class=\"headerlink\" title=\"优化设计方案–数字证书方案\"></a>优化设计方案–数字证书方案</h2><p>接入方需要把公钥在CA证书平台进行公证，拿到数字签名，同时，接受方需要获得CA平台的公钥。<br><img src=\"/blog/2019/01/08/加密签名与解密验签总结/签名验签流程--增加数字证书流程.jpg\" alt=\"签名验签流程\"></p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>数据加密、签名是保障安全性的基础，越是需要保障数据安全的场景，加密签名的流程越复杂。</p>\n<h2 id=\"附：常用加密算法\"><a href=\"#附：常用加密算法\" class=\"headerlink\" title=\"附：常用加密算法\"></a>附：常用加密算法</h2><h3 id=\"单秘钥密码（对称加密）\"><a href=\"#单秘钥密码（对称加密）\" class=\"headerlink\" title=\"单秘钥密码（对称加密）\"></a>单秘钥密码（对称加密）</h3><p>加密和解密使用相同密钥的加密算法。<br>优点：速度快，破译极其困难。适用于大量数据加密。<br>缺点：加密的安全性依靠密钥保管的安全性。</p>\n<p>常用的对称加密算法是DES加密。</p>\n<h4 id=\"DES加密\"><a href=\"#DES加密\" class=\"headerlink\" title=\"DES加密\"></a>DES加密</h4><p>DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用</p>\n<ul>\n<li>DES的原始思想可以参照二战德国的恩尼格玛机，其基本思想大致相同。传统的密码加密都是由古代的循环移位思想而来，恩尼格玛机在这个基础之上进行了扩散模糊。但是本质原理都是一样的。现代DES在二进制级别做着同样的事：替代模糊，增加分析的难度。</li>\n<li>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位（每组的第8位作为奇偶校验位），产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 轮循环，使用异或，置换，代换，移位操作四种基本运算。</li>\n</ul>\n<h4 id=\"3DES加密\"><a href=\"#3DES加密\" class=\"headerlink\" title=\"3DES加密\"></a>3DES加密</h4><p>3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。</p>\n<h4 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h4><p>AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。</p>\n<h3 id=\"消息摘要-（唯一性）\"><a href=\"#消息摘要-（唯一性）\" class=\"headerlink\" title=\"消息摘要 （唯一性）\"></a>消息摘要 （唯一性）</h3><p>一个消息摘要就是一个数据块的数字指纹。即对一个任意长度的一个数据块进行计算，产生一个唯一指印。<br>优点：唯一性，两个不同的报文难以生成相同的摘要<br>缺点：加密不可逆，难以而由数据指纹反推算出指定的摘要</p>\n<p>常用的消息摘要有：美国国家标准技术研究所的 SHA1 和麻省理工学院 Ronald Rivest 提出的 MD5</p>\n<h4 id=\"SHA1加密算法\"><a href=\"#SHA1加密算法\" class=\"headerlink\" title=\"SHA1加密算法\"></a>SHA1加密算法</h4><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。</p>\n<h4 id=\"MD5加密算法\"><a href=\"#MD5加密算法\" class=\"headerlink\" title=\"MD5加密算法\"></a>MD5加密算法</h4><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。</p>\n<h4 id=\"Diffie-Hellman密钥协议算法\"><a href=\"#Diffie-Hellman密钥协议算法\" class=\"headerlink\" title=\"Diffie-Hellman密钥协议算法\"></a>Diffie-Hellman密钥协议算法</h4><p>Diffie-Hellman密钥协议算法是一种确保共享密钥KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分，由Whitefield与Martin Hellman在1976年提出。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。</p>\n<h3 id=\"非对称算法与公钥体系\"><a href=\"#非对称算法与公钥体系\" class=\"headerlink\" title=\"非对称算法与公钥体系\"></a>非对称算法与公钥体系</h3><p>在公钥体制中，加密密钥不同于解密密钥，加密密钥公之于众，谁都可以使用；解密密钥只有解密人自己知道。它们分别称为公开密钥（Public key）和秘密密钥（Private key）。</p>\n<p>常用的非对称加密算法是RSA</p>\n<h4 id=\"RSA加密算法\"><a href=\"#RSA加密算法\" class=\"headerlink\" title=\"RSA加密算法\"></a>RSA加密算法</h4><p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。</p>\n<ul>\n<li>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度是对应同样安全级别的对称密码算法的1/1000左右。</li>\n<li>比起DES和其它对称算法来说，RSA要慢得多。</li>\n</ul>\n"},{"title":"nginx配置踩坑--rewrite","date":"2018-09-05T18:52:43.000Z","_content":"问题\n---\n在协助部署吉林wap商城代码时，nginx配置出现一个问题；\n通常前端框架的nginx配置如下：\n```\n        location ~* \\.(html|htm)$ {\n            root /emallapp/Mobile_mall;\n            etag off;\n         if ($request_uri ~* \"^/([^/]*)/([^/]*).html\") {\n                set $appid $2;\n                rewrite ^/([^/]*)/([^/]*).html /$2.html;\n            }\n            if ($request_uri ~* \"^/([^/]*)/([^/]*)/([^/]*).html\") {\n                set $appid $3;\n                rewrite ^/([^/]*)/([^/]*)/([^/]*).html /$2.html;\n            }\n            index index.html index.htm;\n            expires 1s;\n        }\n```\n因为要增加上下文，需要在匹配html前先把上下文处理掉，否则资源文件无法找到：\n```\nlocatio~^/mall/ {\n        rewrite ^/mall/(.*)$ /$1 last;\n}\n```\n问题就出现在这里，增加了这段代码后，上面的html匹配不到了\n\n原因\n---\n在nginx中，\n* $request_uri是初始的uri，并且不随rewrite变化\n* $uri  是随rewrite变化的uri\n而rewrite中，匹配的链接就是$uri\n在上面的配置中，if条件的写法是正确的，而if条件体中rewrite这里出现了问题；\n\n在没有处理上下文时，rewrite的写法是正确的，这也是导致我先入为主，认为配置是正确的；\n但是，由于进行了上下文处理，rewrite后，uri已经发生了变化；\n\n此时下面的rewrite中的正则表达式是改变后的$uri\n因此正确的写法是这样：\n```\n        location ~* \\.(html|htm)$ {\n            root /emallapp/Mobile_mall;\n            etag off;\n         if ($request_uri ~* \"^/([^/]*)/([^/]*).html\") {\n                set $appid $2;\n            }\n            if ($request_uri ~* \"^/([^/]*)/([^/]*)/([^/]*).html\") {\n                set $appid $3;\n                rewrite ^/([^/]*)/([^/]*).html /$2.html;\n            }\n            index index.html index.htm;\n            expires 1s;\n        }\n```\n因为处理了上下文，所以rewrite时需要减少一个匹配组\n\n总结\n---\nrewrite中的匹配组对应的是$uri，收到rewrite的影响","source":"_posts/nginx配置踩坑-rewrite.md","raw":"---\ntitle: nginx配置踩坑--rewrite\ndate: 2018-09-05 18:52:43\ntags:\n---\n问题\n---\n在协助部署吉林wap商城代码时，nginx配置出现一个问题；\n通常前端框架的nginx配置如下：\n```\n        location ~* \\.(html|htm)$ {\n            root /emallapp/Mobile_mall;\n            etag off;\n         if ($request_uri ~* \"^/([^/]*)/([^/]*).html\") {\n                set $appid $2;\n                rewrite ^/([^/]*)/([^/]*).html /$2.html;\n            }\n            if ($request_uri ~* \"^/([^/]*)/([^/]*)/([^/]*).html\") {\n                set $appid $3;\n                rewrite ^/([^/]*)/([^/]*)/([^/]*).html /$2.html;\n            }\n            index index.html index.htm;\n            expires 1s;\n        }\n```\n因为要增加上下文，需要在匹配html前先把上下文处理掉，否则资源文件无法找到：\n```\nlocatio~^/mall/ {\n        rewrite ^/mall/(.*)$ /$1 last;\n}\n```\n问题就出现在这里，增加了这段代码后，上面的html匹配不到了\n\n原因\n---\n在nginx中，\n* $request_uri是初始的uri，并且不随rewrite变化\n* $uri  是随rewrite变化的uri\n而rewrite中，匹配的链接就是$uri\n在上面的配置中，if条件的写法是正确的，而if条件体中rewrite这里出现了问题；\n\n在没有处理上下文时，rewrite的写法是正确的，这也是导致我先入为主，认为配置是正确的；\n但是，由于进行了上下文处理，rewrite后，uri已经发生了变化；\n\n此时下面的rewrite中的正则表达式是改变后的$uri\n因此正确的写法是这样：\n```\n        location ~* \\.(html|htm)$ {\n            root /emallapp/Mobile_mall;\n            etag off;\n         if ($request_uri ~* \"^/([^/]*)/([^/]*).html\") {\n                set $appid $2;\n            }\n            if ($request_uri ~* \"^/([^/]*)/([^/]*)/([^/]*).html\") {\n                set $appid $3;\n                rewrite ^/([^/]*)/([^/]*).html /$2.html;\n            }\n            index index.html index.htm;\n            expires 1s;\n        }\n```\n因为处理了上下文，所以rewrite时需要减少一个匹配组\n\n总结\n---\nrewrite中的匹配组对应的是$uri，收到rewrite的影响","slug":"nginx配置踩坑-rewrite","published":1,"updated":"2018-09-05T10:54:16.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11wv00092om2gdgwjelm","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在协助部署吉林wap商城代码时，nginx配置出现一个问题；<br>通常前端框架的nginx配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* \\.(html|htm)$ &#123;</span><br><span class=\"line\">    root /emallapp/Mobile_mall;</span><br><span class=\"line\">    etag off;</span><br><span class=\"line\"> if ($request_uri ~* &quot;^/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $2;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ($request_uri ~* &quot;^/([^/]*)/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $3;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    expires 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为要增加上下文，需要在匹配html前先把上下文处理掉，否则资源文件无法找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locatio~^/mall/ &#123;</span><br><span class=\"line\">        rewrite ^/mall/(.*)$ /$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>问题就出现在这里，增加了这段代码后，上面的html匹配不到了</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>在nginx中，</p>\n<ul>\n<li>$request_uri是初始的uri，并且不随rewrite变化</li>\n<li>$uri  是随rewrite变化的uri<br>而rewrite中，匹配的链接就是$uri<br>在上面的配置中，if条件的写法是正确的，而if条件体中rewrite这里出现了问题；</li>\n</ul>\n<p>在没有处理上下文时，rewrite的写法是正确的，这也是导致我先入为主，认为配置是正确的；<br>但是，由于进行了上下文处理，rewrite后，uri已经发生了变化；</p>\n<p>此时下面的rewrite中的正则表达式是改变后的$uri<br>因此正确的写法是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* \\.(html|htm)$ &#123;</span><br><span class=\"line\">    root /emallapp/Mobile_mall;</span><br><span class=\"line\">    etag off;</span><br><span class=\"line\"> if ($request_uri ~* &quot;^/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ($request_uri ~* &quot;^/([^/]*)/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $3;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    expires 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为处理了上下文，所以rewrite时需要减少一个匹配组</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>rewrite中的匹配组对应的是$uri，收到rewrite的影响</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在协助部署吉林wap商城代码时，nginx配置出现一个问题；<br>通常前端框架的nginx配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* \\.(html|htm)$ &#123;</span><br><span class=\"line\">    root /emallapp/Mobile_mall;</span><br><span class=\"line\">    etag off;</span><br><span class=\"line\"> if ($request_uri ~* &quot;^/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $2;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ($request_uri ~* &quot;^/([^/]*)/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $3;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    expires 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为要增加上下文，需要在匹配html前先把上下文处理掉，否则资源文件无法找到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locatio~^/mall/ &#123;</span><br><span class=\"line\">        rewrite ^/mall/(.*)$ /$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>问题就出现在这里，增加了这段代码后，上面的html匹配不到了</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>在nginx中，</p>\n<ul>\n<li>$request_uri是初始的uri，并且不随rewrite变化</li>\n<li>$uri  是随rewrite变化的uri<br>而rewrite中，匹配的链接就是$uri<br>在上面的配置中，if条件的写法是正确的，而if条件体中rewrite这里出现了问题；</li>\n</ul>\n<p>在没有处理上下文时，rewrite的写法是正确的，这也是导致我先入为主，认为配置是正确的；<br>但是，由于进行了上下文处理，rewrite后，uri已经发生了变化；</p>\n<p>此时下面的rewrite中的正则表达式是改变后的$uri<br>因此正确的写法是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* \\.(html|htm)$ &#123;</span><br><span class=\"line\">    root /emallapp/Mobile_mall;</span><br><span class=\"line\">    etag off;</span><br><span class=\"line\"> if ($request_uri ~* &quot;^/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ($request_uri ~* &quot;^/([^/]*)/([^/]*)/([^/]*).html&quot;) &#123;</span><br><span class=\"line\">        set $appid $3;</span><br><span class=\"line\">        rewrite ^/([^/]*)/([^/]*).html /$2.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    expires 1s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为处理了上下文，所以rewrite时需要减少一个匹配组</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>rewrite中的匹配组对应的是$uri，收到rewrite的影响</p>\n"},{"title":"可视化编辑系统实践","date":"2018-05-29T18:42:19.000Z","_content":"这篇我想写写可视化编辑系统的实践，重点在数据模型，静态化，工作流，预览等一系列系统功能的实践上，具体的可视化编辑功能，将另开一贴来介绍；\n\n背景\n---\n前端工程中，有一些页面涉及运营位，根据市场的变化以及运营的要求，需要频繁的更迭，开发人员需要频繁的修改上线；由于生产环境的安全限制，手动上线费时费力，还需要走更多的流程（打申请，写文档，等审批），占用了大量的时间确不能产生多少价值；\n\nCMS\n---\n传统的解决方案就是采用内容管理平台，运营人员通过CMS来修改，发布内容，包括文字，图片，表格等等一切想要发布的信息；CMS系统把数据和模板结合起来，静态化生成HTML页面或代码块，通过ftp协议上传到前端应用中，供项目使用；\n\nCMS解决了2个问题：\n1、没有技术门槛，运营人员可通过界面操作来修改运营位内容；\n2、不需要手动上线，ftp一键上传；也省去了复杂的上线流程；\n\n使用CMS系统，解放了开发人员一部分时间，迭代效率提升不少；\n\nCMS系统已经向前迈了一大步，但仍存在不少问题：\n1. 比较笨重，有一定的门槛，需要有一个熟练的操作人员；\n2. CMS一般有复杂的数据结构，需要把每一个图片，文字都对应到一个数据库字段中；维护相对困难；\n3. 有一些抽象概念（栏目、内容...）；推广困难（用户有意向主动使用，但培训了多次，效果不佳，一直没有交出去）\n4. 模板复用率低，一旦有结构型的变化，需要开发人员修改模板；\n\n设计思路\n---\n最初的想法是复用CMS的数据结构，静态化的部分也可以复用；但这么做需要先把CMS的数据模型梳理出来，并且CMS本身不是前后端分离的架构，接口层需要重新开发；这样rest层需要针对不同的前端场景提供各种接口，多表关联的处理太多，rest层的开发将会非常复杂；还有，本次可视化的要求除了，编辑文字图片外，还要有“楼层”（首页的瀑布式结构）的处理（增加，删除，排序）甚至有“楼中楼”的情况，CMS的数据模型难以表达出楼层概念；\n\n如果把每一个页面元素都和数据库对应起来的话，整个系统会显得非常笨重，耦合度非常高，难以扩展，前端和后端的都不灵活；因此我们考虑，数据库只存储必要的信息，不记录所有的前端元素，只记录编辑完成的结果；\n\n前端编辑过程不和后端交互，编辑结束后，将最终的html代码段存储在数据库中，后端根据代码段来静态化生成页面，这样编辑的过程完全有前端工程去处理，这样更灵活也更轻量；\n\n但是这样做有一个难点：当下一次来编辑时，需要依据html代码块还原成可编辑的模板；之前保存在数据库中的是html代码的字符串，要把它还原成可编辑的模板，非常麻烦；\n\n为此，我们将可编辑的数据以一个json对象的形式存储在数据库中，下一次编辑时，前端通过json数据，结合VUE组件，渲染出可编辑界面；\n\n#### 具体的过程如下：\n1. 管理员访问后台编辑系统时，首先从数据库中查询出默认的json串，这个json串是初始化系统时录入的；前端根据json串，还原出可编辑界面；\n2. 管理员操作可编辑界面，前端记录修改，在保存时，把json串和html代码块一起存储在数据库中；\n3. 后端根据html代码块生成页面，并推送到前端工程使用；\n4. 管理员再次访问后台系统时，可根据json串，结合封装好的vue组件，把可编辑界面还原出来；（这个组件还用来实现了历史版本快照的功能）\n\n除了记录一些页面的固有信息，只存储json数据和html代码块，json用作还原可视化编辑界面，html代码块用来静态化生成页面；\n\n#### 数据模型：\n```bash\n  id    主键  ,\n  name   生成页名称  ,\n  area_code    地市  ,\n  type   类型 1:首页 2:地市专项  ,\n  json   json数据  ,\n  code   html代码块  ,\n  create_time   创建时间  ,\n  update_time   更新时间  ,\n  update_login_no   更新操作工号  ,\n  status   状态(0：编辑完成，1：审批中，2：审批完成，-1：被打回，9：生效，-9：失效)  ,\n  channels   发布渠道  ,\n  access_url 静态化页面路径,\n  remark1   备用字段1  ,\n  remark2   备用字段2  ,\n```\n\n工作流\n---\n根据用户的要求，可视化操作需要有审批流程，具体的审批流程是：\n1、地市发布人员--地市审批人员--省公司审批人员\n2、省公司发布人员--省公司审批人员\n并且，不同地市间，审批人员和发布人员不能交叉：\n![审批关系图](approvalProcess.jpg)\n\n工作流系统采用，Activity工作流系统\n\n流程相对简单，只有2级审批：\n\n1. 工作流角色定义四个角色，地市发布人员，地市审批人员，省公司审批人员和省公司审批人员；不同地市按照工号的归属地区来判定；这样，不同地市运营人员虽然同属一个角色，但依然可以做到审批流程不交叉；\n2. 工作流流转采用指定下一步审批人的方式，找到当前工号的角色在工作流中下一步角色的工号列表；\n3. 审批结束后，由最初的编辑人员执行发布；打回操作同样是直接打回到最初的发布人员；\n\n在实际对接工作流时，比预期要复杂，出现了各种问题：\n\n1. 实际场景中，还有另一个工作流（首页发布），只是完成地市发布，地市审批这样一个非常简单的工作流；但是这两个工作流对应的角色是重叠的，但是工号却不是，那么当选择下一步审批人时，就会出现两个工作流所有的审批人员，这显然是不合理的。\n2. 部分VIP工号要求既有发布权限，又有审批权限，当一个工号存在于同一审批流程中的多个角色中时，在工作流中如何确定他是发布角色，还是审批角色？下一步审批人又怎么查询呢\n3. 地市是按照工号的归属区域来区分的，并且由于还要和营销OP对接，工号的归属区域必须是唯一的，那么当同一工号要管理多个地市时，会出现不可避免的冲突；\n\n情况1相对简单，在角色设置时，不同工作流的角色应该是不同的，工号可以在不同角色中，而角色必须属于唯一的工作流，角色重叠本身是不合理的；\n\n![工作流](workflow.jpg)\n\n情况2稍微复杂些，为了解决这个情况，我们增加了一张数据关联表，用来管理角色之间的关系，以及角色和工作流的之间的关系；\n\n情况3，其实解决问题不难，只要按照不同地市来建立角色即可；但是这样的话，我们会有11个地市发布角色，11个地市审批角色，再加上另一个工作流角色不能重叠，那么我们需要配置44个角色来满足一个2级审批的简单工作流，维护成本颇高；实际使用场景中，这样情况很少，只是及其特殊的情况；用户方面也没有明确的场景支撑，只是提出这样一个想法；经过内部讨论我们决定，暂不处理这样场景，即使后续出现这样的情况，也可以通过分配多个工号处理；避免投入过多的精力去解决没有多大价值的需求点；\n\n#### 前端的设计\n\n前端跟工作流相关的有两个模块，一个是发布管理，一个是审批管理\n发布管理包含6个状态，\n1、`待审批`（完成可视化编辑，但未点击“发起审批”，此状态时仍可以修改配置信息）\n2、`审批中`（即等待审批的配置信息，提供审批提醒功能）\n3、`被打回` 审批不通过的配置信息）\n4、`审批完成`（审批通过的配置信息，运营人员可点击“发布”按钮，正式发布）\n5、`已上线`（审批通过后，在待发布列表点击发布按钮后，状态变更为已上线）\n6、`已结束`（到达活动结束时间或者手动点击“结束活动”的配置信息。此状态下提供“下线”按钮）\n\n对应在数据库的state   0：编辑完成（待审批），1：审批中，2：审批完成，-1：被打回，9：生效（已上线），-9：失效（已结束）\n\n不同的status，对应着不同的操作，这里是由前端自己来管理，如下图：\n![发布管理](issue.jpg)\n\n#### 审批管理：\n只有在状态为1（审批中）时，这条记录会出现在审批管理中；\n审批管理提供，预览、打回、通过三个状态，如下图：\n![审批管理](approval.jpg)\n\n可以看到，审批管理和发布管理涉及的可操作按钮有：`预览`，`编辑`，`发起审批`，`打回`，`通过`，`发布`，`活动下线`\n除了预览和编辑，其它操作都会改变status；\n\n预览\n---\n可视化编辑后，操作人员如何确认自己修改是否生效？审批人员依据什么来确认发布人员的操作是否正确？预览的功能必不可少；\n\n一般预览的思路是静态化后打开页面查看效果，但是本次可视化系统，编辑后并非完整的页面，只是一段代码块，那么预览就必须要依赖于前端工程；为了预览重新搭建一个前端工程显然不值得，那么灰度环境是个非常好的选择；\n\n但是前端工程是根据手机号来进行灰度的，如果发布人员和审批人员的手机号不在配置列表中，就无法访问灰度环境；\n\n因此，在灰度管理平台中增加了一个默认的号码，当cookie中存在该号码时，将被代理至灰度环境；\n\n#### 二维码\n预览链接通过二维码的方式显示出来，发布人员和审批人员只需要扫描二维码即可预览编辑后的界面；\n审批管理中的预览：\n![预览](preview.jpg)\n\n保存成功后，同样会弹出二维码，提示预览测试：\n![预览](preview2.jpg)\n\n有了预览功能，整个工作流就可以形成完整的闭环；\n![工作流](workflow.png)\n\n还有一种预览，需要依赖登录，为此前端提供输入手机号再生成二维码进行预览的方式，前端工程需要配合改造，实现免密登录的能力：\n\n![二维码](qrcode.jpg)\n\n涉及手机号等相关敏感参数的传递，需要考虑安全性：\n\n1. 二维码链接经过des加密处理，其中包含（手机号、默认渠道、以及活动ID等敏感信息）即使后台链接被泄露，也加密信息也不会轻易被修改；\n2. 灰度的cookie增加实效性（10分钟）；通常扫描二维码后，前端工程会增加灰度cookie并跳转至活动界面，10分钟后，cookie失效，刷新界面预览失效；\n\n历史版本管理\n---\n前面介绍了将可视化编辑数据按照json串的格式存储于数据库中的设计，同时我们还增加了一张历史表，当编辑结束保存时，接口层会把原来的json数据存入历史表中，然后再把编辑后的json数据update到原表中，这样，每次保存，都会记录下上一次的数据；借助历史表中的数据，我们可以轻易的获取到历史版本中改了哪些内容；\n\n![历史版本管理](history.jpg)\n\n#### 快照&版本回滚\n为了便于管理员查看，增加了\"快照\"功能，实际就是将历史表中的json数据，取出来，还原成界面；弹框展示给管理员查看，同时提供了将版本回滚的能力，便于在出现紧急情况下回退；\n\n由于历史表中也存储的是json串，借助前面开发的编辑界面组件，可以很轻易的还原出历史版本的界面\n![快照](snapshot.jpg)\n\n版本回滚同样需要经过审批流程，因为发起回滚的角色和发布角色相同，这里复用了发布流程的工作流\n\n图片资源管理\n---\n在营销活动的可视化编辑中，图片可以上传也可以选择已经上传好的，因此需要图片管理功能；\n\n图片分了几个维度：\n1、分公共图片库，以及地市图片库，地市运营人员可以使用本地市图片库，以及公共图片库；但不能使用其它地市图片库；省公司运营只维护公共图片库；\n2、按照可视化控件分类，轮播图控件，背景控件的图片功能不同在选择时不能交叉；\n3、按照图片比例管理，即使是同一种控件，有时图片尺寸比例也不相同；在选择时也需要按照比例来控制；\n\n图片资源记录表：\n```bash\n  material_id  素材ID,\n  area_code    地区编码,\n  material_url 素材路径,\n  control_id   控件ID,\n  ratio        长宽比,\n  remark1      备用字段1,\n  remark2      备用字段2,\n```\n\n图片查询接口根据图片管理的场景获取到满足要求的图片列表，并根据记录表中的素材路径展示出来；\n\n保存图片的目录结构，按照：公共库/归属地/日期/图片  的结构来存储；\n\n![图片管理](imageManage.jpg)\n\n图片服务器 & rsync\n---\n可视化编辑后台系统需要解决另一个问题是图片同步的问题；传统CMS图片需要手动执行FTP同步，并且需要指定推送目录；\n\n在这次的实践中，采用FTP并不合适，主动操作比较繁琐，并且FTP也有一定的延迟（本次项目要求保存后立刻就要预览）；因此我们选择使用rsync协议把上传的图片同步至图片服务器中；\n\n#### rsync的特性\n\n1. 可以镜像保存整个目录树和文件系统。\n2. 可以很容易做到保持原来文件的权限、时间、软硬链接等等。\n3. 无须特殊权限即可安装。\n4. 快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync在传输数据的过程中可以实行压缩及解压缩操作，因此可以使用更少的带宽。\n5. 安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。\n6. 支持匿名传输，以方便进行网站镜象\n\n静态化&FTP推送 \n---\n静态化前面说过了，后端直接从数据库中取出前端编辑好的代码片段，静态化成html文件，然后通过ftp主动推送到前台工程中使用：\n\n完整的流程如下：\n![操作流程](flow.jpg)\n\n总结\n---\n1. 采用json+html代码段的存储结构，将可视化编辑与后台数据实现解耦，大大简化了后台的开发；\n2. 接入工作流系统，完善审批流程，简化了上线流程；\n3. 借助灰度发布，实现实时预览，解决了上线可靠性问题；\n4. 实现历史版本快照和回退功能，完善了紧急情况的处理方案；\n5. 引入图片服务器，解决了图片管理的问题；\n6. rsync同步工具，解决FTP推送延迟问题；\n7. 还有上一篇介绍的后台系统的权限管理；","source":"_posts/可视化编辑系统实践.md","raw":"---\ntitle: 可视化编辑系统实践\ndate: 2018-05-29 18:42:19\ntags:\n---\n这篇我想写写可视化编辑系统的实践，重点在数据模型，静态化，工作流，预览等一系列系统功能的实践上，具体的可视化编辑功能，将另开一贴来介绍；\n\n背景\n---\n前端工程中，有一些页面涉及运营位，根据市场的变化以及运营的要求，需要频繁的更迭，开发人员需要频繁的修改上线；由于生产环境的安全限制，手动上线费时费力，还需要走更多的流程（打申请，写文档，等审批），占用了大量的时间确不能产生多少价值；\n\nCMS\n---\n传统的解决方案就是采用内容管理平台，运营人员通过CMS来修改，发布内容，包括文字，图片，表格等等一切想要发布的信息；CMS系统把数据和模板结合起来，静态化生成HTML页面或代码块，通过ftp协议上传到前端应用中，供项目使用；\n\nCMS解决了2个问题：\n1、没有技术门槛，运营人员可通过界面操作来修改运营位内容；\n2、不需要手动上线，ftp一键上传；也省去了复杂的上线流程；\n\n使用CMS系统，解放了开发人员一部分时间，迭代效率提升不少；\n\nCMS系统已经向前迈了一大步，但仍存在不少问题：\n1. 比较笨重，有一定的门槛，需要有一个熟练的操作人员；\n2. CMS一般有复杂的数据结构，需要把每一个图片，文字都对应到一个数据库字段中；维护相对困难；\n3. 有一些抽象概念（栏目、内容...）；推广困难（用户有意向主动使用，但培训了多次，效果不佳，一直没有交出去）\n4. 模板复用率低，一旦有结构型的变化，需要开发人员修改模板；\n\n设计思路\n---\n最初的想法是复用CMS的数据结构，静态化的部分也可以复用；但这么做需要先把CMS的数据模型梳理出来，并且CMS本身不是前后端分离的架构，接口层需要重新开发；这样rest层需要针对不同的前端场景提供各种接口，多表关联的处理太多，rest层的开发将会非常复杂；还有，本次可视化的要求除了，编辑文字图片外，还要有“楼层”（首页的瀑布式结构）的处理（增加，删除，排序）甚至有“楼中楼”的情况，CMS的数据模型难以表达出楼层概念；\n\n如果把每一个页面元素都和数据库对应起来的话，整个系统会显得非常笨重，耦合度非常高，难以扩展，前端和后端的都不灵活；因此我们考虑，数据库只存储必要的信息，不记录所有的前端元素，只记录编辑完成的结果；\n\n前端编辑过程不和后端交互，编辑结束后，将最终的html代码段存储在数据库中，后端根据代码段来静态化生成页面，这样编辑的过程完全有前端工程去处理，这样更灵活也更轻量；\n\n但是这样做有一个难点：当下一次来编辑时，需要依据html代码块还原成可编辑的模板；之前保存在数据库中的是html代码的字符串，要把它还原成可编辑的模板，非常麻烦；\n\n为此，我们将可编辑的数据以一个json对象的形式存储在数据库中，下一次编辑时，前端通过json数据，结合VUE组件，渲染出可编辑界面；\n\n#### 具体的过程如下：\n1. 管理员访问后台编辑系统时，首先从数据库中查询出默认的json串，这个json串是初始化系统时录入的；前端根据json串，还原出可编辑界面；\n2. 管理员操作可编辑界面，前端记录修改，在保存时，把json串和html代码块一起存储在数据库中；\n3. 后端根据html代码块生成页面，并推送到前端工程使用；\n4. 管理员再次访问后台系统时，可根据json串，结合封装好的vue组件，把可编辑界面还原出来；（这个组件还用来实现了历史版本快照的功能）\n\n除了记录一些页面的固有信息，只存储json数据和html代码块，json用作还原可视化编辑界面，html代码块用来静态化生成页面；\n\n#### 数据模型：\n```bash\n  id    主键  ,\n  name   生成页名称  ,\n  area_code    地市  ,\n  type   类型 1:首页 2:地市专项  ,\n  json   json数据  ,\n  code   html代码块  ,\n  create_time   创建时间  ,\n  update_time   更新时间  ,\n  update_login_no   更新操作工号  ,\n  status   状态(0：编辑完成，1：审批中，2：审批完成，-1：被打回，9：生效，-9：失效)  ,\n  channels   发布渠道  ,\n  access_url 静态化页面路径,\n  remark1   备用字段1  ,\n  remark2   备用字段2  ,\n```\n\n工作流\n---\n根据用户的要求，可视化操作需要有审批流程，具体的审批流程是：\n1、地市发布人员--地市审批人员--省公司审批人员\n2、省公司发布人员--省公司审批人员\n并且，不同地市间，审批人员和发布人员不能交叉：\n![审批关系图](approvalProcess.jpg)\n\n工作流系统采用，Activity工作流系统\n\n流程相对简单，只有2级审批：\n\n1. 工作流角色定义四个角色，地市发布人员，地市审批人员，省公司审批人员和省公司审批人员；不同地市按照工号的归属地区来判定；这样，不同地市运营人员虽然同属一个角色，但依然可以做到审批流程不交叉；\n2. 工作流流转采用指定下一步审批人的方式，找到当前工号的角色在工作流中下一步角色的工号列表；\n3. 审批结束后，由最初的编辑人员执行发布；打回操作同样是直接打回到最初的发布人员；\n\n在实际对接工作流时，比预期要复杂，出现了各种问题：\n\n1. 实际场景中，还有另一个工作流（首页发布），只是完成地市发布，地市审批这样一个非常简单的工作流；但是这两个工作流对应的角色是重叠的，但是工号却不是，那么当选择下一步审批人时，就会出现两个工作流所有的审批人员，这显然是不合理的。\n2. 部分VIP工号要求既有发布权限，又有审批权限，当一个工号存在于同一审批流程中的多个角色中时，在工作流中如何确定他是发布角色，还是审批角色？下一步审批人又怎么查询呢\n3. 地市是按照工号的归属区域来区分的，并且由于还要和营销OP对接，工号的归属区域必须是唯一的，那么当同一工号要管理多个地市时，会出现不可避免的冲突；\n\n情况1相对简单，在角色设置时，不同工作流的角色应该是不同的，工号可以在不同角色中，而角色必须属于唯一的工作流，角色重叠本身是不合理的；\n\n![工作流](workflow.jpg)\n\n情况2稍微复杂些，为了解决这个情况，我们增加了一张数据关联表，用来管理角色之间的关系，以及角色和工作流的之间的关系；\n\n情况3，其实解决问题不难，只要按照不同地市来建立角色即可；但是这样的话，我们会有11个地市发布角色，11个地市审批角色，再加上另一个工作流角色不能重叠，那么我们需要配置44个角色来满足一个2级审批的简单工作流，维护成本颇高；实际使用场景中，这样情况很少，只是及其特殊的情况；用户方面也没有明确的场景支撑，只是提出这样一个想法；经过内部讨论我们决定，暂不处理这样场景，即使后续出现这样的情况，也可以通过分配多个工号处理；避免投入过多的精力去解决没有多大价值的需求点；\n\n#### 前端的设计\n\n前端跟工作流相关的有两个模块，一个是发布管理，一个是审批管理\n发布管理包含6个状态，\n1、`待审批`（完成可视化编辑，但未点击“发起审批”，此状态时仍可以修改配置信息）\n2、`审批中`（即等待审批的配置信息，提供审批提醒功能）\n3、`被打回` 审批不通过的配置信息）\n4、`审批完成`（审批通过的配置信息，运营人员可点击“发布”按钮，正式发布）\n5、`已上线`（审批通过后，在待发布列表点击发布按钮后，状态变更为已上线）\n6、`已结束`（到达活动结束时间或者手动点击“结束活动”的配置信息。此状态下提供“下线”按钮）\n\n对应在数据库的state   0：编辑完成（待审批），1：审批中，2：审批完成，-1：被打回，9：生效（已上线），-9：失效（已结束）\n\n不同的status，对应着不同的操作，这里是由前端自己来管理，如下图：\n![发布管理](issue.jpg)\n\n#### 审批管理：\n只有在状态为1（审批中）时，这条记录会出现在审批管理中；\n审批管理提供，预览、打回、通过三个状态，如下图：\n![审批管理](approval.jpg)\n\n可以看到，审批管理和发布管理涉及的可操作按钮有：`预览`，`编辑`，`发起审批`，`打回`，`通过`，`发布`，`活动下线`\n除了预览和编辑，其它操作都会改变status；\n\n预览\n---\n可视化编辑后，操作人员如何确认自己修改是否生效？审批人员依据什么来确认发布人员的操作是否正确？预览的功能必不可少；\n\n一般预览的思路是静态化后打开页面查看效果，但是本次可视化系统，编辑后并非完整的页面，只是一段代码块，那么预览就必须要依赖于前端工程；为了预览重新搭建一个前端工程显然不值得，那么灰度环境是个非常好的选择；\n\n但是前端工程是根据手机号来进行灰度的，如果发布人员和审批人员的手机号不在配置列表中，就无法访问灰度环境；\n\n因此，在灰度管理平台中增加了一个默认的号码，当cookie中存在该号码时，将被代理至灰度环境；\n\n#### 二维码\n预览链接通过二维码的方式显示出来，发布人员和审批人员只需要扫描二维码即可预览编辑后的界面；\n审批管理中的预览：\n![预览](preview.jpg)\n\n保存成功后，同样会弹出二维码，提示预览测试：\n![预览](preview2.jpg)\n\n有了预览功能，整个工作流就可以形成完整的闭环；\n![工作流](workflow.png)\n\n还有一种预览，需要依赖登录，为此前端提供输入手机号再生成二维码进行预览的方式，前端工程需要配合改造，实现免密登录的能力：\n\n![二维码](qrcode.jpg)\n\n涉及手机号等相关敏感参数的传递，需要考虑安全性：\n\n1. 二维码链接经过des加密处理，其中包含（手机号、默认渠道、以及活动ID等敏感信息）即使后台链接被泄露，也加密信息也不会轻易被修改；\n2. 灰度的cookie增加实效性（10分钟）；通常扫描二维码后，前端工程会增加灰度cookie并跳转至活动界面，10分钟后，cookie失效，刷新界面预览失效；\n\n历史版本管理\n---\n前面介绍了将可视化编辑数据按照json串的格式存储于数据库中的设计，同时我们还增加了一张历史表，当编辑结束保存时，接口层会把原来的json数据存入历史表中，然后再把编辑后的json数据update到原表中，这样，每次保存，都会记录下上一次的数据；借助历史表中的数据，我们可以轻易的获取到历史版本中改了哪些内容；\n\n![历史版本管理](history.jpg)\n\n#### 快照&版本回滚\n为了便于管理员查看，增加了\"快照\"功能，实际就是将历史表中的json数据，取出来，还原成界面；弹框展示给管理员查看，同时提供了将版本回滚的能力，便于在出现紧急情况下回退；\n\n由于历史表中也存储的是json串，借助前面开发的编辑界面组件，可以很轻易的还原出历史版本的界面\n![快照](snapshot.jpg)\n\n版本回滚同样需要经过审批流程，因为发起回滚的角色和发布角色相同，这里复用了发布流程的工作流\n\n图片资源管理\n---\n在营销活动的可视化编辑中，图片可以上传也可以选择已经上传好的，因此需要图片管理功能；\n\n图片分了几个维度：\n1、分公共图片库，以及地市图片库，地市运营人员可以使用本地市图片库，以及公共图片库；但不能使用其它地市图片库；省公司运营只维护公共图片库；\n2、按照可视化控件分类，轮播图控件，背景控件的图片功能不同在选择时不能交叉；\n3、按照图片比例管理，即使是同一种控件，有时图片尺寸比例也不相同；在选择时也需要按照比例来控制；\n\n图片资源记录表：\n```bash\n  material_id  素材ID,\n  area_code    地区编码,\n  material_url 素材路径,\n  control_id   控件ID,\n  ratio        长宽比,\n  remark1      备用字段1,\n  remark2      备用字段2,\n```\n\n图片查询接口根据图片管理的场景获取到满足要求的图片列表，并根据记录表中的素材路径展示出来；\n\n保存图片的目录结构，按照：公共库/归属地/日期/图片  的结构来存储；\n\n![图片管理](imageManage.jpg)\n\n图片服务器 & rsync\n---\n可视化编辑后台系统需要解决另一个问题是图片同步的问题；传统CMS图片需要手动执行FTP同步，并且需要指定推送目录；\n\n在这次的实践中，采用FTP并不合适，主动操作比较繁琐，并且FTP也有一定的延迟（本次项目要求保存后立刻就要预览）；因此我们选择使用rsync协议把上传的图片同步至图片服务器中；\n\n#### rsync的特性\n\n1. 可以镜像保存整个目录树和文件系统。\n2. 可以很容易做到保持原来文件的权限、时间、软硬链接等等。\n3. 无须特殊权限即可安装。\n4. 快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync在传输数据的过程中可以实行压缩及解压缩操作，因此可以使用更少的带宽。\n5. 安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。\n6. 支持匿名传输，以方便进行网站镜象\n\n静态化&FTP推送 \n---\n静态化前面说过了，后端直接从数据库中取出前端编辑好的代码片段，静态化成html文件，然后通过ftp主动推送到前台工程中使用：\n\n完整的流程如下：\n![操作流程](flow.jpg)\n\n总结\n---\n1. 采用json+html代码段的存储结构，将可视化编辑与后台数据实现解耦，大大简化了后台的开发；\n2. 接入工作流系统，完善审批流程，简化了上线流程；\n3. 借助灰度发布，实现实时预览，解决了上线可靠性问题；\n4. 实现历史版本快照和回退功能，完善了紧急情况的处理方案；\n5. 引入图片服务器，解决了图片管理的问题；\n6. rsync同步工具，解决FTP推送延迟问题；\n7. 还有上一篇介绍的后台系统的权限管理；","slug":"可视化编辑系统实践","published":1,"updated":"2018-06-20T09:26:35.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11ww000a2om25aatb4hk","content":"<p>这篇我想写写可视化编辑系统的实践，重点在数据模型，静态化，工作流，预览等一系列系统功能的实践上，具体的可视化编辑功能，将另开一贴来介绍；</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前端工程中，有一些页面涉及运营位，根据市场的变化以及运营的要求，需要频繁的更迭，开发人员需要频繁的修改上线；由于生产环境的安全限制，手动上线费时费力，还需要走更多的流程（打申请，写文档，等审批），占用了大量的时间确不能产生多少价值；</p>\n<h2 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h2><p>传统的解决方案就是采用内容管理平台，运营人员通过CMS来修改，发布内容，包括文字，图片，表格等等一切想要发布的信息；CMS系统把数据和模板结合起来，静态化生成HTML页面或代码块，通过ftp协议上传到前端应用中，供项目使用；</p>\n<p>CMS解决了2个问题：<br>1、没有技术门槛，运营人员可通过界面操作来修改运营位内容；<br>2、不需要手动上线，ftp一键上传；也省去了复杂的上线流程；</p>\n<p>使用CMS系统，解放了开发人员一部分时间，迭代效率提升不少；</p>\n<p>CMS系统已经向前迈了一大步，但仍存在不少问题：</p>\n<ol>\n<li>比较笨重，有一定的门槛，需要有一个熟练的操作人员；</li>\n<li>CMS一般有复杂的数据结构，需要把每一个图片，文字都对应到一个数据库字段中；维护相对困难；</li>\n<li>有一些抽象概念（栏目、内容…）；推广困难（用户有意向主动使用，但培训了多次，效果不佳，一直没有交出去）</li>\n<li>模板复用率低，一旦有结构型的变化，需要开发人员修改模板；</li>\n</ol>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><p>最初的想法是复用CMS的数据结构，静态化的部分也可以复用；但这么做需要先把CMS的数据模型梳理出来，并且CMS本身不是前后端分离的架构，接口层需要重新开发；这样rest层需要针对不同的前端场景提供各种接口，多表关联的处理太多，rest层的开发将会非常复杂；还有，本次可视化的要求除了，编辑文字图片外，还要有“楼层”（首页的瀑布式结构）的处理（增加，删除，排序）甚至有“楼中楼”的情况，CMS的数据模型难以表达出楼层概念；</p>\n<p>如果把每一个页面元素都和数据库对应起来的话，整个系统会显得非常笨重，耦合度非常高，难以扩展，前端和后端的都不灵活；因此我们考虑，数据库只存储必要的信息，不记录所有的前端元素，只记录编辑完成的结果；</p>\n<p>前端编辑过程不和后端交互，编辑结束后，将最终的html代码段存储在数据库中，后端根据代码段来静态化生成页面，这样编辑的过程完全有前端工程去处理，这样更灵活也更轻量；</p>\n<p>但是这样做有一个难点：当下一次来编辑时，需要依据html代码块还原成可编辑的模板；之前保存在数据库中的是html代码的字符串，要把它还原成可编辑的模板，非常麻烦；</p>\n<p>为此，我们将可编辑的数据以一个json对象的形式存储在数据库中，下一次编辑时，前端通过json数据，结合VUE组件，渲染出可编辑界面；</p>\n<h4 id=\"具体的过程如下：\"><a href=\"#具体的过程如下：\" class=\"headerlink\" title=\"具体的过程如下：\"></a>具体的过程如下：</h4><ol>\n<li>管理员访问后台编辑系统时，首先从数据库中查询出默认的json串，这个json串是初始化系统时录入的；前端根据json串，还原出可编辑界面；</li>\n<li>管理员操作可编辑界面，前端记录修改，在保存时，把json串和html代码块一起存储在数据库中；</li>\n<li>后端根据html代码块生成页面，并推送到前端工程使用；</li>\n<li>管理员再次访问后台系统时，可根据json串，结合封装好的vue组件，把可编辑界面还原出来；（这个组件还用来实现了历史版本快照的功能）</li>\n</ol>\n<p>除了记录一些页面的固有信息，只存储json数据和html代码块，json用作还原可视化编辑界面，html代码块用来静态化生成页面；</p>\n<h4 id=\"数据模型：\"><a href=\"#数据模型：\" class=\"headerlink\" title=\"数据模型：\"></a>数据模型：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id    主键  ,</span><br><span class=\"line\">name   生成页名称  ,</span><br><span class=\"line\">area_code    地市  ,</span><br><span class=\"line\"><span class=\"built_in\">type</span>   类型 1:首页 2:地市专项  ,</span><br><span class=\"line\">json   json数据  ,</span><br><span class=\"line\">code   html代码块  ,</span><br><span class=\"line\">create_time   创建时间  ,</span><br><span class=\"line\">update_time   更新时间  ,</span><br><span class=\"line\">update_login_no   更新操作工号  ,</span><br><span class=\"line\">status   状态(0：编辑完成，1：审批中，2：审批完成，-1：被打回，9：生效，-9：失效)  ,</span><br><span class=\"line\">channels   发布渠道  ,</span><br><span class=\"line\">access_url 静态化页面路径,</span><br><span class=\"line\">remark1   备用字段1  ,</span><br><span class=\"line\">remark2   备用字段2  ,</span><br></pre></td></tr></table></figure>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2><p>根据用户的要求，可视化操作需要有审批流程，具体的审批流程是：<br>1、地市发布人员–地市审批人员–省公司审批人员<br>2、省公司发布人员–省公司审批人员<br>并且，不同地市间，审批人员和发布人员不能交叉：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/approvalProcess.jpg\" alt=\"审批关系图\"></p>\n<p>工作流系统采用，Activity工作流系统</p>\n<p>流程相对简单，只有2级审批：</p>\n<ol>\n<li>工作流角色定义四个角色，地市发布人员，地市审批人员，省公司审批人员和省公司审批人员；不同地市按照工号的归属地区来判定；这样，不同地市运营人员虽然同属一个角色，但依然可以做到审批流程不交叉；</li>\n<li>工作流流转采用指定下一步审批人的方式，找到当前工号的角色在工作流中下一步角色的工号列表；</li>\n<li>审批结束后，由最初的编辑人员执行发布；打回操作同样是直接打回到最初的发布人员；</li>\n</ol>\n<p>在实际对接工作流时，比预期要复杂，出现了各种问题：</p>\n<ol>\n<li>实际场景中，还有另一个工作流（首页发布），只是完成地市发布，地市审批这样一个非常简单的工作流；但是这两个工作流对应的角色是重叠的，但是工号却不是，那么当选择下一步审批人时，就会出现两个工作流所有的审批人员，这显然是不合理的。</li>\n<li>部分VIP工号要求既有发布权限，又有审批权限，当一个工号存在于同一审批流程中的多个角色中时，在工作流中如何确定他是发布角色，还是审批角色？下一步审批人又怎么查询呢</li>\n<li>地市是按照工号的归属区域来区分的，并且由于还要和营销OP对接，工号的归属区域必须是唯一的，那么当同一工号要管理多个地市时，会出现不可避免的冲突；</li>\n</ol>\n<p>情况1相对简单，在角色设置时，不同工作流的角色应该是不同的，工号可以在不同角色中，而角色必须属于唯一的工作流，角色重叠本身是不合理的；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/workflow.jpg\" alt=\"工作流\"></p>\n<p>情况2稍微复杂些，为了解决这个情况，我们增加了一张数据关联表，用来管理角色之间的关系，以及角色和工作流的之间的关系；</p>\n<p>情况3，其实解决问题不难，只要按照不同地市来建立角色即可；但是这样的话，我们会有11个地市发布角色，11个地市审批角色，再加上另一个工作流角色不能重叠，那么我们需要配置44个角色来满足一个2级审批的简单工作流，维护成本颇高；实际使用场景中，这样情况很少，只是及其特殊的情况；用户方面也没有明确的场景支撑，只是提出这样一个想法；经过内部讨论我们决定，暂不处理这样场景，即使后续出现这样的情况，也可以通过分配多个工号处理；避免投入过多的精力去解决没有多大价值的需求点；</p>\n<h4 id=\"前端的设计\"><a href=\"#前端的设计\" class=\"headerlink\" title=\"前端的设计\"></a>前端的设计</h4><p>前端跟工作流相关的有两个模块，一个是发布管理，一个是审批管理<br>发布管理包含6个状态，<br>1、<code>待审批</code>（完成可视化编辑，但未点击“发起审批”，此状态时仍可以修改配置信息）<br>2、<code>审批中</code>（即等待审批的配置信息，提供审批提醒功能）<br>3、<code>被打回</code> 审批不通过的配置信息）<br>4、<code>审批完成</code>（审批通过的配置信息，运营人员可点击“发布”按钮，正式发布）<br>5、<code>已上线</code>（审批通过后，在待发布列表点击发布按钮后，状态变更为已上线）<br>6、<code>已结束</code>（到达活动结束时间或者手动点击“结束活动”的配置信息。此状态下提供“下线”按钮）</p>\n<p>对应在数据库的state   0：编辑完成（待审批），1：审批中，2：审批完成，-1：被打回，9：生效（已上线），-9：失效（已结束）</p>\n<p>不同的status，对应着不同的操作，这里是由前端自己来管理，如下图：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/issue.jpg\" alt=\"发布管理\"></p>\n<h4 id=\"审批管理：\"><a href=\"#审批管理：\" class=\"headerlink\" title=\"审批管理：\"></a>审批管理：</h4><p>只有在状态为1（审批中）时，这条记录会出现在审批管理中；<br>审批管理提供，预览、打回、通过三个状态，如下图：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/approval.jpg\" alt=\"审批管理\"></p>\n<p>可以看到，审批管理和发布管理涉及的可操作按钮有：<code>预览</code>，<code>编辑</code>，<code>发起审批</code>，<code>打回</code>，<code>通过</code>，<code>发布</code>，<code>活动下线</code><br>除了预览和编辑，其它操作都会改变status；</p>\n<h2 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h2><p>可视化编辑后，操作人员如何确认自己修改是否生效？审批人员依据什么来确认发布人员的操作是否正确？预览的功能必不可少；</p>\n<p>一般预览的思路是静态化后打开页面查看效果，但是本次可视化系统，编辑后并非完整的页面，只是一段代码块，那么预览就必须要依赖于前端工程；为了预览重新搭建一个前端工程显然不值得，那么灰度环境是个非常好的选择；</p>\n<p>但是前端工程是根据手机号来进行灰度的，如果发布人员和审批人员的手机号不在配置列表中，就无法访问灰度环境；</p>\n<p>因此，在灰度管理平台中增加了一个默认的号码，当cookie中存在该号码时，将被代理至灰度环境；</p>\n<h4 id=\"二维码\"><a href=\"#二维码\" class=\"headerlink\" title=\"二维码\"></a>二维码</h4><p>预览链接通过二维码的方式显示出来，发布人员和审批人员只需要扫描二维码即可预览编辑后的界面；<br>审批管理中的预览：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/preview.jpg\" alt=\"预览\"></p>\n<p>保存成功后，同样会弹出二维码，提示预览测试：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/preview2.jpg\" alt=\"预览\"></p>\n<p>有了预览功能，整个工作流就可以形成完整的闭环；<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/workflow.png\" alt=\"工作流\"></p>\n<p>还有一种预览，需要依赖登录，为此前端提供输入手机号再生成二维码进行预览的方式，前端工程需要配合改造，实现免密登录的能力：</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/qrcode.jpg\" alt=\"二维码\"></p>\n<p>涉及手机号等相关敏感参数的传递，需要考虑安全性：</p>\n<ol>\n<li>二维码链接经过des加密处理，其中包含（手机号、默认渠道、以及活动ID等敏感信息）即使后台链接被泄露，也加密信息也不会轻易被修改；</li>\n<li>灰度的cookie增加实效性（10分钟）；通常扫描二维码后，前端工程会增加灰度cookie并跳转至活动界面，10分钟后，cookie失效，刷新界面预览失效；</li>\n</ol>\n<h2 id=\"历史版本管理\"><a href=\"#历史版本管理\" class=\"headerlink\" title=\"历史版本管理\"></a>历史版本管理</h2><p>前面介绍了将可视化编辑数据按照json串的格式存储于数据库中的设计，同时我们还增加了一张历史表，当编辑结束保存时，接口层会把原来的json数据存入历史表中，然后再把编辑后的json数据update到原表中，这样，每次保存，都会记录下上一次的数据；借助历史表中的数据，我们可以轻易的获取到历史版本中改了哪些内容；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/history.jpg\" alt=\"历史版本管理\"></p>\n<h4 id=\"快照-amp-版本回滚\"><a href=\"#快照-amp-版本回滚\" class=\"headerlink\" title=\"快照&amp;版本回滚\"></a>快照&amp;版本回滚</h4><p>为了便于管理员查看，增加了”快照”功能，实际就是将历史表中的json数据，取出来，还原成界面；弹框展示给管理员查看，同时提供了将版本回滚的能力，便于在出现紧急情况下回退；</p>\n<p>由于历史表中也存储的是json串，借助前面开发的编辑界面组件，可以很轻易的还原出历史版本的界面<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/snapshot.jpg\" alt=\"快照\"></p>\n<p>版本回滚同样需要经过审批流程，因为发起回滚的角色和发布角色相同，这里复用了发布流程的工作流</p>\n<h2 id=\"图片资源管理\"><a href=\"#图片资源管理\" class=\"headerlink\" title=\"图片资源管理\"></a>图片资源管理</h2><p>在营销活动的可视化编辑中，图片可以上传也可以选择已经上传好的，因此需要图片管理功能；</p>\n<p>图片分了几个维度：<br>1、分公共图片库，以及地市图片库，地市运营人员可以使用本地市图片库，以及公共图片库；但不能使用其它地市图片库；省公司运营只维护公共图片库；<br>2、按照可视化控件分类，轮播图控件，背景控件的图片功能不同在选择时不能交叉；<br>3、按照图片比例管理，即使是同一种控件，有时图片尺寸比例也不相同；在选择时也需要按照比例来控制；</p>\n<p>图片资源记录表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">material_id  素材ID,</span><br><span class=\"line\">area_code    地区编码,</span><br><span class=\"line\">material_url 素材路径,</span><br><span class=\"line\">control_id   控件ID,</span><br><span class=\"line\">ratio        长宽比,</span><br><span class=\"line\">remark1      备用字段1,</span><br><span class=\"line\">remark2      备用字段2,</span><br></pre></td></tr></table></figure></p>\n<p>图片查询接口根据图片管理的场景获取到满足要求的图片列表，并根据记录表中的素材路径展示出来；</p>\n<p>保存图片的目录结构，按照：公共库/归属地/日期/图片  的结构来存储；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/imageManage.jpg\" alt=\"图片管理\"></p>\n<h2 id=\"图片服务器-amp-rsync\"><a href=\"#图片服务器-amp-rsync\" class=\"headerlink\" title=\"图片服务器 &amp; rsync\"></a>图片服务器 &amp; rsync</h2><p>可视化编辑后台系统需要解决另一个问题是图片同步的问题；传统CMS图片需要手动执行FTP同步，并且需要指定推送目录；</p>\n<p>在这次的实践中，采用FTP并不合适，主动操作比较繁琐，并且FTP也有一定的延迟（本次项目要求保存后立刻就要预览）；因此我们选择使用rsync协议把上传的图片同步至图片服务器中；</p>\n<h4 id=\"rsync的特性\"><a href=\"#rsync的特性\" class=\"headerlink\" title=\"rsync的特性\"></a>rsync的特性</h4><ol>\n<li>可以镜像保存整个目录树和文件系统。</li>\n<li>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</li>\n<li>无须特殊权限即可安装。</li>\n<li>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync在传输数据的过程中可以实行压缩及解压缩操作，因此可以使用更少的带宽。</li>\n<li>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</li>\n<li>支持匿名传输，以方便进行网站镜象</li>\n</ol>\n<h2 id=\"静态化-amp-FTP推送\"><a href=\"#静态化-amp-FTP推送\" class=\"headerlink\" title=\"静态化&amp;FTP推送 \"></a>静态化&amp;FTP推送 </h2><p>静态化前面说过了，后端直接从数据库中取出前端编辑好的代码片段，静态化成html文件，然后通过ftp主动推送到前台工程中使用：</p>\n<p>完整的流程如下：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/flow.jpg\" alt=\"操作流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>采用json+html代码段的存储结构，将可视化编辑与后台数据实现解耦，大大简化了后台的开发；</li>\n<li>接入工作流系统，完善审批流程，简化了上线流程；</li>\n<li>借助灰度发布，实现实时预览，解决了上线可靠性问题；</li>\n<li>实现历史版本快照和回退功能，完善了紧急情况的处理方案；</li>\n<li>引入图片服务器，解决了图片管理的问题；</li>\n<li>rsync同步工具，解决FTP推送延迟问题；</li>\n<li>还有上一篇介绍的后台系统的权限管理；</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇我想写写可视化编辑系统的实践，重点在数据模型，静态化，工作流，预览等一系列系统功能的实践上，具体的可视化编辑功能，将另开一贴来介绍；</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前端工程中，有一些页面涉及运营位，根据市场的变化以及运营的要求，需要频繁的更迭，开发人员需要频繁的修改上线；由于生产环境的安全限制，手动上线费时费力，还需要走更多的流程（打申请，写文档，等审批），占用了大量的时间确不能产生多少价值；</p>\n<h2 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h2><p>传统的解决方案就是采用内容管理平台，运营人员通过CMS来修改，发布内容，包括文字，图片，表格等等一切想要发布的信息；CMS系统把数据和模板结合起来，静态化生成HTML页面或代码块，通过ftp协议上传到前端应用中，供项目使用；</p>\n<p>CMS解决了2个问题：<br>1、没有技术门槛，运营人员可通过界面操作来修改运营位内容；<br>2、不需要手动上线，ftp一键上传；也省去了复杂的上线流程；</p>\n<p>使用CMS系统，解放了开发人员一部分时间，迭代效率提升不少；</p>\n<p>CMS系统已经向前迈了一大步，但仍存在不少问题：</p>\n<ol>\n<li>比较笨重，有一定的门槛，需要有一个熟练的操作人员；</li>\n<li>CMS一般有复杂的数据结构，需要把每一个图片，文字都对应到一个数据库字段中；维护相对困难；</li>\n<li>有一些抽象概念（栏目、内容…）；推广困难（用户有意向主动使用，但培训了多次，效果不佳，一直没有交出去）</li>\n<li>模板复用率低，一旦有结构型的变化，需要开发人员修改模板；</li>\n</ol>\n<h2 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h2><p>最初的想法是复用CMS的数据结构，静态化的部分也可以复用；但这么做需要先把CMS的数据模型梳理出来，并且CMS本身不是前后端分离的架构，接口层需要重新开发；这样rest层需要针对不同的前端场景提供各种接口，多表关联的处理太多，rest层的开发将会非常复杂；还有，本次可视化的要求除了，编辑文字图片外，还要有“楼层”（首页的瀑布式结构）的处理（增加，删除，排序）甚至有“楼中楼”的情况，CMS的数据模型难以表达出楼层概念；</p>\n<p>如果把每一个页面元素都和数据库对应起来的话，整个系统会显得非常笨重，耦合度非常高，难以扩展，前端和后端的都不灵活；因此我们考虑，数据库只存储必要的信息，不记录所有的前端元素，只记录编辑完成的结果；</p>\n<p>前端编辑过程不和后端交互，编辑结束后，将最终的html代码段存储在数据库中，后端根据代码段来静态化生成页面，这样编辑的过程完全有前端工程去处理，这样更灵活也更轻量；</p>\n<p>但是这样做有一个难点：当下一次来编辑时，需要依据html代码块还原成可编辑的模板；之前保存在数据库中的是html代码的字符串，要把它还原成可编辑的模板，非常麻烦；</p>\n<p>为此，我们将可编辑的数据以一个json对象的形式存储在数据库中，下一次编辑时，前端通过json数据，结合VUE组件，渲染出可编辑界面；</p>\n<h4 id=\"具体的过程如下：\"><a href=\"#具体的过程如下：\" class=\"headerlink\" title=\"具体的过程如下：\"></a>具体的过程如下：</h4><ol>\n<li>管理员访问后台编辑系统时，首先从数据库中查询出默认的json串，这个json串是初始化系统时录入的；前端根据json串，还原出可编辑界面；</li>\n<li>管理员操作可编辑界面，前端记录修改，在保存时，把json串和html代码块一起存储在数据库中；</li>\n<li>后端根据html代码块生成页面，并推送到前端工程使用；</li>\n<li>管理员再次访问后台系统时，可根据json串，结合封装好的vue组件，把可编辑界面还原出来；（这个组件还用来实现了历史版本快照的功能）</li>\n</ol>\n<p>除了记录一些页面的固有信息，只存储json数据和html代码块，json用作还原可视化编辑界面，html代码块用来静态化生成页面；</p>\n<h4 id=\"数据模型：\"><a href=\"#数据模型：\" class=\"headerlink\" title=\"数据模型：\"></a>数据模型：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id    主键  ,</span><br><span class=\"line\">name   生成页名称  ,</span><br><span class=\"line\">area_code    地市  ,</span><br><span class=\"line\"><span class=\"built_in\">type</span>   类型 1:首页 2:地市专项  ,</span><br><span class=\"line\">json   json数据  ,</span><br><span class=\"line\">code   html代码块  ,</span><br><span class=\"line\">create_time   创建时间  ,</span><br><span class=\"line\">update_time   更新时间  ,</span><br><span class=\"line\">update_login_no   更新操作工号  ,</span><br><span class=\"line\">status   状态(0：编辑完成，1：审批中，2：审批完成，-1：被打回，9：生效，-9：失效)  ,</span><br><span class=\"line\">channels   发布渠道  ,</span><br><span class=\"line\">access_url 静态化页面路径,</span><br><span class=\"line\">remark1   备用字段1  ,</span><br><span class=\"line\">remark2   备用字段2  ,</span><br></pre></td></tr></table></figure>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2><p>根据用户的要求，可视化操作需要有审批流程，具体的审批流程是：<br>1、地市发布人员–地市审批人员–省公司审批人员<br>2、省公司发布人员–省公司审批人员<br>并且，不同地市间，审批人员和发布人员不能交叉：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/approvalProcess.jpg\" alt=\"审批关系图\"></p>\n<p>工作流系统采用，Activity工作流系统</p>\n<p>流程相对简单，只有2级审批：</p>\n<ol>\n<li>工作流角色定义四个角色，地市发布人员，地市审批人员，省公司审批人员和省公司审批人员；不同地市按照工号的归属地区来判定；这样，不同地市运营人员虽然同属一个角色，但依然可以做到审批流程不交叉；</li>\n<li>工作流流转采用指定下一步审批人的方式，找到当前工号的角色在工作流中下一步角色的工号列表；</li>\n<li>审批结束后，由最初的编辑人员执行发布；打回操作同样是直接打回到最初的发布人员；</li>\n</ol>\n<p>在实际对接工作流时，比预期要复杂，出现了各种问题：</p>\n<ol>\n<li>实际场景中，还有另一个工作流（首页发布），只是完成地市发布，地市审批这样一个非常简单的工作流；但是这两个工作流对应的角色是重叠的，但是工号却不是，那么当选择下一步审批人时，就会出现两个工作流所有的审批人员，这显然是不合理的。</li>\n<li>部分VIP工号要求既有发布权限，又有审批权限，当一个工号存在于同一审批流程中的多个角色中时，在工作流中如何确定他是发布角色，还是审批角色？下一步审批人又怎么查询呢</li>\n<li>地市是按照工号的归属区域来区分的，并且由于还要和营销OP对接，工号的归属区域必须是唯一的，那么当同一工号要管理多个地市时，会出现不可避免的冲突；</li>\n</ol>\n<p>情况1相对简单，在角色设置时，不同工作流的角色应该是不同的，工号可以在不同角色中，而角色必须属于唯一的工作流，角色重叠本身是不合理的；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/workflow.jpg\" alt=\"工作流\"></p>\n<p>情况2稍微复杂些，为了解决这个情况，我们增加了一张数据关联表，用来管理角色之间的关系，以及角色和工作流的之间的关系；</p>\n<p>情况3，其实解决问题不难，只要按照不同地市来建立角色即可；但是这样的话，我们会有11个地市发布角色，11个地市审批角色，再加上另一个工作流角色不能重叠，那么我们需要配置44个角色来满足一个2级审批的简单工作流，维护成本颇高；实际使用场景中，这样情况很少，只是及其特殊的情况；用户方面也没有明确的场景支撑，只是提出这样一个想法；经过内部讨论我们决定，暂不处理这样场景，即使后续出现这样的情况，也可以通过分配多个工号处理；避免投入过多的精力去解决没有多大价值的需求点；</p>\n<h4 id=\"前端的设计\"><a href=\"#前端的设计\" class=\"headerlink\" title=\"前端的设计\"></a>前端的设计</h4><p>前端跟工作流相关的有两个模块，一个是发布管理，一个是审批管理<br>发布管理包含6个状态，<br>1、<code>待审批</code>（完成可视化编辑，但未点击“发起审批”，此状态时仍可以修改配置信息）<br>2、<code>审批中</code>（即等待审批的配置信息，提供审批提醒功能）<br>3、<code>被打回</code> 审批不通过的配置信息）<br>4、<code>审批完成</code>（审批通过的配置信息，运营人员可点击“发布”按钮，正式发布）<br>5、<code>已上线</code>（审批通过后，在待发布列表点击发布按钮后，状态变更为已上线）<br>6、<code>已结束</code>（到达活动结束时间或者手动点击“结束活动”的配置信息。此状态下提供“下线”按钮）</p>\n<p>对应在数据库的state   0：编辑完成（待审批），1：审批中，2：审批完成，-1：被打回，9：生效（已上线），-9：失效（已结束）</p>\n<p>不同的status，对应着不同的操作，这里是由前端自己来管理，如下图：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/issue.jpg\" alt=\"发布管理\"></p>\n<h4 id=\"审批管理：\"><a href=\"#审批管理：\" class=\"headerlink\" title=\"审批管理：\"></a>审批管理：</h4><p>只有在状态为1（审批中）时，这条记录会出现在审批管理中；<br>审批管理提供，预览、打回、通过三个状态，如下图：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/approval.jpg\" alt=\"审批管理\"></p>\n<p>可以看到，审批管理和发布管理涉及的可操作按钮有：<code>预览</code>，<code>编辑</code>，<code>发起审批</code>，<code>打回</code>，<code>通过</code>，<code>发布</code>，<code>活动下线</code><br>除了预览和编辑，其它操作都会改变status；</p>\n<h2 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h2><p>可视化编辑后，操作人员如何确认自己修改是否生效？审批人员依据什么来确认发布人员的操作是否正确？预览的功能必不可少；</p>\n<p>一般预览的思路是静态化后打开页面查看效果，但是本次可视化系统，编辑后并非完整的页面，只是一段代码块，那么预览就必须要依赖于前端工程；为了预览重新搭建一个前端工程显然不值得，那么灰度环境是个非常好的选择；</p>\n<p>但是前端工程是根据手机号来进行灰度的，如果发布人员和审批人员的手机号不在配置列表中，就无法访问灰度环境；</p>\n<p>因此，在灰度管理平台中增加了一个默认的号码，当cookie中存在该号码时，将被代理至灰度环境；</p>\n<h4 id=\"二维码\"><a href=\"#二维码\" class=\"headerlink\" title=\"二维码\"></a>二维码</h4><p>预览链接通过二维码的方式显示出来，发布人员和审批人员只需要扫描二维码即可预览编辑后的界面；<br>审批管理中的预览：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/preview.jpg\" alt=\"预览\"></p>\n<p>保存成功后，同样会弹出二维码，提示预览测试：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/preview2.jpg\" alt=\"预览\"></p>\n<p>有了预览功能，整个工作流就可以形成完整的闭环；<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/workflow.png\" alt=\"工作流\"></p>\n<p>还有一种预览，需要依赖登录，为此前端提供输入手机号再生成二维码进行预览的方式，前端工程需要配合改造，实现免密登录的能力：</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/qrcode.jpg\" alt=\"二维码\"></p>\n<p>涉及手机号等相关敏感参数的传递，需要考虑安全性：</p>\n<ol>\n<li>二维码链接经过des加密处理，其中包含（手机号、默认渠道、以及活动ID等敏感信息）即使后台链接被泄露，也加密信息也不会轻易被修改；</li>\n<li>灰度的cookie增加实效性（10分钟）；通常扫描二维码后，前端工程会增加灰度cookie并跳转至活动界面，10分钟后，cookie失效，刷新界面预览失效；</li>\n</ol>\n<h2 id=\"历史版本管理\"><a href=\"#历史版本管理\" class=\"headerlink\" title=\"历史版本管理\"></a>历史版本管理</h2><p>前面介绍了将可视化编辑数据按照json串的格式存储于数据库中的设计，同时我们还增加了一张历史表，当编辑结束保存时，接口层会把原来的json数据存入历史表中，然后再把编辑后的json数据update到原表中，这样，每次保存，都会记录下上一次的数据；借助历史表中的数据，我们可以轻易的获取到历史版本中改了哪些内容；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/history.jpg\" alt=\"历史版本管理\"></p>\n<h4 id=\"快照-amp-版本回滚\"><a href=\"#快照-amp-版本回滚\" class=\"headerlink\" title=\"快照&amp;版本回滚\"></a>快照&amp;版本回滚</h4><p>为了便于管理员查看，增加了”快照”功能，实际就是将历史表中的json数据，取出来，还原成界面；弹框展示给管理员查看，同时提供了将版本回滚的能力，便于在出现紧急情况下回退；</p>\n<p>由于历史表中也存储的是json串，借助前面开发的编辑界面组件，可以很轻易的还原出历史版本的界面<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/snapshot.jpg\" alt=\"快照\"></p>\n<p>版本回滚同样需要经过审批流程，因为发起回滚的角色和发布角色相同，这里复用了发布流程的工作流</p>\n<h2 id=\"图片资源管理\"><a href=\"#图片资源管理\" class=\"headerlink\" title=\"图片资源管理\"></a>图片资源管理</h2><p>在营销活动的可视化编辑中，图片可以上传也可以选择已经上传好的，因此需要图片管理功能；</p>\n<p>图片分了几个维度：<br>1、分公共图片库，以及地市图片库，地市运营人员可以使用本地市图片库，以及公共图片库；但不能使用其它地市图片库；省公司运营只维护公共图片库；<br>2、按照可视化控件分类，轮播图控件，背景控件的图片功能不同在选择时不能交叉；<br>3、按照图片比例管理，即使是同一种控件，有时图片尺寸比例也不相同；在选择时也需要按照比例来控制；</p>\n<p>图片资源记录表：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">material_id  素材ID,</span><br><span class=\"line\">area_code    地区编码,</span><br><span class=\"line\">material_url 素材路径,</span><br><span class=\"line\">control_id   控件ID,</span><br><span class=\"line\">ratio        长宽比,</span><br><span class=\"line\">remark1      备用字段1,</span><br><span class=\"line\">remark2      备用字段2,</span><br></pre></td></tr></table></figure></p>\n<p>图片查询接口根据图片管理的场景获取到满足要求的图片列表，并根据记录表中的素材路径展示出来；</p>\n<p>保存图片的目录结构，按照：公共库/归属地/日期/图片  的结构来存储；</p>\n<p><img src=\"/blog/2018/05/30/可视化编辑系统实践/imageManage.jpg\" alt=\"图片管理\"></p>\n<h2 id=\"图片服务器-amp-rsync\"><a href=\"#图片服务器-amp-rsync\" class=\"headerlink\" title=\"图片服务器 &amp; rsync\"></a>图片服务器 &amp; rsync</h2><p>可视化编辑后台系统需要解决另一个问题是图片同步的问题；传统CMS图片需要手动执行FTP同步，并且需要指定推送目录；</p>\n<p>在这次的实践中，采用FTP并不合适，主动操作比较繁琐，并且FTP也有一定的延迟（本次项目要求保存后立刻就要预览）；因此我们选择使用rsync协议把上传的图片同步至图片服务器中；</p>\n<h4 id=\"rsync的特性\"><a href=\"#rsync的特性\" class=\"headerlink\" title=\"rsync的特性\"></a>rsync的特性</h4><ol>\n<li>可以镜像保存整个目录树和文件系统。</li>\n<li>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</li>\n<li>无须特殊权限即可安装。</li>\n<li>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync在传输数据的过程中可以实行压缩及解压缩操作，因此可以使用更少的带宽。</li>\n<li>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</li>\n<li>支持匿名传输，以方便进行网站镜象</li>\n</ol>\n<h2 id=\"静态化-amp-FTP推送\"><a href=\"#静态化-amp-FTP推送\" class=\"headerlink\" title=\"静态化&amp;FTP推送 \"></a>静态化&amp;FTP推送 </h2><p>静态化前面说过了，后端直接从数据库中取出前端编辑好的代码片段，静态化成html文件，然后通过ftp主动推送到前台工程中使用：</p>\n<p>完整的流程如下：<br><img src=\"/blog/2018/05/30/可视化编辑系统实践/flow.jpg\" alt=\"操作流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>采用json+html代码段的存储结构，将可视化编辑与后台数据实现解耦，大大简化了后台的开发；</li>\n<li>接入工作流系统，完善审批流程，简化了上线流程；</li>\n<li>借助灰度发布，实现实时预览，解决了上线可靠性问题；</li>\n<li>实现历史版本快照和回退功能，完善了紧急情况的处理方案；</li>\n<li>引入图片服务器，解决了图片管理的问题；</li>\n<li>rsync同步工具，解决FTP推送延迟问题；</li>\n<li>还有上一篇介绍的后台系统的权限管理；</li>\n</ol>\n"},{"title":"前端实现表格数据导出功能","date":"2018-06-25T17:09:49.000Z","_content":"\n将表格数据导出为文档是常见的功能需求，通常是借助后端来实现这个功能；\n\n现在前端也可以直接导出文档了，CSV格式的文档；\n\nCSV格式\n---\nCSV是comma separated values的缩写，是常用的数据文档格式之一，可以用excel文档等表格处理软件打开修改，但本质上是一个纯文本文件，格式相当简单：每一行数据为行，每一列数据由分隔符隔开。\n\n先来试一下：\n在sublime中输入如下文本，保存为test.csv\n![test.csv](test.jpg)\n然后使用excel打开文档\n![excel打开](excel打开.jpg)\n果然可以!\n那么导出时，只需要把数据转为纯文本，生成文件即可；\n\n但由于CSV并未标准化，不同软件系统使用的行分隔符和列分隔符不一定相同，这为分析和转化增加了一些难度。再加上数据内容的格式（比如日期、金额等）会由不同的国家习惯和个人习惯造成不同，处理起来会有一些麻烦。\n\n换行符\n---\n上面的图可以看出：\n* CSV文件格式单元格之间是通过,隔开的\n* CSV文件格式里，换行是通过\\n实现的\n\n另外：\n* 在Windows系统中，标准模式采用的是`\\r\\n`匹配Enter键\n* 在mac系统中，用`\\r`匹配Enter键\n* 在Linux系统中，用`\\n`匹配Enter键\n\n因此，我们只要把相应的数据按照,和\\n分隔就可以了\n\njson to csv\n---\n前端的数据通常都是json格式，因此我们要做的是把json格式的数据转为csv的字符串；\n可以自己造轮子来实现，不过目前已有开源库实现了这些能力，建议直接拿来用；\njson2csv：https://github.com/zemirco/json2csv\nAPI我就不贴了，可以在github上找到；\n\n下载\n---\n下载方式根据不同浏览器提供不同方式\n##### download属性\n*chrome、firefox、safari、opera*支持a标签的download属性，可以借助此属性实现下载；\n在`<a>`标签的href属性上配置`hrefElement.href = 'data:attachment/csv;charset=UTF-8,\\ufeff'+encodeURI(content);`\n\n`\\uFEFF`是用来解决中文乱码的情况；\n\n##### ie10/11和IEEdge\nie10/11和ieEdge使用 Blob 和 msSaveBlob 以本地方式保存文件\n使用 Blob()构造函数，我们首先创建一个 Blob 对象，其参数是包含所需文件内容的数组\n`const csvData = new Blob([BOM + text], { type: 'text/csv' })`\n调用msSaveBlob下载文件\n`navigator.msSaveBlob(csvData, filename)`\n\n##### ie9之前的版本\nie9及之前的版本不支持download属性，也没有Blob对象，需要其他方式实现\n```\n  const oWin = window.top.open('about:blank', '_blank') //打开一个新标签页\n  oWin.document.charset = 'utf-8'\n  oWin.document.write(text)                        //doument中写入数据\n  oWin.document.close()                            //关闭\n  oWin.document.execCommand('SaveAs', filename)    //唤起下载窗口\n  oWin.close()                                     //关闭标签页\n```\n\n整体代码如下：\n```\ndownload (filename, text) {\n    if (has('ie') && has('ie') < 10) {\n\t  const oWin = window.top.open('about:blank', '_blank')\n\t  oWin.document.charset = 'utf-8'\n\t  oWin.document.write(text)\n\t  oWin.document.close()\n\t  oWin.document.execCommand('SaveAs', filename)\n\t  oWin.close()\n\t} else if (has('ie') === 10 || this._isIE11() || this._isEdge()) {\n\t  const BOM = '\\uFEFF'\n\t  const csvData = new Blob([BOM + text], { type: 'text/csv' })\n\t  navigator.msSaveBlob(csvData, filename)\n\t} else {\n\t  const link = document.createElement('a')\n\t  link.download = filename\n\t  link.href = this._getDownloadUrl(text)\n\t  document.body.appendChild(link)\n\t  link.click()\n\t  document.body.removeChild(link)\n\t}\n}\n```\n\n示例\n---\n下面是一个使用示例，可以看到导出csv只需要5行代码即可；\n```\nexportCsv () {\n  /* 引入json2csv */\n  const Json2csvParser = require('json2csv').Parser\n  /* 配置表头 */\n  const fields = ['太原', '大同', '阳泉', '长治', '朔州', '晋城', '晋中', '运城', '忻州', '临汾', '吕梁']\n  const json2csvParser = new Json2csvParser({ fields })\n  /* 设置数据 */\n  const csv = json2csvParser.parse(this.tableData)\n  /* 下载 */\n  ExportCsv.download('各地市专享页面活动列表.csv', csv)\n}\n```\n表格数据：\n![表格数据](table.jpg)\n点击导出：\n![导出](保存.jpg)\n打开导出文档：\n![打开excel](导出excel.jpg)","source":"_posts/前端导出csv.md","raw":"---\ntitle: 前端实现表格数据导出功能\ndate: 2018-06-25 17:09:49\ntags:\n---\n\n将表格数据导出为文档是常见的功能需求，通常是借助后端来实现这个功能；\n\n现在前端也可以直接导出文档了，CSV格式的文档；\n\nCSV格式\n---\nCSV是comma separated values的缩写，是常用的数据文档格式之一，可以用excel文档等表格处理软件打开修改，但本质上是一个纯文本文件，格式相当简单：每一行数据为行，每一列数据由分隔符隔开。\n\n先来试一下：\n在sublime中输入如下文本，保存为test.csv\n![test.csv](test.jpg)\n然后使用excel打开文档\n![excel打开](excel打开.jpg)\n果然可以!\n那么导出时，只需要把数据转为纯文本，生成文件即可；\n\n但由于CSV并未标准化，不同软件系统使用的行分隔符和列分隔符不一定相同，这为分析和转化增加了一些难度。再加上数据内容的格式（比如日期、金额等）会由不同的国家习惯和个人习惯造成不同，处理起来会有一些麻烦。\n\n换行符\n---\n上面的图可以看出：\n* CSV文件格式单元格之间是通过,隔开的\n* CSV文件格式里，换行是通过\\n实现的\n\n另外：\n* 在Windows系统中，标准模式采用的是`\\r\\n`匹配Enter键\n* 在mac系统中，用`\\r`匹配Enter键\n* 在Linux系统中，用`\\n`匹配Enter键\n\n因此，我们只要把相应的数据按照,和\\n分隔就可以了\n\njson to csv\n---\n前端的数据通常都是json格式，因此我们要做的是把json格式的数据转为csv的字符串；\n可以自己造轮子来实现，不过目前已有开源库实现了这些能力，建议直接拿来用；\njson2csv：https://github.com/zemirco/json2csv\nAPI我就不贴了，可以在github上找到；\n\n下载\n---\n下载方式根据不同浏览器提供不同方式\n##### download属性\n*chrome、firefox、safari、opera*支持a标签的download属性，可以借助此属性实现下载；\n在`<a>`标签的href属性上配置`hrefElement.href = 'data:attachment/csv;charset=UTF-8,\\ufeff'+encodeURI(content);`\n\n`\\uFEFF`是用来解决中文乱码的情况；\n\n##### ie10/11和IEEdge\nie10/11和ieEdge使用 Blob 和 msSaveBlob 以本地方式保存文件\n使用 Blob()构造函数，我们首先创建一个 Blob 对象，其参数是包含所需文件内容的数组\n`const csvData = new Blob([BOM + text], { type: 'text/csv' })`\n调用msSaveBlob下载文件\n`navigator.msSaveBlob(csvData, filename)`\n\n##### ie9之前的版本\nie9及之前的版本不支持download属性，也没有Blob对象，需要其他方式实现\n```\n  const oWin = window.top.open('about:blank', '_blank') //打开一个新标签页\n  oWin.document.charset = 'utf-8'\n  oWin.document.write(text)                        //doument中写入数据\n  oWin.document.close()                            //关闭\n  oWin.document.execCommand('SaveAs', filename)    //唤起下载窗口\n  oWin.close()                                     //关闭标签页\n```\n\n整体代码如下：\n```\ndownload (filename, text) {\n    if (has('ie') && has('ie') < 10) {\n\t  const oWin = window.top.open('about:blank', '_blank')\n\t  oWin.document.charset = 'utf-8'\n\t  oWin.document.write(text)\n\t  oWin.document.close()\n\t  oWin.document.execCommand('SaveAs', filename)\n\t  oWin.close()\n\t} else if (has('ie') === 10 || this._isIE11() || this._isEdge()) {\n\t  const BOM = '\\uFEFF'\n\t  const csvData = new Blob([BOM + text], { type: 'text/csv' })\n\t  navigator.msSaveBlob(csvData, filename)\n\t} else {\n\t  const link = document.createElement('a')\n\t  link.download = filename\n\t  link.href = this._getDownloadUrl(text)\n\t  document.body.appendChild(link)\n\t  link.click()\n\t  document.body.removeChild(link)\n\t}\n}\n```\n\n示例\n---\n下面是一个使用示例，可以看到导出csv只需要5行代码即可；\n```\nexportCsv () {\n  /* 引入json2csv */\n  const Json2csvParser = require('json2csv').Parser\n  /* 配置表头 */\n  const fields = ['太原', '大同', '阳泉', '长治', '朔州', '晋城', '晋中', '运城', '忻州', '临汾', '吕梁']\n  const json2csvParser = new Json2csvParser({ fields })\n  /* 设置数据 */\n  const csv = json2csvParser.parse(this.tableData)\n  /* 下载 */\n  ExportCsv.download('各地市专享页面活动列表.csv', csv)\n}\n```\n表格数据：\n![表格数据](table.jpg)\n点击导出：\n![导出](保存.jpg)\n打开导出文档：\n![打开excel](导出excel.jpg)","slug":"前端导出csv","published":1,"updated":"2018-06-26T07:39:08.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11wy000b2om2s0m3n0p5","content":"<p>将表格数据导出为文档是常见的功能需求，通常是借助后端来实现这个功能；</p>\n<p>现在前端也可以直接导出文档了，CSV格式的文档；</p>\n<h2 id=\"CSV格式\"><a href=\"#CSV格式\" class=\"headerlink\" title=\"CSV格式\"></a>CSV格式</h2><p>CSV是comma separated values的缩写，是常用的数据文档格式之一，可以用excel文档等表格处理软件打开修改，但本质上是一个纯文本文件，格式相当简单：每一行数据为行，每一列数据由分隔符隔开。</p>\n<p>先来试一下：<br>在sublime中输入如下文本，保存为test.csv<br><img src=\"/blog/2018/06/26/前端导出csv/test.jpg\" alt=\"test.csv\"><br>然后使用excel打开文档<br><img src=\"/blog/2018/06/26/前端导出csv/excel打开.jpg\" alt=\"excel打开\"><br>果然可以!<br>那么导出时，只需要把数据转为纯文本，生成文件即可；</p>\n<p>但由于CSV并未标准化，不同软件系统使用的行分隔符和列分隔符不一定相同，这为分析和转化增加了一些难度。再加上数据内容的格式（比如日期、金额等）会由不同的国家习惯和个人习惯造成不同，处理起来会有一些麻烦。</p>\n<h2 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\"></a>换行符</h2><p>上面的图可以看出：</p>\n<ul>\n<li>CSV文件格式单元格之间是通过,隔开的</li>\n<li>CSV文件格式里，换行是通过\\n实现的</li>\n</ul>\n<p>另外：</p>\n<ul>\n<li>在Windows系统中，标准模式采用的是<code>\\r\\n</code>匹配Enter键</li>\n<li>在mac系统中，用<code>\\r</code>匹配Enter键</li>\n<li>在Linux系统中，用<code>\\n</code>匹配Enter键</li>\n</ul>\n<p>因此，我们只要把相应的数据按照,和\\n分隔就可以了</p>\n<h2 id=\"json-to-csv\"><a href=\"#json-to-csv\" class=\"headerlink\" title=\"json to csv\"></a>json to csv</h2><p>前端的数据通常都是json格式，因此我们要做的是把json格式的数据转为csv的字符串；<br>可以自己造轮子来实现，不过目前已有开源库实现了这些能力，建议直接拿来用；<br>json2csv：<a href=\"https://github.com/zemirco/json2csv\" target=\"_blank\" rel=\"noopener\">https://github.com/zemirco/json2csv</a><br>API我就不贴了，可以在github上找到；</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>下载方式根据不同浏览器提供不同方式</p>\n<h5 id=\"download属性\"><a href=\"#download属性\" class=\"headerlink\" title=\"download属性\"></a>download属性</h5><p><em>chrome、firefox、safari、opera</em>支持a标签的download属性，可以借助此属性实现下载；<br>在<code>&lt;a&gt;</code>标签的href属性上配置<code>hrefElement.href = &#39;data:attachment/csv;charset=UTF-8,\\ufeff&#39;+encodeURI(content);</code></p>\n<p><code>\\uFEFF</code>是用来解决中文乱码的情况；</p>\n<h5 id=\"ie10-11和IEEdge\"><a href=\"#ie10-11和IEEdge\" class=\"headerlink\" title=\"ie10/11和IEEdge\"></a>ie10/11和IEEdge</h5><p>ie10/11和ieEdge使用 Blob 和 msSaveBlob 以本地方式保存文件<br>使用 Blob()构造函数，我们首先创建一个 Blob 对象，其参数是包含所需文件内容的数组<br><code>const csvData = new Blob([BOM + text], { type: &#39;text/csv&#39; })</code><br>调用msSaveBlob下载文件<br><code>navigator.msSaveBlob(csvData, filename)</code></p>\n<h5 id=\"ie9之前的版本\"><a href=\"#ie9之前的版本\" class=\"headerlink\" title=\"ie9之前的版本\"></a>ie9之前的版本</h5><p>ie9及之前的版本不支持download属性，也没有Blob对象，需要其他方式实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const oWin = window.top.open(&apos;about:blank&apos;, &apos;_blank&apos;) //打开一个新标签页</span><br><span class=\"line\">oWin.document.charset = &apos;utf-8&apos;</span><br><span class=\"line\">oWin.document.write(text)                        //doument中写入数据</span><br><span class=\"line\">oWin.document.close()                            //关闭</span><br><span class=\"line\">oWin.document.execCommand(&apos;SaveAs&apos;, filename)    //唤起下载窗口</span><br><span class=\"line\">oWin.close()                                     //关闭标签页</span><br></pre></td></tr></table></figure></p>\n<p>整体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">download (filename, text) &#123;</span><br><span class=\"line\">    if (has(&apos;ie&apos;) &amp;&amp; has(&apos;ie&apos;) &lt; 10) &#123;</span><br><span class=\"line\">\t  const oWin = window.top.open(&apos;about:blank&apos;, &apos;_blank&apos;)</span><br><span class=\"line\">\t  oWin.document.charset = &apos;utf-8&apos;</span><br><span class=\"line\">\t  oWin.document.write(text)</span><br><span class=\"line\">\t  oWin.document.close()</span><br><span class=\"line\">\t  oWin.document.execCommand(&apos;SaveAs&apos;, filename)</span><br><span class=\"line\">\t  oWin.close()</span><br><span class=\"line\">\t&#125; else if (has(&apos;ie&apos;) === 10 || this._isIE11() || this._isEdge()) &#123;</span><br><span class=\"line\">\t  const BOM = &apos;\\uFEFF&apos;</span><br><span class=\"line\">\t  const csvData = new Blob([BOM + text], &#123; type: &apos;text/csv&apos; &#125;)</span><br><span class=\"line\">\t  navigator.msSaveBlob(csvData, filename)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t  const link = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">\t  link.download = filename</span><br><span class=\"line\">\t  link.href = this._getDownloadUrl(text)</span><br><span class=\"line\">\t  document.body.appendChild(link)</span><br><span class=\"line\">\t  link.click()</span><br><span class=\"line\">\t  document.body.removeChild(link)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>下面是一个使用示例，可以看到导出csv只需要5行代码即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exportCsv () &#123;</span><br><span class=\"line\">  /* 引入json2csv */</span><br><span class=\"line\">  const Json2csvParser = require(&apos;json2csv&apos;).Parser</span><br><span class=\"line\">  /* 配置表头 */</span><br><span class=\"line\">  const fields = [&apos;太原&apos;, &apos;大同&apos;, &apos;阳泉&apos;, &apos;长治&apos;, &apos;朔州&apos;, &apos;晋城&apos;, &apos;晋中&apos;, &apos;运城&apos;, &apos;忻州&apos;, &apos;临汾&apos;, &apos;吕梁&apos;]</span><br><span class=\"line\">  const json2csvParser = new Json2csvParser(&#123; fields &#125;)</span><br><span class=\"line\">  /* 设置数据 */</span><br><span class=\"line\">  const csv = json2csvParser.parse(this.tableData)</span><br><span class=\"line\">  /* 下载 */</span><br><span class=\"line\">  ExportCsv.download(&apos;各地市专享页面活动列表.csv&apos;, csv)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>表格数据：<br><img src=\"/blog/2018/06/26/前端导出csv/table.jpg\" alt=\"表格数据\"><br>点击导出：<br><img src=\"/blog/2018/06/26/前端导出csv/保存.jpg\" alt=\"导出\"><br>打开导出文档：<br><img src=\"/blog/2018/06/26/前端导出csv/导出excel.jpg\" alt=\"打开excel\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>将表格数据导出为文档是常见的功能需求，通常是借助后端来实现这个功能；</p>\n<p>现在前端也可以直接导出文档了，CSV格式的文档；</p>\n<h2 id=\"CSV格式\"><a href=\"#CSV格式\" class=\"headerlink\" title=\"CSV格式\"></a>CSV格式</h2><p>CSV是comma separated values的缩写，是常用的数据文档格式之一，可以用excel文档等表格处理软件打开修改，但本质上是一个纯文本文件，格式相当简单：每一行数据为行，每一列数据由分隔符隔开。</p>\n<p>先来试一下：<br>在sublime中输入如下文本，保存为test.csv<br><img src=\"/blog/2018/06/26/前端导出csv/test.jpg\" alt=\"test.csv\"><br>然后使用excel打开文档<br><img src=\"/blog/2018/06/26/前端导出csv/excel打开.jpg\" alt=\"excel打开\"><br>果然可以!<br>那么导出时，只需要把数据转为纯文本，生成文件即可；</p>\n<p>但由于CSV并未标准化，不同软件系统使用的行分隔符和列分隔符不一定相同，这为分析和转化增加了一些难度。再加上数据内容的格式（比如日期、金额等）会由不同的国家习惯和个人习惯造成不同，处理起来会有一些麻烦。</p>\n<h2 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\"></a>换行符</h2><p>上面的图可以看出：</p>\n<ul>\n<li>CSV文件格式单元格之间是通过,隔开的</li>\n<li>CSV文件格式里，换行是通过\\n实现的</li>\n</ul>\n<p>另外：</p>\n<ul>\n<li>在Windows系统中，标准模式采用的是<code>\\r\\n</code>匹配Enter键</li>\n<li>在mac系统中，用<code>\\r</code>匹配Enter键</li>\n<li>在Linux系统中，用<code>\\n</code>匹配Enter键</li>\n</ul>\n<p>因此，我们只要把相应的数据按照,和\\n分隔就可以了</p>\n<h2 id=\"json-to-csv\"><a href=\"#json-to-csv\" class=\"headerlink\" title=\"json to csv\"></a>json to csv</h2><p>前端的数据通常都是json格式，因此我们要做的是把json格式的数据转为csv的字符串；<br>可以自己造轮子来实现，不过目前已有开源库实现了这些能力，建议直接拿来用；<br>json2csv：<a href=\"https://github.com/zemirco/json2csv\" target=\"_blank\" rel=\"noopener\">https://github.com/zemirco/json2csv</a><br>API我就不贴了，可以在github上找到；</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>下载方式根据不同浏览器提供不同方式</p>\n<h5 id=\"download属性\"><a href=\"#download属性\" class=\"headerlink\" title=\"download属性\"></a>download属性</h5><p><em>chrome、firefox、safari、opera</em>支持a标签的download属性，可以借助此属性实现下载；<br>在<code>&lt;a&gt;</code>标签的href属性上配置<code>hrefElement.href = &#39;data:attachment/csv;charset=UTF-8,\\ufeff&#39;+encodeURI(content);</code></p>\n<p><code>\\uFEFF</code>是用来解决中文乱码的情况；</p>\n<h5 id=\"ie10-11和IEEdge\"><a href=\"#ie10-11和IEEdge\" class=\"headerlink\" title=\"ie10/11和IEEdge\"></a>ie10/11和IEEdge</h5><p>ie10/11和ieEdge使用 Blob 和 msSaveBlob 以本地方式保存文件<br>使用 Blob()构造函数，我们首先创建一个 Blob 对象，其参数是包含所需文件内容的数组<br><code>const csvData = new Blob([BOM + text], { type: &#39;text/csv&#39; })</code><br>调用msSaveBlob下载文件<br><code>navigator.msSaveBlob(csvData, filename)</code></p>\n<h5 id=\"ie9之前的版本\"><a href=\"#ie9之前的版本\" class=\"headerlink\" title=\"ie9之前的版本\"></a>ie9之前的版本</h5><p>ie9及之前的版本不支持download属性，也没有Blob对象，需要其他方式实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const oWin = window.top.open(&apos;about:blank&apos;, &apos;_blank&apos;) //打开一个新标签页</span><br><span class=\"line\">oWin.document.charset = &apos;utf-8&apos;</span><br><span class=\"line\">oWin.document.write(text)                        //doument中写入数据</span><br><span class=\"line\">oWin.document.close()                            //关闭</span><br><span class=\"line\">oWin.document.execCommand(&apos;SaveAs&apos;, filename)    //唤起下载窗口</span><br><span class=\"line\">oWin.close()                                     //关闭标签页</span><br></pre></td></tr></table></figure></p>\n<p>整体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">download (filename, text) &#123;</span><br><span class=\"line\">    if (has(&apos;ie&apos;) &amp;&amp; has(&apos;ie&apos;) &lt; 10) &#123;</span><br><span class=\"line\">\t  const oWin = window.top.open(&apos;about:blank&apos;, &apos;_blank&apos;)</span><br><span class=\"line\">\t  oWin.document.charset = &apos;utf-8&apos;</span><br><span class=\"line\">\t  oWin.document.write(text)</span><br><span class=\"line\">\t  oWin.document.close()</span><br><span class=\"line\">\t  oWin.document.execCommand(&apos;SaveAs&apos;, filename)</span><br><span class=\"line\">\t  oWin.close()</span><br><span class=\"line\">\t&#125; else if (has(&apos;ie&apos;) === 10 || this._isIE11() || this._isEdge()) &#123;</span><br><span class=\"line\">\t  const BOM = &apos;\\uFEFF&apos;</span><br><span class=\"line\">\t  const csvData = new Blob([BOM + text], &#123; type: &apos;text/csv&apos; &#125;)</span><br><span class=\"line\">\t  navigator.msSaveBlob(csvData, filename)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t  const link = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">\t  link.download = filename</span><br><span class=\"line\">\t  link.href = this._getDownloadUrl(text)</span><br><span class=\"line\">\t  document.body.appendChild(link)</span><br><span class=\"line\">\t  link.click()</span><br><span class=\"line\">\t  document.body.removeChild(link)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>下面是一个使用示例，可以看到导出csv只需要5行代码即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exportCsv () &#123;</span><br><span class=\"line\">  /* 引入json2csv */</span><br><span class=\"line\">  const Json2csvParser = require(&apos;json2csv&apos;).Parser</span><br><span class=\"line\">  /* 配置表头 */</span><br><span class=\"line\">  const fields = [&apos;太原&apos;, &apos;大同&apos;, &apos;阳泉&apos;, &apos;长治&apos;, &apos;朔州&apos;, &apos;晋城&apos;, &apos;晋中&apos;, &apos;运城&apos;, &apos;忻州&apos;, &apos;临汾&apos;, &apos;吕梁&apos;]</span><br><span class=\"line\">  const json2csvParser = new Json2csvParser(&#123; fields &#125;)</span><br><span class=\"line\">  /* 设置数据 */</span><br><span class=\"line\">  const csv = json2csvParser.parse(this.tableData)</span><br><span class=\"line\">  /* 下载 */</span><br><span class=\"line\">  ExportCsv.download(&apos;各地市专享页面活动列表.csv&apos;, csv)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>表格数据：<br><img src=\"/blog/2018/06/26/前端导出csv/table.jpg\" alt=\"表格数据\"><br>点击导出：<br><img src=\"/blog/2018/06/26/前端导出csv/保存.jpg\" alt=\"导出\"><br>打开导出文档：<br><img src=\"/blog/2018/06/26/前端导出csv/导出excel.jpg\" alt=\"打开excel\"></p>\n"},{"title":"基于vue的埋点方案","date":"2018-05-07T08:59:01.000Z","_content":"buried-point基于vue的埋点方案\n======\n安装Install\n------\n<pre><code>npm install buried-point</code></pre>\n\n配置configuration\n-----------\n`main.js`中进行如下配置：\n<pre><code>\n  import BuriedPoint from 'buried-point'\n\n  let option = {\n    router: router,  //vue路由对象\n    domain: '127.0.0.1:18080',  //埋点服务器地址\n    path: '/nresource/dcsImg'   //埋点请求路径  `/nresource/dcsImg/dcs.log`\n  }\n  Vue.use(BuriedPoint, option)\n\n</code></pre>\n\n开始使用start\n-------------\n>1.`v-ready-stat`指令，用于采集页面加载完成时数据\n在需要采集数据的vue组件根节点上声明埋点指令`v-ready-stat`\n\n<pre><code>\n  &lt;template&gt;\n  &lt;div class=\"button-content\" v-ready-stat&gt;\n  &lt;/template&gt;\n</code></pre>\n\n>如果需要在页面加载时传递数据，`v-ready-stat`指令可以接收`json`格式的参数`{'SI.si_n':'WEB', 'SI.si_x':'002'}`\n\n<pre><code>\n  &lt;div class=\"icon-content\" v-ready-stat=\"{'SI.si_n':'xxx','SI.si_x':'009'}\"&gt;\n</code></pre>\n\n>2.`v-click-stat`指令，用于采集用户点击事件的数据\n在被点击的dom节点上声明埋点指令`v-click-stat`,数据格式`{'SI.si_n':'WEB', 'SI.si_x':'002'}`\n\n<pre><code>\n\t&lt;el-button type=\"text\" v-data-stat=\"{'SI.si_n':'WEB', 'SI.si_x':'002'}\"&gt;{{message}}&lt;/el-button&gt;\n</code></pre>\n\n>3.命令式采集业务码\n针对需要在业务逻辑中进行埋点的特殊场景，提供命令式埋点方案；\n在vue组件中需要`import`埋点插件`import bp from 'buried-Point'`,在需要埋点的位置调用埋点方法`bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')`\n\n<pre><code>\nimport bp from 'buried-Point'\nexport default {\n  //在vue组件的生命周期钩子mounted阶段，进行埋点\n  mounted() {\n    bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')\n  }\n}\n</code></pre>\n\n","source":"_posts/基于vue的埋点方案.md","raw":"---\ntitle: '基于vue的埋点方案'\ndate: 2018-05-07 08:59:01\ntags:\n---\nburied-point基于vue的埋点方案\n======\n安装Install\n------\n<pre><code>npm install buried-point</code></pre>\n\n配置configuration\n-----------\n`main.js`中进行如下配置：\n<pre><code>\n  import BuriedPoint from 'buried-point'\n\n  let option = {\n    router: router,  //vue路由对象\n    domain: '127.0.0.1:18080',  //埋点服务器地址\n    path: '/nresource/dcsImg'   //埋点请求路径  `/nresource/dcsImg/dcs.log`\n  }\n  Vue.use(BuriedPoint, option)\n\n</code></pre>\n\n开始使用start\n-------------\n>1.`v-ready-stat`指令，用于采集页面加载完成时数据\n在需要采集数据的vue组件根节点上声明埋点指令`v-ready-stat`\n\n<pre><code>\n  &lt;template&gt;\n  &lt;div class=\"button-content\" v-ready-stat&gt;\n  &lt;/template&gt;\n</code></pre>\n\n>如果需要在页面加载时传递数据，`v-ready-stat`指令可以接收`json`格式的参数`{'SI.si_n':'WEB', 'SI.si_x':'002'}`\n\n<pre><code>\n  &lt;div class=\"icon-content\" v-ready-stat=\"{'SI.si_n':'xxx','SI.si_x':'009'}\"&gt;\n</code></pre>\n\n>2.`v-click-stat`指令，用于采集用户点击事件的数据\n在被点击的dom节点上声明埋点指令`v-click-stat`,数据格式`{'SI.si_n':'WEB', 'SI.si_x':'002'}`\n\n<pre><code>\n\t&lt;el-button type=\"text\" v-data-stat=\"{'SI.si_n':'WEB', 'SI.si_x':'002'}\"&gt;{{message}}&lt;/el-button&gt;\n</code></pre>\n\n>3.命令式采集业务码\n针对需要在业务逻辑中进行埋点的特殊场景，提供命令式埋点方案；\n在vue组件中需要`import`埋点插件`import bp from 'buried-Point'`,在需要埋点的位置调用埋点方法`bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')`\n\n<pre><code>\nimport bp from 'buried-Point'\nexport default {\n  //在vue组件的生命周期钩子mounted阶段，进行埋点\n  mounted() {\n    bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')\n  }\n}\n</code></pre>\n\n","slug":"基于vue的埋点方案","published":1,"updated":"2018-05-07T01:32:16.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11x0000c2om2jueesar1","content":"<h1 id=\"buried-point基于vue的埋点方案\"><a href=\"#buried-point基于vue的埋点方案\" class=\"headerlink\" title=\"buried-point基于vue的埋点方案\"></a>buried-point基于vue的埋点方案</h1><h2 id=\"安装Install\"><a href=\"#安装Install\" class=\"headerlink\" title=\"安装Install\"></a>安装Install</h2><pre><code>npm install buried-point</code></pre>\n\n<h2 id=\"配置configuration\"><a href=\"#配置configuration\" class=\"headerlink\" title=\"配置configuration\"></a>配置configuration</h2><p><code>main.js</code>中进行如下配置：</p>\n<pre><code>\n  import BuriedPoint from 'buried-point'\n\n  let option = {\n    router: router,  //vue路由对象\n    domain: '127.0.0.1:18080',  //埋点服务器地址\n    path: '/nresource/dcsImg'   //埋点请求路径  `/nresource/dcsImg/dcs.log`\n  }\n  Vue.use(BuriedPoint, option)\n\n</code></pre>\n\n<h2 id=\"开始使用start\"><a href=\"#开始使用start\" class=\"headerlink\" title=\"开始使用start\"></a>开始使用start</h2><blockquote>\n<p>1.<code>v-ready-stat</code>指令，用于采集页面加载完成时数据<br>在需要采集数据的vue组件根节点上声明埋点指令<code>v-ready-stat</code></p>\n</blockquote>\n<pre><code>\n  &lt;template&gt;\n  &lt;div class=\"button-content\" v-ready-stat&gt;\n  &lt;/template&gt;\n</code></pre>\n\n<blockquote>\n<p>如果需要在页面加载时传递数据，<code>v-ready-stat</code>指令可以接收<code>json</code>格式的参数<code>{&#39;SI.si_n&#39;:&#39;WEB&#39;, &#39;SI.si_x&#39;:&#39;002&#39;}</code></p>\n</blockquote>\n<pre><code>\n  &lt;div class=\"icon-content\" v-ready-stat=\"{'SI.si_n':'xxx','SI.si_x':'009'}\"&gt;\n</code></pre>\n\n<blockquote>\n<p>2.<code>v-click-stat</code>指令，用于采集用户点击事件的数据<br>在被点击的dom节点上声明埋点指令<code>v-click-stat</code>,数据格式<code>{&#39;SI.si_n&#39;:&#39;WEB&#39;, &#39;SI.si_x&#39;:&#39;002&#39;}</code></p>\n</blockquote>\n<pre><code>\n    &lt;el-button type=\"text\" v-data-stat=\"{'SI.si_n':'WEB', 'SI.si_x':'002'}\"&gt;{{message}}&lt;/el-button&gt;\n</code></pre>\n\n<blockquote>\n<p>3.命令式采集业务码<br>针对需要在业务逻辑中进行埋点的特殊场景，提供命令式埋点方案；<br>在vue组件中需要<code>import</code>埋点插件<code>import bp from &#39;buried-Point&#39;</code>,在需要埋点的位置调用埋点方法<code>bp.dcsMultiTrack(&#39;SI.si_n&#39;, &#39;WEB_Q&#39;, &#39;SI.si_x&#39;, &#39;005&#39;)</code></p>\n</blockquote>\n<pre><code>\nimport bp from 'buried-Point'\nexport default {\n  //在vue组件的生命周期钩子mounted阶段，进行埋点\n  mounted() {\n    bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')\n  }\n}\n</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"buried-point基于vue的埋点方案\"><a href=\"#buried-point基于vue的埋点方案\" class=\"headerlink\" title=\"buried-point基于vue的埋点方案\"></a>buried-point基于vue的埋点方案</h1><h2 id=\"安装Install\"><a href=\"#安装Install\" class=\"headerlink\" title=\"安装Install\"></a>安装Install</h2><pre><code>npm install buried-point</code></pre>\n\n<h2 id=\"配置configuration\"><a href=\"#配置configuration\" class=\"headerlink\" title=\"配置configuration\"></a>配置configuration</h2><p><code>main.js</code>中进行如下配置：</p>\n<pre><code>\n  import BuriedPoint from 'buried-point'\n\n  let option = {\n    router: router,  //vue路由对象\n    domain: '127.0.0.1:18080',  //埋点服务器地址\n    path: '/nresource/dcsImg'   //埋点请求路径  `/nresource/dcsImg/dcs.log`\n  }\n  Vue.use(BuriedPoint, option)\n\n</code></pre>\n\n<h2 id=\"开始使用start\"><a href=\"#开始使用start\" class=\"headerlink\" title=\"开始使用start\"></a>开始使用start</h2><blockquote>\n<p>1.<code>v-ready-stat</code>指令，用于采集页面加载完成时数据<br>在需要采集数据的vue组件根节点上声明埋点指令<code>v-ready-stat</code></p>\n</blockquote>\n<pre><code>\n  &lt;template&gt;\n  &lt;div class=\"button-content\" v-ready-stat&gt;\n  &lt;/template&gt;\n</code></pre>\n\n<blockquote>\n<p>如果需要在页面加载时传递数据，<code>v-ready-stat</code>指令可以接收<code>json</code>格式的参数<code>{&#39;SI.si_n&#39;:&#39;WEB&#39;, &#39;SI.si_x&#39;:&#39;002&#39;}</code></p>\n</blockquote>\n<pre><code>\n  &lt;div class=\"icon-content\" v-ready-stat=\"{'SI.si_n':'xxx','SI.si_x':'009'}\"&gt;\n</code></pre>\n\n<blockquote>\n<p>2.<code>v-click-stat</code>指令，用于采集用户点击事件的数据<br>在被点击的dom节点上声明埋点指令<code>v-click-stat</code>,数据格式<code>{&#39;SI.si_n&#39;:&#39;WEB&#39;, &#39;SI.si_x&#39;:&#39;002&#39;}</code></p>\n</blockquote>\n<pre><code>\n    &lt;el-button type=\"text\" v-data-stat=\"{'SI.si_n':'WEB', 'SI.si_x':'002'}\"&gt;{{message}}&lt;/el-button&gt;\n</code></pre>\n\n<blockquote>\n<p>3.命令式采集业务码<br>针对需要在业务逻辑中进行埋点的特殊场景，提供命令式埋点方案；<br>在vue组件中需要<code>import</code>埋点插件<code>import bp from &#39;buried-Point&#39;</code>,在需要埋点的位置调用埋点方法<code>bp.dcsMultiTrack(&#39;SI.si_n&#39;, &#39;WEB_Q&#39;, &#39;SI.si_x&#39;, &#39;005&#39;)</code></p>\n</blockquote>\n<pre><code>\nimport bp from 'buried-Point'\nexport default {\n  //在vue组件的生命周期钩子mounted阶段，进行埋点\n  mounted() {\n    bp.dcsMultiTrack('SI.si_n', 'WEB_Q', 'SI.si_x', '005')\n  }\n}\n</code></pre>\n\n"},{"title":"基于vue的管理系统权限管控方案","date":"2018-05-14T14:07:52.000Z","_content":"基于vue的管理系统的权限管控方案\n===\n近期在做后台管理系统，前端是vue + vue-router + vuex + webpack实现的spa应用；管理系统中有可视化编辑、工作流、运营数据、报表等不同的能力，需要开放给不同的用户角色使用，因此需要对菜单进行权限控制；\n\n还有一些特殊的情况，由于运营数据和可视化配置是两个前端应用，展示效果是统一的，技术栈也相同（vue...），但是需要统一进行登录和权限管理；（后期也可能会有更多这样的情况，如：报表系统）\n\n最终想要达到的目标：\n1. 不同用户登录后看到的菜单不同；\n2. 多个前端系统的菜单统一\n3. 系统内的菜单是路由访问，系统外的菜单使用外链跳转；\n4. 即使用户保存了前端路由，没有权限也无法访问；\n\n设计方案\n---\n\n###### 时序图\n\n![时序图](SequenceDiagram.png)\n\n登录和权限管理我们有现成的产品，CAS+基础域；集成CAS后，即可通过基础域来管理角色和权限；因此方案是根据CAS和基础域来设计的；\n* 首先，前端需要获取到当前登录的用户和权限；登录后，后端的session中是保存有用户信息和权限信息的，需要增加一个接口为前端返回这些信息；\n* 第二：菜单需要根据权限信息展示，而基础域返回的权限信息只有url；因此需要现有全量的菜单，再根据权限做交集处理；最开始计划全量菜单写在前端工程里，但后续增加菜单需要在每个系统都做一次修改，不合理；基础域中导航管理模块的数据结构正好能满足要求，计划将菜单通过基础域配置，提供接口返回给前端使用，这样的话菜单也可以通过可视化配置，避免了频繁的开发上线；\n* 第三：区分路由还是外链，在配置时统一配置完整的url，包含请求路径和hash值，在每个前端系统中配置自己的上下文，查询出的菜单与当前系统的上下文相同时，即为内部访问路由；如果不相同则表示外链\n* 第四：VUE路由通过权限信息来生成，没有权限则没有路由，即使之前保存了路由也无法访问；保证了安全性；\n![渲染菜单](menu.jpg)\n\n\n在具体实现过程中，踩了不少坑，下面我将详细讲述下实现过程中的关键点：\n\n\n集成CAS\n---\n登录的部分采用现有的CAS产品；CAS是SpringMVC架构实现的单点登录应用，有独立的登录界面，通过在目标应用的web.xml中配置过滤器、集成jar包的方式，在目标应用收到请求时，向CAS系统发起验证登录请求，如未登录则拦截请求，重定向至CAS登录界面；\n\n在前后端分离的项目中，请求前端工程时，需要前端主动发起请求，判断登录状态，如未登录由前端重定向至CAS登录界面（后端返回指定错误码）；\n\n在前端应用加载时就发起请求验证登录状态，可以在main.js中进行；如果未登录重定向至登录界面；\n```bash\n  axios({method: 'post', url: '/y/adm/market/sso/asynchronLoginCheckServlet', data: {}}).then(({ data }) => {\n    if (data.code === '009999') {\n      window.location.href = config.domain + '/cas/login?service=' + config.retDom + '/market/sso/asynchronLoginResServlet?page=' + window.location.origin + '/y/adm/market/index.html'; \n    }\n  })\n```\n\n\n菜单初始化\n---\n#### 权限信息获取\n登录成功后，后端应用的session中会保存当前登录用户的基本信息和权限信息；后端提供接口，在登录成功后获取session中的信息，数据结构如下：\n```bash\n{\n\t\"data\":\n\t{\n\t\t\"authority\":[],   //url权限列表\n\t\t\"contactPhone\":\"13934900000\",   \n\t\t\"loginNo\":\"admin\"  //登录账号\n\t},\n\t\"retCode\":\"0000\",\n\t\"retMsg\":\"OK\"\n}\n```\n\n#### 菜单列表查询\n采用基础域的权限模型\n#### 补充查询sql，画一下UML图\n\n#### 初始化菜单\n拿到全量的菜单信息后，根据权限信息进行过滤，将没有权限的菜单剔除掉：\n\n权限信息查询和菜单查询需要放在登录后进行，并且需要在权限获取后再进行菜单查询，否则在菜单渲染时，会出现权限列表尚未获取情况，导致菜单未经过滤全部展示出来；\n\n因此权限信息获取接口和菜单列表接口需要处理竞态，竞态的处理建议放在同一个action中来做，如果写成两个action，处理竞态要麻烦很多；\n```bash\n  async fetchUserInfo ({ commit }, payload) {\n    let response = null\n    let response1 = null\n    try {\n      response = await initBase({})\n      response1 = await qryMenu({})\n      response.data.menuList = response1.data\n      let rou = initAuthority(response.data)\n      commit('SET_USER_BASE_INFO', response.data)\n      return rou\n    } catch (err) {\n      console.error(err)\n    }\n  }\n```\ninitAuthority方法处理三件事：\n1、过滤menuList中没有权限的menu；\n2、根据权限生成路由对象；\n3、区分出内链和外链（系统内菜单还是系统外菜单）；\n这里需要注意一点，为了菜单是系统内还是系统外，录入菜单url时，需要录入完整的url，\n例如：http://xxx/111/222.html#333\n由于系统的上下文不同，在处理时根据本系统的上下文来区分，是本系统的上下文，则只保留路由部分；非本系统则保留完整的url；\n```bash\n  data.menuList.filter(function (x) {\n    x.childPortalNavs = x.childPortalNavs.filter(function (y) {\n      y.childPortalNavs = y.childPortalNavs.map(function (z) {\n        if (z.appVersionUrl.indexOf(config.host) > -1) {\n          z.appVersionUrl = z.appVersionUrl.split('#')[1]\n          z.out = false\n        } else {\n          z.out = true\n        }\n        return z\n      })\n      return y.childPortalNavs.length > 0\n    })\n    return x.childPortalNavs.length > 0\n  })\n```\n\ncommit设置status中的变量：\n```bash\n'SET_USER_BASE_INFO' (state, payload) {\n    let {loginNo, contactPhone, authority, menuList} = payload\n    state.userBase.name = loginNo\n    state.userBase.phone = contactPhone\n    state.userBase.authority = authority\n    state.menuList = menuList\n  },\n```\n\n#### Router（路由）管理\n路由管理就是说，可访问的路由要和菜单保持一致；\n但是vue-router的实例，在new vue实例的时候，就加载了，且必须加载，这个时候，登录路由一定要加载，可是这个时候没有登录，无法确定权限\n\n解决思路很简单，菜单和路由同步，肯定是采用了vuex，一开始的思路的是，在一开始，就把所有的路由规则加载，然后在登录的时候，取得权限路由，对比两个路由，通过修改修改一个权限字段来隐藏菜单，如果在后台页面添加了新菜单规则，路由是按模块加载的不同的文件，这时对路由的文件进行新的读写，虽然可以解决问题，但是如果手动在浏览器地址上路由，依然可以访问，所以在路由的全局钩子上还要做拦截。\n\n上面的思路可以解决问题，但是很繁琐；\n\n幸运的是VUE在2.2版本以后，官方新增了api，addRoutes，专门针对服务端渲染路由，那么这下问题就比较简单了；\n\n在前面initAuthority方法中，我们已经拿到了经过权限过滤的菜单列表了，只要再把列表中属于系统内的菜单生成路由对象，通过addRoutes动态加载到路由中就可以了；\n```bash\nconst checkMenus = function (data) {\n  data.menuList.forEach(function (x) {\n    if (x.childPortalNavs.length > 0) {\n      x.childPortalNavs.forEach(function (y) {\n        if (y.childPortalNavs.length > 0) {\n          y.childPortalNavs.forEach(function (z) {\n            if (!z.out) {\n              rou.children.push({\n                path: z.appVersionUrl,\n                name: z.naviName,\n                component: componentMap[z.appVersionUrl]\n              })\n            }\n          })\n        }\n      })\n    }\n  })\n  return rou\n}\n```\n\n前面的代码中，initAuthority方法返回的就是生成的路由对象：\n```bash\nstore.dispatch('easyMarketing/fetchUserInfo', null, { root: true }).then(rou => {\n   router.addRoutes([rou])\n});\n```\n\n#### 菜单渲染\n菜单根据menuList渲染即可，渲染时根据是否系统外菜单增加a标签\n```bash\n  <el-menu-item :index=\"item2.out ? '' : item2.appVersionUrl\" v-for=\"item2 in item1.childPortalNavs\" :key=\"item2.naviId\">\n    <a :href=\"item2.appVersionUrl\" v-if=\"item2.out\" style=\"color:rgb(143, 151, 161);\">\n      {{item2.naviName}}\n    </a>\n    <a style=\"color:rgb(143, 151, 161);\" v-else>\n      {{item2.naviName}}\n    </a>\n  </el-menu-item>\n```\n需要注意一点：渲染时，系统外的菜单，菜单路由要为空，否则会出现先切换路由再触发a标签的跳转，浏览器选择上一步时就会出现空页面；\n\n总结\n---\n1、菜单结构保持3级，只有最小级的菜单有访问路由；\n2、根据系统上下文区分菜单是否本系统菜单；\n3、使用addRoutes动态生成路由，保证路由和菜单的一致性，没有权限的菜单即使知道路由也无法访问；\n4、权限信息查询和菜单查询要放在一个action中查，使用异步开发手段处理好竞态；\n5、外链菜单渲染时路由参数置空，保证系统间切换的一致性性；\n\n##### 此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；","source":"_posts/基于vue的管理系统权限管控方案.md","raw":"---\ntitle: 基于vue的管理系统权限管控方案\ndate: 2018-05-14 14:07:52\ntags:\n---\n基于vue的管理系统的权限管控方案\n===\n近期在做后台管理系统，前端是vue + vue-router + vuex + webpack实现的spa应用；管理系统中有可视化编辑、工作流、运营数据、报表等不同的能力，需要开放给不同的用户角色使用，因此需要对菜单进行权限控制；\n\n还有一些特殊的情况，由于运营数据和可视化配置是两个前端应用，展示效果是统一的，技术栈也相同（vue...），但是需要统一进行登录和权限管理；（后期也可能会有更多这样的情况，如：报表系统）\n\n最终想要达到的目标：\n1. 不同用户登录后看到的菜单不同；\n2. 多个前端系统的菜单统一\n3. 系统内的菜单是路由访问，系统外的菜单使用外链跳转；\n4. 即使用户保存了前端路由，没有权限也无法访问；\n\n设计方案\n---\n\n###### 时序图\n\n![时序图](SequenceDiagram.png)\n\n登录和权限管理我们有现成的产品，CAS+基础域；集成CAS后，即可通过基础域来管理角色和权限；因此方案是根据CAS和基础域来设计的；\n* 首先，前端需要获取到当前登录的用户和权限；登录后，后端的session中是保存有用户信息和权限信息的，需要增加一个接口为前端返回这些信息；\n* 第二：菜单需要根据权限信息展示，而基础域返回的权限信息只有url；因此需要现有全量的菜单，再根据权限做交集处理；最开始计划全量菜单写在前端工程里，但后续增加菜单需要在每个系统都做一次修改，不合理；基础域中导航管理模块的数据结构正好能满足要求，计划将菜单通过基础域配置，提供接口返回给前端使用，这样的话菜单也可以通过可视化配置，避免了频繁的开发上线；\n* 第三：区分路由还是外链，在配置时统一配置完整的url，包含请求路径和hash值，在每个前端系统中配置自己的上下文，查询出的菜单与当前系统的上下文相同时，即为内部访问路由；如果不相同则表示外链\n* 第四：VUE路由通过权限信息来生成，没有权限则没有路由，即使之前保存了路由也无法访问；保证了安全性；\n![渲染菜单](menu.jpg)\n\n\n在具体实现过程中，踩了不少坑，下面我将详细讲述下实现过程中的关键点：\n\n\n集成CAS\n---\n登录的部分采用现有的CAS产品；CAS是SpringMVC架构实现的单点登录应用，有独立的登录界面，通过在目标应用的web.xml中配置过滤器、集成jar包的方式，在目标应用收到请求时，向CAS系统发起验证登录请求，如未登录则拦截请求，重定向至CAS登录界面；\n\n在前后端分离的项目中，请求前端工程时，需要前端主动发起请求，判断登录状态，如未登录由前端重定向至CAS登录界面（后端返回指定错误码）；\n\n在前端应用加载时就发起请求验证登录状态，可以在main.js中进行；如果未登录重定向至登录界面；\n```bash\n  axios({method: 'post', url: '/y/adm/market/sso/asynchronLoginCheckServlet', data: {}}).then(({ data }) => {\n    if (data.code === '009999') {\n      window.location.href = config.domain + '/cas/login?service=' + config.retDom + '/market/sso/asynchronLoginResServlet?page=' + window.location.origin + '/y/adm/market/index.html'; \n    }\n  })\n```\n\n\n菜单初始化\n---\n#### 权限信息获取\n登录成功后，后端应用的session中会保存当前登录用户的基本信息和权限信息；后端提供接口，在登录成功后获取session中的信息，数据结构如下：\n```bash\n{\n\t\"data\":\n\t{\n\t\t\"authority\":[],   //url权限列表\n\t\t\"contactPhone\":\"13934900000\",   \n\t\t\"loginNo\":\"admin\"  //登录账号\n\t},\n\t\"retCode\":\"0000\",\n\t\"retMsg\":\"OK\"\n}\n```\n\n#### 菜单列表查询\n采用基础域的权限模型\n#### 补充查询sql，画一下UML图\n\n#### 初始化菜单\n拿到全量的菜单信息后，根据权限信息进行过滤，将没有权限的菜单剔除掉：\n\n权限信息查询和菜单查询需要放在登录后进行，并且需要在权限获取后再进行菜单查询，否则在菜单渲染时，会出现权限列表尚未获取情况，导致菜单未经过滤全部展示出来；\n\n因此权限信息获取接口和菜单列表接口需要处理竞态，竞态的处理建议放在同一个action中来做，如果写成两个action，处理竞态要麻烦很多；\n```bash\n  async fetchUserInfo ({ commit }, payload) {\n    let response = null\n    let response1 = null\n    try {\n      response = await initBase({})\n      response1 = await qryMenu({})\n      response.data.menuList = response1.data\n      let rou = initAuthority(response.data)\n      commit('SET_USER_BASE_INFO', response.data)\n      return rou\n    } catch (err) {\n      console.error(err)\n    }\n  }\n```\ninitAuthority方法处理三件事：\n1、过滤menuList中没有权限的menu；\n2、根据权限生成路由对象；\n3、区分出内链和外链（系统内菜单还是系统外菜单）；\n这里需要注意一点，为了菜单是系统内还是系统外，录入菜单url时，需要录入完整的url，\n例如：http://xxx/111/222.html#333\n由于系统的上下文不同，在处理时根据本系统的上下文来区分，是本系统的上下文，则只保留路由部分；非本系统则保留完整的url；\n```bash\n  data.menuList.filter(function (x) {\n    x.childPortalNavs = x.childPortalNavs.filter(function (y) {\n      y.childPortalNavs = y.childPortalNavs.map(function (z) {\n        if (z.appVersionUrl.indexOf(config.host) > -1) {\n          z.appVersionUrl = z.appVersionUrl.split('#')[1]\n          z.out = false\n        } else {\n          z.out = true\n        }\n        return z\n      })\n      return y.childPortalNavs.length > 0\n    })\n    return x.childPortalNavs.length > 0\n  })\n```\n\ncommit设置status中的变量：\n```bash\n'SET_USER_BASE_INFO' (state, payload) {\n    let {loginNo, contactPhone, authority, menuList} = payload\n    state.userBase.name = loginNo\n    state.userBase.phone = contactPhone\n    state.userBase.authority = authority\n    state.menuList = menuList\n  },\n```\n\n#### Router（路由）管理\n路由管理就是说，可访问的路由要和菜单保持一致；\n但是vue-router的实例，在new vue实例的时候，就加载了，且必须加载，这个时候，登录路由一定要加载，可是这个时候没有登录，无法确定权限\n\n解决思路很简单，菜单和路由同步，肯定是采用了vuex，一开始的思路的是，在一开始，就把所有的路由规则加载，然后在登录的时候，取得权限路由，对比两个路由，通过修改修改一个权限字段来隐藏菜单，如果在后台页面添加了新菜单规则，路由是按模块加载的不同的文件，这时对路由的文件进行新的读写，虽然可以解决问题，但是如果手动在浏览器地址上路由，依然可以访问，所以在路由的全局钩子上还要做拦截。\n\n上面的思路可以解决问题，但是很繁琐；\n\n幸运的是VUE在2.2版本以后，官方新增了api，addRoutes，专门针对服务端渲染路由，那么这下问题就比较简单了；\n\n在前面initAuthority方法中，我们已经拿到了经过权限过滤的菜单列表了，只要再把列表中属于系统内的菜单生成路由对象，通过addRoutes动态加载到路由中就可以了；\n```bash\nconst checkMenus = function (data) {\n  data.menuList.forEach(function (x) {\n    if (x.childPortalNavs.length > 0) {\n      x.childPortalNavs.forEach(function (y) {\n        if (y.childPortalNavs.length > 0) {\n          y.childPortalNavs.forEach(function (z) {\n            if (!z.out) {\n              rou.children.push({\n                path: z.appVersionUrl,\n                name: z.naviName,\n                component: componentMap[z.appVersionUrl]\n              })\n            }\n          })\n        }\n      })\n    }\n  })\n  return rou\n}\n```\n\n前面的代码中，initAuthority方法返回的就是生成的路由对象：\n```bash\nstore.dispatch('easyMarketing/fetchUserInfo', null, { root: true }).then(rou => {\n   router.addRoutes([rou])\n});\n```\n\n#### 菜单渲染\n菜单根据menuList渲染即可，渲染时根据是否系统外菜单增加a标签\n```bash\n  <el-menu-item :index=\"item2.out ? '' : item2.appVersionUrl\" v-for=\"item2 in item1.childPortalNavs\" :key=\"item2.naviId\">\n    <a :href=\"item2.appVersionUrl\" v-if=\"item2.out\" style=\"color:rgb(143, 151, 161);\">\n      {{item2.naviName}}\n    </a>\n    <a style=\"color:rgb(143, 151, 161);\" v-else>\n      {{item2.naviName}}\n    </a>\n  </el-menu-item>\n```\n需要注意一点：渲染时，系统外的菜单，菜单路由要为空，否则会出现先切换路由再触发a标签的跳转，浏览器选择上一步时就会出现空页面；\n\n总结\n---\n1、菜单结构保持3级，只有最小级的菜单有访问路由；\n2、根据系统上下文区分菜单是否本系统菜单；\n3、使用addRoutes动态生成路由，保证路由和菜单的一致性，没有权限的菜单即使知道路由也无法访问；\n4、权限信息查询和菜单查询要放在一个action中查，使用异步开发手段处理好竞态；\n5、外链菜单渲染时路由参数置空，保证系统间切换的一致性性；\n\n##### 此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；","slug":"基于vue的管理系统权限管控方案","published":1,"updated":"2018-05-31T11:49:56.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11x1000d2om2e6epaex4","content":"<h1 id=\"基于vue的管理系统的权限管控方案\"><a href=\"#基于vue的管理系统的权限管控方案\" class=\"headerlink\" title=\"基于vue的管理系统的权限管控方案\"></a>基于vue的管理系统的权限管控方案</h1><p>近期在做后台管理系统，前端是vue + vue-router + vuex + webpack实现的spa应用；管理系统中有可视化编辑、工作流、运营数据、报表等不同的能力，需要开放给不同的用户角色使用，因此需要对菜单进行权限控制；</p>\n<p>还有一些特殊的情况，由于运营数据和可视化配置是两个前端应用，展示效果是统一的，技术栈也相同（vue…），但是需要统一进行登录和权限管理；（后期也可能会有更多这样的情况，如：报表系统）</p>\n<p>最终想要达到的目标：</p>\n<ol>\n<li>不同用户登录后看到的菜单不同；</li>\n<li>多个前端系统的菜单统一</li>\n<li>系统内的菜单是路由访问，系统外的菜单使用外链跳转；</li>\n<li>即使用户保存了前端路由，没有权限也无法访问；</li>\n</ol>\n<h2 id=\"设计方案\"><a href=\"#设计方案\" class=\"headerlink\" title=\"设计方案\"></a>设计方案</h2><h6 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h6><p><img src=\"/blog/2018/05/14/基于vue的管理系统权限管控方案/SequenceDiagram.png\" alt=\"时序图\"></p>\n<p>登录和权限管理我们有现成的产品，CAS+基础域；集成CAS后，即可通过基础域来管理角色和权限；因此方案是根据CAS和基础域来设计的；</p>\n<ul>\n<li>首先，前端需要获取到当前登录的用户和权限；登录后，后端的session中是保存有用户信息和权限信息的，需要增加一个接口为前端返回这些信息；</li>\n<li>第二：菜单需要根据权限信息展示，而基础域返回的权限信息只有url；因此需要现有全量的菜单，再根据权限做交集处理；最开始计划全量菜单写在前端工程里，但后续增加菜单需要在每个系统都做一次修改，不合理；基础域中导航管理模块的数据结构正好能满足要求，计划将菜单通过基础域配置，提供接口返回给前端使用，这样的话菜单也可以通过可视化配置，避免了频繁的开发上线；</li>\n<li>第三：区分路由还是外链，在配置时统一配置完整的url，包含请求路径和hash值，在每个前端系统中配置自己的上下文，查询出的菜单与当前系统的上下文相同时，即为内部访问路由；如果不相同则表示外链</li>\n<li>第四：VUE路由通过权限信息来生成，没有权限则没有路由，即使之前保存了路由也无法访问；保证了安全性；<br><img src=\"/blog/2018/05/14/基于vue的管理系统权限管控方案/menu.jpg\" alt=\"渲染菜单\"></li>\n</ul>\n<p>在具体实现过程中，踩了不少坑，下面我将详细讲述下实现过程中的关键点：</p>\n<h2 id=\"集成CAS\"><a href=\"#集成CAS\" class=\"headerlink\" title=\"集成CAS\"></a>集成CAS</h2><p>登录的部分采用现有的CAS产品；CAS是SpringMVC架构实现的单点登录应用，有独立的登录界面，通过在目标应用的web.xml中配置过滤器、集成jar包的方式，在目标应用收到请求时，向CAS系统发起验证登录请求，如未登录则拦截请求，重定向至CAS登录界面；</p>\n<p>在前后端分离的项目中，请求前端工程时，需要前端主动发起请求，判断登录状态，如未登录由前端重定向至CAS登录界面（后端返回指定错误码）；</p>\n<p>在前端应用加载时就发起请求验证登录状态，可以在main.js中进行；如果未登录重定向至登录界面；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;method: <span class=\"string\">'post'</span>, url: <span class=\"string\">'/y/adm/market/sso/asynchronLoginCheckServlet'</span>, data: &#123;&#125;&#125;).<span class=\"keyword\">then</span>((&#123; data &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data.code === <span class=\"string\">'009999'</span>) &#123;</span><br><span class=\"line\">    window.location.href = config.domain + <span class=\"string\">'/cas/login?service='</span> + config.retDom + <span class=\"string\">'/market/sso/asynchronLoginResServlet?page='</span> + window.location.origin + <span class=\"string\">'/y/adm/market/index.html'</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"菜单初始化\"><a href=\"#菜单初始化\" class=\"headerlink\" title=\"菜单初始化\"></a>菜单初始化</h2><h4 id=\"权限信息获取\"><a href=\"#权限信息获取\" class=\"headerlink\" title=\"权限信息获取\"></a>权限信息获取</h4><p>登录成功后，后端应用的session中会保存当前登录用户的基本信息和权限信息；后端提供接口，在登录成功后获取session中的信息，数据结构如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"authority\"</span>:[],   //url权限列表</span><br><span class=\"line\">\t\t<span class=\"string\">\"contactPhone\"</span>:<span class=\"string\">\"13934900000\"</span>,   </span><br><span class=\"line\">\t\t<span class=\"string\">\"loginNo\"</span>:<span class=\"string\">\"admin\"</span>  //登录账号</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"string\">\"retCode\"</span>:<span class=\"string\">\"0000\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"retMsg\"</span>:<span class=\"string\">\"OK\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"菜单列表查询\"><a href=\"#菜单列表查询\" class=\"headerlink\" title=\"菜单列表查询\"></a>菜单列表查询</h4><p>采用基础域的权限模型</p>\n<h4 id=\"补充查询sql，画一下UML图\"><a href=\"#补充查询sql，画一下UML图\" class=\"headerlink\" title=\"补充查询sql，画一下UML图\"></a>补充查询sql，画一下UML图</h4><h4 id=\"初始化菜单\"><a href=\"#初始化菜单\" class=\"headerlink\" title=\"初始化菜单\"></a>初始化菜单</h4><p>拿到全量的菜单信息后，根据权限信息进行过滤，将没有权限的菜单剔除掉：</p>\n<p>权限信息查询和菜单查询需要放在登录后进行，并且需要在权限获取后再进行菜单查询，否则在菜单渲染时，会出现权限列表尚未获取情况，导致菜单未经过滤全部展示出来；</p>\n<p>因此权限信息获取接口和菜单列表接口需要处理竞态，竞态的处理建议放在同一个action中来做，如果写成两个action，处理竞态要麻烦很多；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async fetchUserInfo (&#123; commit &#125;, payload) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> response = null</span><br><span class=\"line\">  <span class=\"built_in\">let</span> response1 = null</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    response = await initBase(&#123;&#125;)</span><br><span class=\"line\">    response1 = await qryMenu(&#123;&#125;)</span><br><span class=\"line\">    response.data.menuList = response1.data</span><br><span class=\"line\">    <span class=\"built_in\">let</span> rou = initAuthority(response.data)</span><br><span class=\"line\">    commit(<span class=\"string\">'SET_USER_BASE_INFO'</span>, response.data)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> rou</span><br><span class=\"line\">  &#125; catch (err) &#123;</span><br><span class=\"line\">    console.error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>initAuthority方法处理三件事：<br>1、过滤menuList中没有权限的menu；<br>2、根据权限生成路由对象；<br>3、区分出内链和外链（系统内菜单还是系统外菜单）；<br>这里需要注意一点，为了菜单是系统内还是系统外，录入菜单url时，需要录入完整的url，<br>例如：<a href=\"http://xxx/111/222.html#333\" target=\"_blank\" rel=\"noopener\">http://xxx/111/222.html#333</a><br>由于系统的上下文不同，在处理时根据本系统的上下文来区分，是本系统的上下文，则只保留路由部分；非本系统则保留完整的url；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data.menuList.filter(<span class=\"keyword\">function</span> (x) &#123;</span><br><span class=\"line\">  x.childPortalNavs = x.childPortalNavs.filter(<span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">    y.childPortalNavs = y.childPortalNavs.map(<span class=\"keyword\">function</span> (z) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (z.appVersionUrl.indexOf(config.host) &gt; -1) &#123;</span><br><span class=\"line\">        z.appVersionUrl = z.appVersionUrl.split(<span class=\"string\">'#'</span>)[1]</span><br><span class=\"line\">        z.out = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        z.out = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> z</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> y.childPortalNavs.length &gt; 0</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> x.childPortalNavs.length &gt; 0</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>commit设置status中的变量：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'SET_USER_BASE_INFO'</span> (state, payload) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> &#123;loginNo, contactPhone, authority, menuList&#125; = payload</span><br><span class=\"line\">    state.userBase.name = loginNo</span><br><span class=\"line\">    state.userBase.phone = contactPhone</span><br><span class=\"line\">    state.userBase.authority = authority</span><br><span class=\"line\">    state.menuList = menuList</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Router（路由）管理\"><a href=\"#Router（路由）管理\" class=\"headerlink\" title=\"Router（路由）管理\"></a>Router（路由）管理</h4><p>路由管理就是说，可访问的路由要和菜单保持一致；<br>但是vue-router的实例，在new vue实例的时候，就加载了，且必须加载，这个时候，登录路由一定要加载，可是这个时候没有登录，无法确定权限</p>\n<p>解决思路很简单，菜单和路由同步，肯定是采用了vuex，一开始的思路的是，在一开始，就把所有的路由规则加载，然后在登录的时候，取得权限路由，对比两个路由，通过修改修改一个权限字段来隐藏菜单，如果在后台页面添加了新菜单规则，路由是按模块加载的不同的文件，这时对路由的文件进行新的读写，虽然可以解决问题，但是如果手动在浏览器地址上路由，依然可以访问，所以在路由的全局钩子上还要做拦截。</p>\n<p>上面的思路可以解决问题，但是很繁琐；</p>\n<p>幸运的是VUE在2.2版本以后，官方新增了api，addRoutes，专门针对服务端渲染路由，那么这下问题就比较简单了；</p>\n<p>在前面initAuthority方法中，我们已经拿到了经过权限过滤的菜单列表了，只要再把列表中属于系统内的菜单生成路由对象，通过addRoutes动态加载到路由中就可以了；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const checkMenus = <span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">  data.menuList.forEach(<span class=\"keyword\">function</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.childPortalNavs.length &gt; 0) &#123;</span><br><span class=\"line\">      x.childPortalNavs.forEach(<span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y.childPortalNavs.length &gt; 0) &#123;</span><br><span class=\"line\">          y.childPortalNavs.forEach(<span class=\"keyword\">function</span> (z) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!z.out) &#123;</span><br><span class=\"line\">              rou.children.push(&#123;</span><br><span class=\"line\">                path: z.appVersionUrl,</span><br><span class=\"line\">                name: z.naviName,</span><br><span class=\"line\">                component: componentMap[z.appVersionUrl]</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> rou</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前面的代码中，initAuthority方法返回的就是生成的路由对象：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'easyMarketing/fetchUserInfo'</span>, null, &#123; root: <span class=\"literal\">true</span> &#125;).<span class=\"keyword\">then</span>(rou =&gt; &#123;</span><br><span class=\"line\">   router.addRoutes([rou])</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"菜单渲染\"><a href=\"#菜单渲染\" class=\"headerlink\" title=\"菜单渲染\"></a>菜单渲染</h4><p>菜单根据menuList渲染即可，渲染时根据是否系统外菜单增加a标签<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-menu-item :index=<span class=\"string\">\"item2.out ? '' : item2.appVersionUrl\"</span> v-for=<span class=\"string\">\"item2 in item1.childPortalNavs\"</span> :key=<span class=\"string\">\"item2.naviId\"</span>&gt;</span><br><span class=\"line\">  &lt;a :href=<span class=\"string\">\"item2.appVersionUrl\"</span> v-if=<span class=\"string\">\"item2.out\"</span> style=<span class=\"string\">\"color:rgb(143, 151, 161);\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;item2.naviName&#125;&#125;</span><br><span class=\"line\">  &lt;/a&gt;</span><br><span class=\"line\">  &lt;a style=<span class=\"string\">\"color:rgb(143, 151, 161);\"</span> v-else&gt;</span><br><span class=\"line\">    &#123;&#123;item2.naviName&#125;&#125;</span><br><span class=\"line\">  &lt;/a&gt;</span><br><span class=\"line\">&lt;/el-menu-item&gt;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意一点：渲染时，系统外的菜单，菜单路由要为空，否则会出现先切换路由再触发a标签的跳转，浏览器选择上一步时就会出现空页面；</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、菜单结构保持3级，只有最小级的菜单有访问路由；<br>2、根据系统上下文区分菜单是否本系统菜单；<br>3、使用addRoutes动态生成路由，保证路由和菜单的一致性，没有权限的菜单即使知道路由也无法访问；<br>4、权限信息查询和菜单查询要放在一个action中查，使用异步开发手段处理好竞态；<br>5、外链菜单渲染时路由参数置空，保证系统间切换的一致性性；</p>\n<h5 id=\"此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\"><a href=\"#此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\" class=\"headerlink\" title=\"此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\"></a>此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；</h5>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于vue的管理系统的权限管控方案\"><a href=\"#基于vue的管理系统的权限管控方案\" class=\"headerlink\" title=\"基于vue的管理系统的权限管控方案\"></a>基于vue的管理系统的权限管控方案</h1><p>近期在做后台管理系统，前端是vue + vue-router + vuex + webpack实现的spa应用；管理系统中有可视化编辑、工作流、运营数据、报表等不同的能力，需要开放给不同的用户角色使用，因此需要对菜单进行权限控制；</p>\n<p>还有一些特殊的情况，由于运营数据和可视化配置是两个前端应用，展示效果是统一的，技术栈也相同（vue…），但是需要统一进行登录和权限管理；（后期也可能会有更多这样的情况，如：报表系统）</p>\n<p>最终想要达到的目标：</p>\n<ol>\n<li>不同用户登录后看到的菜单不同；</li>\n<li>多个前端系统的菜单统一</li>\n<li>系统内的菜单是路由访问，系统外的菜单使用外链跳转；</li>\n<li>即使用户保存了前端路由，没有权限也无法访问；</li>\n</ol>\n<h2 id=\"设计方案\"><a href=\"#设计方案\" class=\"headerlink\" title=\"设计方案\"></a>设计方案</h2><h6 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h6><p><img src=\"/blog/2018/05/14/基于vue的管理系统权限管控方案/SequenceDiagram.png\" alt=\"时序图\"></p>\n<p>登录和权限管理我们有现成的产品，CAS+基础域；集成CAS后，即可通过基础域来管理角色和权限；因此方案是根据CAS和基础域来设计的；</p>\n<ul>\n<li>首先，前端需要获取到当前登录的用户和权限；登录后，后端的session中是保存有用户信息和权限信息的，需要增加一个接口为前端返回这些信息；</li>\n<li>第二：菜单需要根据权限信息展示，而基础域返回的权限信息只有url；因此需要现有全量的菜单，再根据权限做交集处理；最开始计划全量菜单写在前端工程里，但后续增加菜单需要在每个系统都做一次修改，不合理；基础域中导航管理模块的数据结构正好能满足要求，计划将菜单通过基础域配置，提供接口返回给前端使用，这样的话菜单也可以通过可视化配置，避免了频繁的开发上线；</li>\n<li>第三：区分路由还是外链，在配置时统一配置完整的url，包含请求路径和hash值，在每个前端系统中配置自己的上下文，查询出的菜单与当前系统的上下文相同时，即为内部访问路由；如果不相同则表示外链</li>\n<li>第四：VUE路由通过权限信息来生成，没有权限则没有路由，即使之前保存了路由也无法访问；保证了安全性；<br><img src=\"/blog/2018/05/14/基于vue的管理系统权限管控方案/menu.jpg\" alt=\"渲染菜单\"></li>\n</ul>\n<p>在具体实现过程中，踩了不少坑，下面我将详细讲述下实现过程中的关键点：</p>\n<h2 id=\"集成CAS\"><a href=\"#集成CAS\" class=\"headerlink\" title=\"集成CAS\"></a>集成CAS</h2><p>登录的部分采用现有的CAS产品；CAS是SpringMVC架构实现的单点登录应用，有独立的登录界面，通过在目标应用的web.xml中配置过滤器、集成jar包的方式，在目标应用收到请求时，向CAS系统发起验证登录请求，如未登录则拦截请求，重定向至CAS登录界面；</p>\n<p>在前后端分离的项目中，请求前端工程时，需要前端主动发起请求，判断登录状态，如未登录由前端重定向至CAS登录界面（后端返回指定错误码）；</p>\n<p>在前端应用加载时就发起请求验证登录状态，可以在main.js中进行；如果未登录重定向至登录界面；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;method: <span class=\"string\">'post'</span>, url: <span class=\"string\">'/y/adm/market/sso/asynchronLoginCheckServlet'</span>, data: &#123;&#125;&#125;).<span class=\"keyword\">then</span>((&#123; data &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data.code === <span class=\"string\">'009999'</span>) &#123;</span><br><span class=\"line\">    window.location.href = config.domain + <span class=\"string\">'/cas/login?service='</span> + config.retDom + <span class=\"string\">'/market/sso/asynchronLoginResServlet?page='</span> + window.location.origin + <span class=\"string\">'/y/adm/market/index.html'</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"菜单初始化\"><a href=\"#菜单初始化\" class=\"headerlink\" title=\"菜单初始化\"></a>菜单初始化</h2><h4 id=\"权限信息获取\"><a href=\"#权限信息获取\" class=\"headerlink\" title=\"权限信息获取\"></a>权限信息获取</h4><p>登录成功后，后端应用的session中会保存当前登录用户的基本信息和权限信息；后端提供接口，在登录成功后获取session中的信息，数据结构如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"authority\"</span>:[],   //url权限列表</span><br><span class=\"line\">\t\t<span class=\"string\">\"contactPhone\"</span>:<span class=\"string\">\"13934900000\"</span>,   </span><br><span class=\"line\">\t\t<span class=\"string\">\"loginNo\"</span>:<span class=\"string\">\"admin\"</span>  //登录账号</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"string\">\"retCode\"</span>:<span class=\"string\">\"0000\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"retMsg\"</span>:<span class=\"string\">\"OK\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"菜单列表查询\"><a href=\"#菜单列表查询\" class=\"headerlink\" title=\"菜单列表查询\"></a>菜单列表查询</h4><p>采用基础域的权限模型</p>\n<h4 id=\"补充查询sql，画一下UML图\"><a href=\"#补充查询sql，画一下UML图\" class=\"headerlink\" title=\"补充查询sql，画一下UML图\"></a>补充查询sql，画一下UML图</h4><h4 id=\"初始化菜单\"><a href=\"#初始化菜单\" class=\"headerlink\" title=\"初始化菜单\"></a>初始化菜单</h4><p>拿到全量的菜单信息后，根据权限信息进行过滤，将没有权限的菜单剔除掉：</p>\n<p>权限信息查询和菜单查询需要放在登录后进行，并且需要在权限获取后再进行菜单查询，否则在菜单渲染时，会出现权限列表尚未获取情况，导致菜单未经过滤全部展示出来；</p>\n<p>因此权限信息获取接口和菜单列表接口需要处理竞态，竞态的处理建议放在同一个action中来做，如果写成两个action，处理竞态要麻烦很多；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async fetchUserInfo (&#123; commit &#125;, payload) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> response = null</span><br><span class=\"line\">  <span class=\"built_in\">let</span> response1 = null</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    response = await initBase(&#123;&#125;)</span><br><span class=\"line\">    response1 = await qryMenu(&#123;&#125;)</span><br><span class=\"line\">    response.data.menuList = response1.data</span><br><span class=\"line\">    <span class=\"built_in\">let</span> rou = initAuthority(response.data)</span><br><span class=\"line\">    commit(<span class=\"string\">'SET_USER_BASE_INFO'</span>, response.data)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> rou</span><br><span class=\"line\">  &#125; catch (err) &#123;</span><br><span class=\"line\">    console.error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>initAuthority方法处理三件事：<br>1、过滤menuList中没有权限的menu；<br>2、根据权限生成路由对象；<br>3、区分出内链和外链（系统内菜单还是系统外菜单）；<br>这里需要注意一点，为了菜单是系统内还是系统外，录入菜单url时，需要录入完整的url，<br>例如：<a href=\"http://xxx/111/222.html#333\" target=\"_blank\" rel=\"noopener\">http://xxx/111/222.html#333</a><br>由于系统的上下文不同，在处理时根据本系统的上下文来区分，是本系统的上下文，则只保留路由部分；非本系统则保留完整的url；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data.menuList.filter(<span class=\"keyword\">function</span> (x) &#123;</span><br><span class=\"line\">  x.childPortalNavs = x.childPortalNavs.filter(<span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">    y.childPortalNavs = y.childPortalNavs.map(<span class=\"keyword\">function</span> (z) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (z.appVersionUrl.indexOf(config.host) &gt; -1) &#123;</span><br><span class=\"line\">        z.appVersionUrl = z.appVersionUrl.split(<span class=\"string\">'#'</span>)[1]</span><br><span class=\"line\">        z.out = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        z.out = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> z</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">return</span> y.childPortalNavs.length &gt; 0</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> x.childPortalNavs.length &gt; 0</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>commit设置status中的变量：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'SET_USER_BASE_INFO'</span> (state, payload) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> &#123;loginNo, contactPhone, authority, menuList&#125; = payload</span><br><span class=\"line\">    state.userBase.name = loginNo</span><br><span class=\"line\">    state.userBase.phone = contactPhone</span><br><span class=\"line\">    state.userBase.authority = authority</span><br><span class=\"line\">    state.menuList = menuList</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Router（路由）管理\"><a href=\"#Router（路由）管理\" class=\"headerlink\" title=\"Router（路由）管理\"></a>Router（路由）管理</h4><p>路由管理就是说，可访问的路由要和菜单保持一致；<br>但是vue-router的实例，在new vue实例的时候，就加载了，且必须加载，这个时候，登录路由一定要加载，可是这个时候没有登录，无法确定权限</p>\n<p>解决思路很简单，菜单和路由同步，肯定是采用了vuex，一开始的思路的是，在一开始，就把所有的路由规则加载，然后在登录的时候，取得权限路由，对比两个路由，通过修改修改一个权限字段来隐藏菜单，如果在后台页面添加了新菜单规则，路由是按模块加载的不同的文件，这时对路由的文件进行新的读写，虽然可以解决问题，但是如果手动在浏览器地址上路由，依然可以访问，所以在路由的全局钩子上还要做拦截。</p>\n<p>上面的思路可以解决问题，但是很繁琐；</p>\n<p>幸运的是VUE在2.2版本以后，官方新增了api，addRoutes，专门针对服务端渲染路由，那么这下问题就比较简单了；</p>\n<p>在前面initAuthority方法中，我们已经拿到了经过权限过滤的菜单列表了，只要再把列表中属于系统内的菜单生成路由对象，通过addRoutes动态加载到路由中就可以了；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const checkMenus = <span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">  data.menuList.forEach(<span class=\"keyword\">function</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.childPortalNavs.length &gt; 0) &#123;</span><br><span class=\"line\">      x.childPortalNavs.forEach(<span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y.childPortalNavs.length &gt; 0) &#123;</span><br><span class=\"line\">          y.childPortalNavs.forEach(<span class=\"keyword\">function</span> (z) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!z.out) &#123;</span><br><span class=\"line\">              rou.children.push(&#123;</span><br><span class=\"line\">                path: z.appVersionUrl,</span><br><span class=\"line\">                name: z.naviName,</span><br><span class=\"line\">                component: componentMap[z.appVersionUrl]</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> rou</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前面的代码中，initAuthority方法返回的就是生成的路由对象：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'easyMarketing/fetchUserInfo'</span>, null, &#123; root: <span class=\"literal\">true</span> &#125;).<span class=\"keyword\">then</span>(rou =&gt; &#123;</span><br><span class=\"line\">   router.addRoutes([rou])</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"菜单渲染\"><a href=\"#菜单渲染\" class=\"headerlink\" title=\"菜单渲染\"></a>菜单渲染</h4><p>菜单根据menuList渲染即可，渲染时根据是否系统外菜单增加a标签<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-menu-item :index=<span class=\"string\">\"item2.out ? '' : item2.appVersionUrl\"</span> v-for=<span class=\"string\">\"item2 in item1.childPortalNavs\"</span> :key=<span class=\"string\">\"item2.naviId\"</span>&gt;</span><br><span class=\"line\">  &lt;a :href=<span class=\"string\">\"item2.appVersionUrl\"</span> v-if=<span class=\"string\">\"item2.out\"</span> style=<span class=\"string\">\"color:rgb(143, 151, 161);\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123;item2.naviName&#125;&#125;</span><br><span class=\"line\">  &lt;/a&gt;</span><br><span class=\"line\">  &lt;a style=<span class=\"string\">\"color:rgb(143, 151, 161);\"</span> v-else&gt;</span><br><span class=\"line\">    &#123;&#123;item2.naviName&#125;&#125;</span><br><span class=\"line\">  &lt;/a&gt;</span><br><span class=\"line\">&lt;/el-menu-item&gt;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意一点：渲染时，系统外的菜单，菜单路由要为空，否则会出现先切换路由再触发a标签的跳转，浏览器选择上一步时就会出现空页面；</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、菜单结构保持3级，只有最小级的菜单有访问路由；<br>2、根据系统上下文区分菜单是否本系统菜单；<br>3、使用addRoutes动态生成路由，保证路由和菜单的一致性，没有权限的菜单即使知道路由也无法访问；<br>4、权限信息查询和菜单查询要放在一个action中查，使用异步开发手段处理好竞态；<br>5、外链菜单渲染时路由参数置空，保证系统间切换的一致性性；</p>\n<h5 id=\"此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\"><a href=\"#此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\" class=\"headerlink\" title=\"此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；\"></a>此方案可复用至多个前端系统共享菜单的场景，菜单管理只需要在基础域中进行配置，前端工程无需改造；</h5>"},{"title":"手动实现一个promise/A+","date":"2018-12-03T14:06:06.000Z","_content":"\n开始\n---\n用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。\n\n准备工作\n---\n既然要手动实现一个Promise/A+的规范，那么首先需要知道这个规范的详细内容；\n\nPromise/A+规范\n---\n### Promise状态\n一个Promise必须在其中之一的状态： pending， fulfilled或rejected\n* pending状态：promise可以转成fulfilled和rejected状态\n* fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变；\n* rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；\n\n","source":"_posts/手动实现一个promise-A.md","raw":"---\ntitle: 手动实现一个promise/A+\ndate: 2018-12-03 14:06:06\ntags:\n---\n\n开始\n---\n用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。\n\n准备工作\n---\n既然要手动实现一个Promise/A+的规范，那么首先需要知道这个规范的详细内容；\n\nPromise/A+规范\n---\n### Promise状态\n一个Promise必须在其中之一的状态： pending， fulfilled或rejected\n* pending状态：promise可以转成fulfilled和rejected状态\n* fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变；\n* rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；\n\n","slug":"手动实现一个promise-A","published":1,"updated":"2019-01-21T01:19:13.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11x3000e2om2qnspg4zf","content":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>既然要手动实现一个Promise/A+的规范，那么首先需要知道这个规范的详细内容；</p>\n<h2 id=\"Promise-A-规范\"><a href=\"#Promise-A-规范\" class=\"headerlink\" title=\"Promise/A+规范\"></a>Promise/A+规范</h2><h3 id=\"Promise状态\"><a href=\"#Promise状态\" class=\"headerlink\" title=\"Promise状态\"></a>Promise状态</h3><p>一个Promise必须在其中之一的状态： pending， fulfilled或rejected</p>\n<ul>\n<li>pending状态：promise可以转成fulfilled和rejected状态</li>\n<li>fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变；</li>\n<li>rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>既然要手动实现一个Promise/A+的规范，那么首先需要知道这个规范的详细内容；</p>\n<h2 id=\"Promise-A-规范\"><a href=\"#Promise-A-规范\" class=\"headerlink\" title=\"Promise/A+规范\"></a>Promise/A+规范</h2><h3 id=\"Promise状态\"><a href=\"#Promise状态\" class=\"headerlink\" title=\"Promise状态\"></a>Promise状态</h3><p>一个Promise必须在其中之一的状态： pending， fulfilled或rejected</p>\n<ul>\n<li>pending状态：promise可以转成fulfilled和rejected状态</li>\n<li>fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变；</li>\n<li>rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；</li>\n</ul>\n"},{"title":"营销活动数据采集日志存储方案","date":"2018-11-02T15:29:56.000Z","_content":"\n山西移动电子渠道营销2018项目中，营销活动需要采集用户行为数据，目前采集方案已有，需要确定日志存放位置；\n\n#### 方案一：插码日志打印在和生活主机（8台）\n\n* 好处：与和生活方案一致，网络策略已打通；\n* 风险：需要改动和生活前端8台主机的nginx配置，为营销插码数据单独进行配置，改动风险较大；\n\n#### 方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）\n\n* 好处：已经配置完成，可直接采集；\n* 风险：需要打通网络；\n\n#### 方案三：插码日志统一打印在图片服务器主机上（8台）\n\n* 好处：图片服务器没有系统应用，配置风险低；做好目录规划，后期山西分支插码可统一打印在一起；\n* 风险：需要打通网络；\n\n个人比较倾向于方案三，统一采集位置后，可对日志及配置进行统一管理；独立主机改造风险小；","source":"_posts/营销活动数据采集方案.md","raw":"---\ntitle: 营销活动数据采集日志存储方案\ndate: 2018-11-02 15:29:56\ntags:\n---\n\n山西移动电子渠道营销2018项目中，营销活动需要采集用户行为数据，目前采集方案已有，需要确定日志存放位置；\n\n#### 方案一：插码日志打印在和生活主机（8台）\n\n* 好处：与和生活方案一致，网络策略已打通；\n* 风险：需要改动和生活前端8台主机的nginx配置，为营销插码数据单独进行配置，改动风险较大；\n\n#### 方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）\n\n* 好处：已经配置完成，可直接采集；\n* 风险：需要打通网络；\n\n#### 方案三：插码日志统一打印在图片服务器主机上（8台）\n\n* 好处：图片服务器没有系统应用，配置风险低；做好目录规划，后期山西分支插码可统一打印在一起；\n* 风险：需要打通网络；\n\n个人比较倾向于方案三，统一采集位置后，可对日志及配置进行统一管理；独立主机改造风险小；","slug":"营销活动数据采集方案","published":1,"updated":"2018-11-05T06:22:19.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11x4000f2om2043u1oq6","content":"<p>山西移动电子渠道营销2018项目中，营销活动需要采集用户行为数据，目前采集方案已有，需要确定日志存放位置；</p>\n<h4 id=\"方案一：插码日志打印在和生活主机（8台）\"><a href=\"#方案一：插码日志打印在和生活主机（8台）\" class=\"headerlink\" title=\"方案一：插码日志打印在和生活主机（8台）\"></a>方案一：插码日志打印在和生活主机（8台）</h4><ul>\n<li>好处：与和生活方案一致，网络策略已打通；</li>\n<li>风险：需要改动和生活前端8台主机的nginx配置，为营销插码数据单独进行配置，改动风险较大；</li>\n</ul>\n<h4 id=\"方案二：营销活动插码日志打印在营销前台主机（3台，79-80-81）\"><a href=\"#方案二：营销活动插码日志打印在营销前台主机（3台，79-80-81）\" class=\"headerlink\" title=\"方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）\"></a>方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）</h4><ul>\n<li>好处：已经配置完成，可直接采集；</li>\n<li>风险：需要打通网络；</li>\n</ul>\n<h4 id=\"方案三：插码日志统一打印在图片服务器主机上（8台）\"><a href=\"#方案三：插码日志统一打印在图片服务器主机上（8台）\" class=\"headerlink\" title=\"方案三：插码日志统一打印在图片服务器主机上（8台）\"></a>方案三：插码日志统一打印在图片服务器主机上（8台）</h4><ul>\n<li>好处：图片服务器没有系统应用，配置风险低；做好目录规划，后期山西分支插码可统一打印在一起；</li>\n<li>风险：需要打通网络；</li>\n</ul>\n<p>个人比较倾向于方案三，统一采集位置后，可对日志及配置进行统一管理；独立主机改造风险小；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>山西移动电子渠道营销2018项目中，营销活动需要采集用户行为数据，目前采集方案已有，需要确定日志存放位置；</p>\n<h4 id=\"方案一：插码日志打印在和生活主机（8台）\"><a href=\"#方案一：插码日志打印在和生活主机（8台）\" class=\"headerlink\" title=\"方案一：插码日志打印在和生活主机（8台）\"></a>方案一：插码日志打印在和生活主机（8台）</h4><ul>\n<li>好处：与和生活方案一致，网络策略已打通；</li>\n<li>风险：需要改动和生活前端8台主机的nginx配置，为营销插码数据单独进行配置，改动风险较大；</li>\n</ul>\n<h4 id=\"方案二：营销活动插码日志打印在营销前台主机（3台，79-80-81）\"><a href=\"#方案二：营销活动插码日志打印在营销前台主机（3台，79-80-81）\" class=\"headerlink\" title=\"方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）\"></a>方案二：营销活动插码日志打印在营销前台主机（3台，79/80/81）</h4><ul>\n<li>好处：已经配置完成，可直接采集；</li>\n<li>风险：需要打通网络；</li>\n</ul>\n<h4 id=\"方案三：插码日志统一打印在图片服务器主机上（8台）\"><a href=\"#方案三：插码日志统一打印在图片服务器主机上（8台）\" class=\"headerlink\" title=\"方案三：插码日志统一打印在图片服务器主机上（8台）\"></a>方案三：插码日志统一打印在图片服务器主机上（8台）</h4><ul>\n<li>好处：图片服务器没有系统应用，配置风险低；做好目录规划，后期山西分支插码可统一打印在一起；</li>\n<li>风险：需要打通网络；</li>\n</ul>\n<p>个人比较倾向于方案三，统一采集位置后，可对日志及配置进行统一管理；独立主机改造风险小；</p>\n"},{"title":"易问web版浏览器支持方案分析","date":"2019-01-25T15:30:12.000Z","_content":"背景\n---\n易问.net向web迁移过程，需要考虑浏览器支持性的问题。支持不同的浏览器技术架构和实现方案也有所不同\n\n现状\n---\n易问.net版有一部分用户仍然使用的是windows xp系统，而xp系统，IE浏览器最高只能支持到IE8。\n### 数据\n|省份|总用户|xp用户|\n|----|-----|------|\n|福建省|24957|1270|\n|广西壮族自治区|33389|1116|\n|江西省|25330|308|\n|陕西省|21060|291|\n|山东省|14466|242|\n|山西省|9549|214|\n|贵州省|4810|192|\n|重庆电信|15117|191|\n|云南省|15348|103|\n|黑龙江电信|5939|98|\n|吉林省|6458|94|\n|内蒙古自治区|7952|87|\n|辽宁省|6593|79|\n|海南省|8553|78|\n|河北省|24747|77|\n|宁夏回族自治区|3459|77|\n|甘肃省|6505|52|\n|湖北省|6379|41|\n|天津市|3552|41|\n|青海省|4506|21|\n|西藏自治区|3769|17|\n|易问集团支撑项目组||17010|\n|四川省|714|7|\n|北京市|2943|5|\n|号百信息服务有限公司||800|\n|河南省|2|0|\n|翼支付|12|0|\n|云公司|170|0|\n\n如果要照顾这部分用户的使用，易问web版需要兼容IE8浏览器。\n\n设计和实现上的限制\n---\nIE8的发行时间是2008年，到现在已经有10年以上了，很多新技术，新规范IE8都无法支持。\n### 即时沟通模块\nwebsocket是HTML5新加入的，一种在单个TCP上进行全双工通信协议，非常适合web端的即时通讯场景。\n\n不能采用WEBSOCKET协议的原因有两个：\n1、\t消息服务由NBC提供，根据反馈目前暂时无法支持websocket协议。（需要升级）\n2、\t兼容性问题，websocket协议需要IE10以上的浏览器才能支持。\nwebsocket兼容性:\n\nNBC目前提供的消息接口是基于BOSH协议实现（Bidirectional-streams Over Synchronous HTTP）\nBOSH： 一种传输协议。它可以利用同步的HTTP协议模拟两个实体（例如客户端-服务端）双向流传输，而不需要轮询或异步组件。\n\n性能比较：https://blog.csdn.net/liangxw1/article/details/50810440\n\n### 跨域解决方案\n消息服务接口是独立域名，目前是通过CORS方式解决的浏览器跨域请求。\n\n但是，IE8不支持CORS，需要通过反向代理的方式解决，在实际落地时需要考虑网络情况。\n\n### 文件上传\n易问提问题流程需要上传附件。\n\n目前大部分文件上传是基于浏览器的FormData对象，在IE8下，除了表单提交，只能使用jquery.form方式，并且需要后端配合修改contentType才能实现，并且无法实现断点续传方式。体验上要差很多。\n\n### 前端存储\n易问web版有可能会处理大量消息，消息解析，消息排序，消息状态管理等，全部依赖接口实现，性能会存在问题，同时，消息服务也无法完全确保消息的次序。实际解决过程，难免需要前端缓存一部分数据。\n\n### 前端框架选择\nEP框架     -支持IE8以上浏览器\nTOUCH2.1   支持IE10以上浏览器","source":"_posts/易问web版浏览器支持方案分析.md","raw":"---\ntitle: 易问web版浏览器支持方案分析\ndate: 2019-01-25 15:30:12\ntags:\n---\n背景\n---\n易问.net向web迁移过程，需要考虑浏览器支持性的问题。支持不同的浏览器技术架构和实现方案也有所不同\n\n现状\n---\n易问.net版有一部分用户仍然使用的是windows xp系统，而xp系统，IE浏览器最高只能支持到IE8。\n### 数据\n|省份|总用户|xp用户|\n|----|-----|------|\n|福建省|24957|1270|\n|广西壮族自治区|33389|1116|\n|江西省|25330|308|\n|陕西省|21060|291|\n|山东省|14466|242|\n|山西省|9549|214|\n|贵州省|4810|192|\n|重庆电信|15117|191|\n|云南省|15348|103|\n|黑龙江电信|5939|98|\n|吉林省|6458|94|\n|内蒙古自治区|7952|87|\n|辽宁省|6593|79|\n|海南省|8553|78|\n|河北省|24747|77|\n|宁夏回族自治区|3459|77|\n|甘肃省|6505|52|\n|湖北省|6379|41|\n|天津市|3552|41|\n|青海省|4506|21|\n|西藏自治区|3769|17|\n|易问集团支撑项目组||17010|\n|四川省|714|7|\n|北京市|2943|5|\n|号百信息服务有限公司||800|\n|河南省|2|0|\n|翼支付|12|0|\n|云公司|170|0|\n\n如果要照顾这部分用户的使用，易问web版需要兼容IE8浏览器。\n\n设计和实现上的限制\n---\nIE8的发行时间是2008年，到现在已经有10年以上了，很多新技术，新规范IE8都无法支持。\n### 即时沟通模块\nwebsocket是HTML5新加入的，一种在单个TCP上进行全双工通信协议，非常适合web端的即时通讯场景。\n\n不能采用WEBSOCKET协议的原因有两个：\n1、\t消息服务由NBC提供，根据反馈目前暂时无法支持websocket协议。（需要升级）\n2、\t兼容性问题，websocket协议需要IE10以上的浏览器才能支持。\nwebsocket兼容性:\n\nNBC目前提供的消息接口是基于BOSH协议实现（Bidirectional-streams Over Synchronous HTTP）\nBOSH： 一种传输协议。它可以利用同步的HTTP协议模拟两个实体（例如客户端-服务端）双向流传输，而不需要轮询或异步组件。\n\n性能比较：https://blog.csdn.net/liangxw1/article/details/50810440\n\n### 跨域解决方案\n消息服务接口是独立域名，目前是通过CORS方式解决的浏览器跨域请求。\n\n但是，IE8不支持CORS，需要通过反向代理的方式解决，在实际落地时需要考虑网络情况。\n\n### 文件上传\n易问提问题流程需要上传附件。\n\n目前大部分文件上传是基于浏览器的FormData对象，在IE8下，除了表单提交，只能使用jquery.form方式，并且需要后端配合修改contentType才能实现，并且无法实现断点续传方式。体验上要差很多。\n\n### 前端存储\n易问web版有可能会处理大量消息，消息解析，消息排序，消息状态管理等，全部依赖接口实现，性能会存在问题，同时，消息服务也无法完全确保消息的次序。实际解决过程，难免需要前端缓存一部分数据。\n\n### 前端框架选择\nEP框架     -支持IE8以上浏览器\nTOUCH2.1   支持IE10以上浏览器","slug":"易问web版浏览器支持方案分析","published":1,"updated":"2019-01-25T07:48:34.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11x5000g2om2gbabw0yg","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>易问.net向web迁移过程，需要考虑浏览器支持性的问题。支持不同的浏览器技术架构和实现方案也有所不同</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>易问.net版有一部分用户仍然使用的是windows xp系统，而xp系统，IE浏览器最高只能支持到IE8。</p>\n<h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h3><table>\n<thead>\n<tr>\n<th>省份</th>\n<th>总用户</th>\n<th>xp用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>福建省</td>\n<td>24957</td>\n<td>1270</td>\n</tr>\n<tr>\n<td>广西壮族自治区</td>\n<td>33389</td>\n<td>1116</td>\n</tr>\n<tr>\n<td>江西省</td>\n<td>25330</td>\n<td>308</td>\n</tr>\n<tr>\n<td>陕西省</td>\n<td>21060</td>\n<td>291</td>\n</tr>\n<tr>\n<td>山东省</td>\n<td>14466</td>\n<td>242</td>\n</tr>\n<tr>\n<td>山西省</td>\n<td>9549</td>\n<td>214</td>\n</tr>\n<tr>\n<td>贵州省</td>\n<td>4810</td>\n<td>192</td>\n</tr>\n<tr>\n<td>重庆电信</td>\n<td>15117</td>\n<td>191</td>\n</tr>\n<tr>\n<td>云南省</td>\n<td>15348</td>\n<td>103</td>\n</tr>\n<tr>\n<td>黑龙江电信</td>\n<td>5939</td>\n<td>98</td>\n</tr>\n<tr>\n<td>吉林省</td>\n<td>6458</td>\n<td>94</td>\n</tr>\n<tr>\n<td>内蒙古自治区</td>\n<td>7952</td>\n<td>87</td>\n</tr>\n<tr>\n<td>辽宁省</td>\n<td>6593</td>\n<td>79</td>\n</tr>\n<tr>\n<td>海南省</td>\n<td>8553</td>\n<td>78</td>\n</tr>\n<tr>\n<td>河北省</td>\n<td>24747</td>\n<td>77</td>\n</tr>\n<tr>\n<td>宁夏回族自治区</td>\n<td>3459</td>\n<td>77</td>\n</tr>\n<tr>\n<td>甘肃省</td>\n<td>6505</td>\n<td>52</td>\n</tr>\n<tr>\n<td>湖北省</td>\n<td>6379</td>\n<td>41</td>\n</tr>\n<tr>\n<td>天津市</td>\n<td>3552</td>\n<td>41</td>\n</tr>\n<tr>\n<td>青海省</td>\n<td>4506</td>\n<td>21</td>\n</tr>\n<tr>\n<td>西藏自治区</td>\n<td>3769</td>\n<td>17</td>\n</tr>\n<tr>\n<td>易问集团支撑项目组</td>\n<td></td>\n<td>17010</td>\n</tr>\n<tr>\n<td>四川省</td>\n<td>714</td>\n<td>7</td>\n</tr>\n<tr>\n<td>北京市</td>\n<td>2943</td>\n<td>5</td>\n</tr>\n<tr>\n<td>号百信息服务有限公司</td>\n<td></td>\n<td>800</td>\n</tr>\n<tr>\n<td>河南省</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>翼支付</td>\n<td>12</td>\n<td>0</td>\n</tr>\n<tr>\n<td>云公司</td>\n<td>170</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>如果要照顾这部分用户的使用，易问web版需要兼容IE8浏览器。</p>\n<h2 id=\"设计和实现上的限制\"><a href=\"#设计和实现上的限制\" class=\"headerlink\" title=\"设计和实现上的限制\"></a>设计和实现上的限制</h2><p>IE8的发行时间是2008年，到现在已经有10年以上了，很多新技术，新规范IE8都无法支持。</p>\n<h3 id=\"即时沟通模块\"><a href=\"#即时沟通模块\" class=\"headerlink\" title=\"即时沟通模块\"></a>即时沟通模块</h3><p>websocket是HTML5新加入的，一种在单个TCP上进行全双工通信协议，非常适合web端的即时通讯场景。</p>\n<p>不能采用WEBSOCKET协议的原因有两个：<br>1、    消息服务由NBC提供，根据反馈目前暂时无法支持websocket协议。（需要升级）<br>2、    兼容性问题，websocket协议需要IE10以上的浏览器才能支持。<br>websocket兼容性:</p>\n<p>NBC目前提供的消息接口是基于BOSH协议实现（Bidirectional-streams Over Synchronous HTTP）<br>BOSH： 一种传输协议。它可以利用同步的HTTP协议模拟两个实体（例如客户端-服务端）双向流传输，而不需要轮询或异步组件。</p>\n<p>性能比较：<a href=\"https://blog.csdn.net/liangxw1/article/details/50810440\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liangxw1/article/details/50810440</a></p>\n<h3 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h3><p>消息服务接口是独立域名，目前是通过CORS方式解决的浏览器跨域请求。</p>\n<p>但是，IE8不支持CORS，需要通过反向代理的方式解决，在实际落地时需要考虑网络情况。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p>易问提问题流程需要上传附件。</p>\n<p>目前大部分文件上传是基于浏览器的FormData对象，在IE8下，除了表单提交，只能使用jquery.form方式，并且需要后端配合修改contentType才能实现，并且无法实现断点续传方式。体验上要差很多。</p>\n<h3 id=\"前端存储\"><a href=\"#前端存储\" class=\"headerlink\" title=\"前端存储\"></a>前端存储</h3><p>易问web版有可能会处理大量消息，消息解析，消息排序，消息状态管理等，全部依赖接口实现，性能会存在问题，同时，消息服务也无法完全确保消息的次序。实际解决过程，难免需要前端缓存一部分数据。</p>\n<h3 id=\"前端框架选择\"><a href=\"#前端框架选择\" class=\"headerlink\" title=\"前端框架选择\"></a>前端框架选择</h3><p>EP框架     -支持IE8以上浏览器<br>TOUCH2.1   支持IE10以上浏览器</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>易问.net向web迁移过程，需要考虑浏览器支持性的问题。支持不同的浏览器技术架构和实现方案也有所不同</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>易问.net版有一部分用户仍然使用的是windows xp系统，而xp系统，IE浏览器最高只能支持到IE8。</p>\n<h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h3><table>\n<thead>\n<tr>\n<th>省份</th>\n<th>总用户</th>\n<th>xp用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>福建省</td>\n<td>24957</td>\n<td>1270</td>\n</tr>\n<tr>\n<td>广西壮族自治区</td>\n<td>33389</td>\n<td>1116</td>\n</tr>\n<tr>\n<td>江西省</td>\n<td>25330</td>\n<td>308</td>\n</tr>\n<tr>\n<td>陕西省</td>\n<td>21060</td>\n<td>291</td>\n</tr>\n<tr>\n<td>山东省</td>\n<td>14466</td>\n<td>242</td>\n</tr>\n<tr>\n<td>山西省</td>\n<td>9549</td>\n<td>214</td>\n</tr>\n<tr>\n<td>贵州省</td>\n<td>4810</td>\n<td>192</td>\n</tr>\n<tr>\n<td>重庆电信</td>\n<td>15117</td>\n<td>191</td>\n</tr>\n<tr>\n<td>云南省</td>\n<td>15348</td>\n<td>103</td>\n</tr>\n<tr>\n<td>黑龙江电信</td>\n<td>5939</td>\n<td>98</td>\n</tr>\n<tr>\n<td>吉林省</td>\n<td>6458</td>\n<td>94</td>\n</tr>\n<tr>\n<td>内蒙古自治区</td>\n<td>7952</td>\n<td>87</td>\n</tr>\n<tr>\n<td>辽宁省</td>\n<td>6593</td>\n<td>79</td>\n</tr>\n<tr>\n<td>海南省</td>\n<td>8553</td>\n<td>78</td>\n</tr>\n<tr>\n<td>河北省</td>\n<td>24747</td>\n<td>77</td>\n</tr>\n<tr>\n<td>宁夏回族自治区</td>\n<td>3459</td>\n<td>77</td>\n</tr>\n<tr>\n<td>甘肃省</td>\n<td>6505</td>\n<td>52</td>\n</tr>\n<tr>\n<td>湖北省</td>\n<td>6379</td>\n<td>41</td>\n</tr>\n<tr>\n<td>天津市</td>\n<td>3552</td>\n<td>41</td>\n</tr>\n<tr>\n<td>青海省</td>\n<td>4506</td>\n<td>21</td>\n</tr>\n<tr>\n<td>西藏自治区</td>\n<td>3769</td>\n<td>17</td>\n</tr>\n<tr>\n<td>易问集团支撑项目组</td>\n<td></td>\n<td>17010</td>\n</tr>\n<tr>\n<td>四川省</td>\n<td>714</td>\n<td>7</td>\n</tr>\n<tr>\n<td>北京市</td>\n<td>2943</td>\n<td>5</td>\n</tr>\n<tr>\n<td>号百信息服务有限公司</td>\n<td></td>\n<td>800</td>\n</tr>\n<tr>\n<td>河南省</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>翼支付</td>\n<td>12</td>\n<td>0</td>\n</tr>\n<tr>\n<td>云公司</td>\n<td>170</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>如果要照顾这部分用户的使用，易问web版需要兼容IE8浏览器。</p>\n<h2 id=\"设计和实现上的限制\"><a href=\"#设计和实现上的限制\" class=\"headerlink\" title=\"设计和实现上的限制\"></a>设计和实现上的限制</h2><p>IE8的发行时间是2008年，到现在已经有10年以上了，很多新技术，新规范IE8都无法支持。</p>\n<h3 id=\"即时沟通模块\"><a href=\"#即时沟通模块\" class=\"headerlink\" title=\"即时沟通模块\"></a>即时沟通模块</h3><p>websocket是HTML5新加入的，一种在单个TCP上进行全双工通信协议，非常适合web端的即时通讯场景。</p>\n<p>不能采用WEBSOCKET协议的原因有两个：<br>1、    消息服务由NBC提供，根据反馈目前暂时无法支持websocket协议。（需要升级）<br>2、    兼容性问题，websocket协议需要IE10以上的浏览器才能支持。<br>websocket兼容性:</p>\n<p>NBC目前提供的消息接口是基于BOSH协议实现（Bidirectional-streams Over Synchronous HTTP）<br>BOSH： 一种传输协议。它可以利用同步的HTTP协议模拟两个实体（例如客户端-服务端）双向流传输，而不需要轮询或异步组件。</p>\n<p>性能比较：<a href=\"https://blog.csdn.net/liangxw1/article/details/50810440\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liangxw1/article/details/50810440</a></p>\n<h3 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h3><p>消息服务接口是独立域名，目前是通过CORS方式解决的浏览器跨域请求。</p>\n<p>但是，IE8不支持CORS，需要通过反向代理的方式解决，在实际落地时需要考虑网络情况。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p>易问提问题流程需要上传附件。</p>\n<p>目前大部分文件上传是基于浏览器的FormData对象，在IE8下，除了表单提交，只能使用jquery.form方式，并且需要后端配合修改contentType才能实现，并且无法实现断点续传方式。体验上要差很多。</p>\n<h3 id=\"前端存储\"><a href=\"#前端存储\" class=\"headerlink\" title=\"前端存储\"></a>前端存储</h3><p>易问web版有可能会处理大量消息，消息解析，消息排序，消息状态管理等，全部依赖接口实现，性能会存在问题，同时，消息服务也无法完全确保消息的次序。实际解决过程，难免需要前端缓存一部分数据。</p>\n<h3 id=\"前端框架选择\"><a href=\"#前端框架选择\" class=\"headerlink\" title=\"前端框架选择\"></a>前端框架选择</h3><p>EP框架     -支持IE8以上浏览器<br>TOUCH2.1   支持IE10以上浏览器</p>\n"},{"title":"拼团购活动开发总结","date":"2018-11-05T14:24:07.000Z","_content":"\n背景\n---\n\n拼团购活动是山西移动电子渠道营销2018项目中一个重要的验收点，恰好在今年山西移动也策划了一次拼团购活动（由于与世界杯活动冲突，此需求被砍），需求组的同事已经出了设计方案，本次开发就是在需求组同事的设计方案上进行一些调整，与项目中已经完成的补调机制整合，并且独立出和生活APP应用；\n\n原需求设计方案\n---\n\nhttp://eip.teamshub.com/t/3567906\n\n原设计方案已经比较详细，大体的流程已经具备；不过有些细节没有明确，而且设计方案中也没有体现，这些是本次开发的重点：细化原需求，明确场景以及细节；\n\n需求细化\n---\n\n1. 明确次数限制是针对总人数的限制；\n原需求中有参与次数的限制，经过讨论和确认，次数限制是针对参与活动的总人数进行限制（2w人次）每个档次的活动并不独立限制次数；并且，一旦成团即占据了参与人数；\n2. 明确由于余额变化导致的参团失败情况的处理；\n由于无法做到余额预占，而活动参与到成团办理有一定的时间间隔，很容易出现参与时余额足够，成团后余额不足的情况；\n经过讨论，这样的情况为用户保留办理资格，可通过界面进行补办（补调机制已经在电渠营销前台实现）；\n3. 明确限制次数可进行一定的冗余；\n团购分为3人团和5人团，最终成团人数很有可能不是恰好2w人，当剩余2人时，不论下一个成团是3人还是5人都一定会超出；\n经过讨论，可以接受1-4人的冗余；因此在成团前进行验证，只要成团前人数不足2w即可成团，而成团前一但人数超过2w即判定为参与活动失败；\n4. 每一个账号在同一时间最多只能在一个团中，只有成团后才能再次发起/参与拼团；\n5. 团购信息进行分享时，微信打开后引导用户拉起和生活APP进行访问，不提供H5直接访问界面；\n\n细化方案\n---\nhttp://eip.teamshub.com/t/3738726\n\n新数据模型\n---\n![数据模型](拼团购活动模型.png)\n\n\n开发过程中遇到的问题&总结\n---\n\n1. 前端多页面配置 @lihao_mios\nhttp://eip.teamshub.com/t/3768089\n2. vue的history模式改造  @lihao_mios\nhttp://eip.teamshub.com/t/3768294\n3. vue多页面场景+history路由模式下的nginx配置方案； @wangfy\nhttp://eip.teamshub.com/t/3770330\n4. 拼团购活动总结 @ hantao\nhttp://eip.teamshub.com/t/3769652\n---待补充\n","source":"_posts/拼团购活动开发总结.md","raw":"---\ntitle: 拼团购活动开发总结\ndate: 2018-11-05 14:24:07\ntags:\n---\n\n背景\n---\n\n拼团购活动是山西移动电子渠道营销2018项目中一个重要的验收点，恰好在今年山西移动也策划了一次拼团购活动（由于与世界杯活动冲突，此需求被砍），需求组的同事已经出了设计方案，本次开发就是在需求组同事的设计方案上进行一些调整，与项目中已经完成的补调机制整合，并且独立出和生活APP应用；\n\n原需求设计方案\n---\n\nhttp://eip.teamshub.com/t/3567906\n\n原设计方案已经比较详细，大体的流程已经具备；不过有些细节没有明确，而且设计方案中也没有体现，这些是本次开发的重点：细化原需求，明确场景以及细节；\n\n需求细化\n---\n\n1. 明确次数限制是针对总人数的限制；\n原需求中有参与次数的限制，经过讨论和确认，次数限制是针对参与活动的总人数进行限制（2w人次）每个档次的活动并不独立限制次数；并且，一旦成团即占据了参与人数；\n2. 明确由于余额变化导致的参团失败情况的处理；\n由于无法做到余额预占，而活动参与到成团办理有一定的时间间隔，很容易出现参与时余额足够，成团后余额不足的情况；\n经过讨论，这样的情况为用户保留办理资格，可通过界面进行补办（补调机制已经在电渠营销前台实现）；\n3. 明确限制次数可进行一定的冗余；\n团购分为3人团和5人团，最终成团人数很有可能不是恰好2w人，当剩余2人时，不论下一个成团是3人还是5人都一定会超出；\n经过讨论，可以接受1-4人的冗余；因此在成团前进行验证，只要成团前人数不足2w即可成团，而成团前一但人数超过2w即判定为参与活动失败；\n4. 每一个账号在同一时间最多只能在一个团中，只有成团后才能再次发起/参与拼团；\n5. 团购信息进行分享时，微信打开后引导用户拉起和生活APP进行访问，不提供H5直接访问界面；\n\n细化方案\n---\nhttp://eip.teamshub.com/t/3738726\n\n新数据模型\n---\n![数据模型](拼团购活动模型.png)\n\n\n开发过程中遇到的问题&总结\n---\n\n1. 前端多页面配置 @lihao_mios\nhttp://eip.teamshub.com/t/3768089\n2. vue的history模式改造  @lihao_mios\nhttp://eip.teamshub.com/t/3768294\n3. vue多页面场景+history路由模式下的nginx配置方案； @wangfy\nhttp://eip.teamshub.com/t/3770330\n4. 拼团购活动总结 @ hantao\nhttp://eip.teamshub.com/t/3769652\n---待补充\n","slug":"拼团购活动开发总结","published":1,"updated":"2018-11-06T10:59:15.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11xk000h2om29z82xhrd","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>拼团购活动是山西移动电子渠道营销2018项目中一个重要的验收点，恰好在今年山西移动也策划了一次拼团购活动（由于与世界杯活动冲突，此需求被砍），需求组的同事已经出了设计方案，本次开发就是在需求组同事的设计方案上进行一些调整，与项目中已经完成的补调机制整合，并且独立出和生活APP应用；</p>\n<h2 id=\"原需求设计方案\"><a href=\"#原需求设计方案\" class=\"headerlink\" title=\"原需求设计方案\"></a>原需求设计方案</h2><p><a href=\"http://eip.teamshub.com/t/3567906\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3567906</a></p>\n<p>原设计方案已经比较详细，大体的流程已经具备；不过有些细节没有明确，而且设计方案中也没有体现，这些是本次开发的重点：细化原需求，明确场景以及细节；</p>\n<h2 id=\"需求细化\"><a href=\"#需求细化\" class=\"headerlink\" title=\"需求细化\"></a>需求细化</h2><ol>\n<li>明确次数限制是针对总人数的限制；<br>原需求中有参与次数的限制，经过讨论和确认，次数限制是针对参与活动的总人数进行限制（2w人次）每个档次的活动并不独立限制次数；并且，一旦成团即占据了参与人数；</li>\n<li>明确由于余额变化导致的参团失败情况的处理；<br>由于无法做到余额预占，而活动参与到成团办理有一定的时间间隔，很容易出现参与时余额足够，成团后余额不足的情况；<br>经过讨论，这样的情况为用户保留办理资格，可通过界面进行补办（补调机制已经在电渠营销前台实现）；</li>\n<li>明确限制次数可进行一定的冗余；<br>团购分为3人团和5人团，最终成团人数很有可能不是恰好2w人，当剩余2人时，不论下一个成团是3人还是5人都一定会超出；<br>经过讨论，可以接受1-4人的冗余；因此在成团前进行验证，只要成团前人数不足2w即可成团，而成团前一但人数超过2w即判定为参与活动失败；</li>\n<li>每一个账号在同一时间最多只能在一个团中，只有成团后才能再次发起/参与拼团；</li>\n<li>团购信息进行分享时，微信打开后引导用户拉起和生活APP进行访问，不提供H5直接访问界面；</li>\n</ol>\n<h2 id=\"细化方案\"><a href=\"#细化方案\" class=\"headerlink\" title=\"细化方案\"></a>细化方案</h2><p><a href=\"http://eip.teamshub.com/t/3738726\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3738726</a></p>\n<h2 id=\"新数据模型\"><a href=\"#新数据模型\" class=\"headerlink\" title=\"新数据模型\"></a>新数据模型</h2><p><img src=\"/blog/2018/11/05/拼团购活动开发总结/拼团购活动模型.png\" alt=\"数据模型\"></p>\n<h2 id=\"开发过程中遇到的问题-amp-总结\"><a href=\"#开发过程中遇到的问题-amp-总结\" class=\"headerlink\" title=\"开发过程中遇到的问题&amp;总结\"></a>开发过程中遇到的问题&amp;总结</h2><ol>\n<li>前端多页面配置 @lihao_mios<br><a href=\"http://eip.teamshub.com/t/3768089\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3768089</a></li>\n<li>vue的history模式改造  @lihao_mios<br><a href=\"http://eip.teamshub.com/t/3768294\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3768294</a></li>\n<li>vue多页面场景+history路由模式下的nginx配置方案； @wangfy<br><a href=\"http://eip.teamshub.com/t/3770330\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3770330</a></li>\n<li>拼团购活动总结 @ hantao<br><a href=\"http://eip.teamshub.com/t/3769652\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3769652</a><br>—待补充</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>拼团购活动是山西移动电子渠道营销2018项目中一个重要的验收点，恰好在今年山西移动也策划了一次拼团购活动（由于与世界杯活动冲突，此需求被砍），需求组的同事已经出了设计方案，本次开发就是在需求组同事的设计方案上进行一些调整，与项目中已经完成的补调机制整合，并且独立出和生活APP应用；</p>\n<h2 id=\"原需求设计方案\"><a href=\"#原需求设计方案\" class=\"headerlink\" title=\"原需求设计方案\"></a>原需求设计方案</h2><p><a href=\"http://eip.teamshub.com/t/3567906\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3567906</a></p>\n<p>原设计方案已经比较详细，大体的流程已经具备；不过有些细节没有明确，而且设计方案中也没有体现，这些是本次开发的重点：细化原需求，明确场景以及细节；</p>\n<h2 id=\"需求细化\"><a href=\"#需求细化\" class=\"headerlink\" title=\"需求细化\"></a>需求细化</h2><ol>\n<li>明确次数限制是针对总人数的限制；<br>原需求中有参与次数的限制，经过讨论和确认，次数限制是针对参与活动的总人数进行限制（2w人次）每个档次的活动并不独立限制次数；并且，一旦成团即占据了参与人数；</li>\n<li>明确由于余额变化导致的参团失败情况的处理；<br>由于无法做到余额预占，而活动参与到成团办理有一定的时间间隔，很容易出现参与时余额足够，成团后余额不足的情况；<br>经过讨论，这样的情况为用户保留办理资格，可通过界面进行补办（补调机制已经在电渠营销前台实现）；</li>\n<li>明确限制次数可进行一定的冗余；<br>团购分为3人团和5人团，最终成团人数很有可能不是恰好2w人，当剩余2人时，不论下一个成团是3人还是5人都一定会超出；<br>经过讨论，可以接受1-4人的冗余；因此在成团前进行验证，只要成团前人数不足2w即可成团，而成团前一但人数超过2w即判定为参与活动失败；</li>\n<li>每一个账号在同一时间最多只能在一个团中，只有成团后才能再次发起/参与拼团；</li>\n<li>团购信息进行分享时，微信打开后引导用户拉起和生活APP进行访问，不提供H5直接访问界面；</li>\n</ol>\n<h2 id=\"细化方案\"><a href=\"#细化方案\" class=\"headerlink\" title=\"细化方案\"></a>细化方案</h2><p><a href=\"http://eip.teamshub.com/t/3738726\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3738726</a></p>\n<h2 id=\"新数据模型\"><a href=\"#新数据模型\" class=\"headerlink\" title=\"新数据模型\"></a>新数据模型</h2><p><img src=\"/blog/2018/11/05/拼团购活动开发总结/拼团购活动模型.png\" alt=\"数据模型\"></p>\n<h2 id=\"开发过程中遇到的问题-amp-总结\"><a href=\"#开发过程中遇到的问题-amp-总结\" class=\"headerlink\" title=\"开发过程中遇到的问题&amp;总结\"></a>开发过程中遇到的问题&amp;总结</h2><ol>\n<li>前端多页面配置 @lihao_mios<br><a href=\"http://eip.teamshub.com/t/3768089\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3768089</a></li>\n<li>vue的history模式改造  @lihao_mios<br><a href=\"http://eip.teamshub.com/t/3768294\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3768294</a></li>\n<li>vue多页面场景+history路由模式下的nginx配置方案； @wangfy<br><a href=\"http://eip.teamshub.com/t/3770330\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3770330</a></li>\n<li>拼团购活动总结 @ hantao<br><a href=\"http://eip.teamshub.com/t/3769652\" target=\"_blank\" rel=\"noopener\">http://eip.teamshub.com/t/3769652</a><br>—待补充</li>\n</ol>\n"},{"title":"神经网络梯度下降训练模型","date":"2018-07-28T08:29:35.000Z","_content":"先列个提纲，后续补充；\n\n1、抽象数据模型：把训练模型抽象为由多个0-1之间的数值集合；\n例如手写数字，抽象为784个像素点，每个像素点的值（0-1）表示该像素点的亮度；那么这一组像素点的数值就可以表示出手写数字的图形；\n那么我们的训练数据就是每个手写数字对应这一组像素值集合；\n\n2、设计隐含层：需要根据实际场景确认；  需要再看一遍视频\n\n3、输出层就是0-9这10个数字\n\n4、下一层节点数值计算，下一层每个节点的数值受到上一层没个节点的数值影响；\n但上层的每个节点的影响程度不同，因此需要给上一层每个节点加一个权重值W（根据自己判断，先写一个）；\n下层节点的值计算就是（W1A1+W2A2+...WnAn）为了让这个值也处在0-1之间，需要给结果加一个sigmoid函数；\n设置偏置值b，偏置值如何解释？\n最终，下层节点的计算方式是signoid(W1A1+W2A2+...WnAn-b)\n\n至此，我们可以根据上层节点的数值，以及偏置值来计算下层节点的每个值；\n\n那么可以根据我们初始的设置的权重和偏置值，计算出0-9这10个数字对应的值，我们可以理解，越接近1是这个数字的可能越大\n\n5、我们初始设置的权重w和偏置b，肯定不能准确的得出结果，那么我们需要通过计算反复的调整这些值；\n编写公式的例子\n$$\n\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\n$$\n\n首先，\n\n","source":"_posts/神经网络梯度下降训练模型.md","raw":"---\ntitle: 神经网络梯度下降训练模型\ndate: 2018-07-28 08:29:35\ntags:\n---\n先列个提纲，后续补充；\n\n1、抽象数据模型：把训练模型抽象为由多个0-1之间的数值集合；\n例如手写数字，抽象为784个像素点，每个像素点的值（0-1）表示该像素点的亮度；那么这一组像素点的数值就可以表示出手写数字的图形；\n那么我们的训练数据就是每个手写数字对应这一组像素值集合；\n\n2、设计隐含层：需要根据实际场景确认；  需要再看一遍视频\n\n3、输出层就是0-9这10个数字\n\n4、下一层节点数值计算，下一层每个节点的数值受到上一层没个节点的数值影响；\n但上层的每个节点的影响程度不同，因此需要给上一层每个节点加一个权重值W（根据自己判断，先写一个）；\n下层节点的值计算就是（W1A1+W2A2+...WnAn）为了让这个值也处在0-1之间，需要给结果加一个sigmoid函数；\n设置偏置值b，偏置值如何解释？\n最终，下层节点的计算方式是signoid(W1A1+W2A2+...WnAn-b)\n\n至此，我们可以根据上层节点的数值，以及偏置值来计算下层节点的每个值；\n\n那么可以根据我们初始的设置的权重和偏置值，计算出0-9这10个数字对应的值，我们可以理解，越接近1是这个数字的可能越大\n\n5、我们初始设置的权重w和偏置b，肯定不能准确的得出结果，那么我们需要通过计算反复的调整这些值；\n编写公式的例子\n$$\n\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\n$$\n\n首先，\n\n","slug":"神经网络梯度下降训练模型","published":1,"updated":"2018-08-01T09:29:20.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11xl000i2om2rowwlst4","content":"<p>先列个提纲，后续补充；</p>\n<p>1、抽象数据模型：把训练模型抽象为由多个0-1之间的数值集合；<br>例如手写数字，抽象为784个像素点，每个像素点的值（0-1）表示该像素点的亮度；那么这一组像素点的数值就可以表示出手写数字的图形；<br>那么我们的训练数据就是每个手写数字对应这一组像素值集合；</p>\n<p>2、设计隐含层：需要根据实际场景确认；  需要再看一遍视频</p>\n<p>3、输出层就是0-9这10个数字</p>\n<p>4、下一层节点数值计算，下一层每个节点的数值受到上一层没个节点的数值影响；<br>但上层的每个节点的影响程度不同，因此需要给上一层每个节点加一个权重值W（根据自己判断，先写一个）；<br>下层节点的值计算就是（W1A1+W2A2+…WnAn）为了让这个值也处在0-1之间，需要给结果加一个sigmoid函数；<br>设置偏置值b，偏置值如何解释？<br>最终，下层节点的计算方式是signoid(W1A1+W2A2+…WnAn-b)</p>\n<p>至此，我们可以根据上层节点的数值，以及偏置值来计算下层节点的每个值；</p>\n<p>那么可以根据我们初始的设置的权重和偏置值，计算出0-9这10个数字对应的值，我们可以理解，越接近1是这个数字的可能越大</p>\n<p>5、我们初始设置的权重w和偏置b，肯定不能准确的得出结果，那么我们需要通过计算反复的调整这些值；<br>编写公式的例子<br>$$<br>\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}<br>$$</p>\n<p>首先，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>先列个提纲，后续补充；</p>\n<p>1、抽象数据模型：把训练模型抽象为由多个0-1之间的数值集合；<br>例如手写数字，抽象为784个像素点，每个像素点的值（0-1）表示该像素点的亮度；那么这一组像素点的数值就可以表示出手写数字的图形；<br>那么我们的训练数据就是每个手写数字对应这一组像素值集合；</p>\n<p>2、设计隐含层：需要根据实际场景确认；  需要再看一遍视频</p>\n<p>3、输出层就是0-9这10个数字</p>\n<p>4、下一层节点数值计算，下一层每个节点的数值受到上一层没个节点的数值影响；<br>但上层的每个节点的影响程度不同，因此需要给上一层每个节点加一个权重值W（根据自己判断，先写一个）；<br>下层节点的值计算就是（W1A1+W2A2+…WnAn）为了让这个值也处在0-1之间，需要给结果加一个sigmoid函数；<br>设置偏置值b，偏置值如何解释？<br>最终，下层节点的计算方式是signoid(W1A1+W2A2+…WnAn-b)</p>\n<p>至此，我们可以根据上层节点的数值，以及偏置值来计算下层节点的每个值；</p>\n<p>那么可以根据我们初始的设置的权重和偏置值，计算出0-9这10个数字对应的值，我们可以理解，越接近1是这个数字的可能越大</p>\n<p>5、我们初始设置的权重w和偏置b，肯定不能准确的得出结果，那么我们需要通过计算反复的调整这些值；<br>编写公式的例子<br>$$<br>\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}<br>$$</p>\n<p>首先，</p>\n"},{"title":"和生活首页在部分机型下白屏原因分析","date":"2018-07-16T16:53:15.000Z","_content":"问题\n---\n和生活首页在世界杯活动上线后，发现极个别iphone手机（1部iphone6plus、1部iphone7）首页出现白屏，但其他同事的iphone6plus、iphone7正常\n\n问题分析\n---\n出现问题的两部手机分别是：iphone6plus（ios8.2）、iphone7（ios10.1.1）；其他同型号未出现问题的手机，系统均是ios11，因此推断是ios兼容性导致的问题；\n\nios8.2\n---\n借助mac系统的调试工具查看，发现在ios8下首页出现报错信息，信息显示不支持Class语法；\n\nClass语法是ES6标准中新增的，在ios8并不支持；\n\n查找错误信息所在位置，是swiper组件依赖的Dom7库；\n\nswiper是首页改版时引入的新的轮播图插件，也就是说导致ios8，白屏的原因是swiper中有ES6的语法；\n\nios10.1.1\n---\n在swiper的github上找到关于ios10的issue\n![issue](ios10报错.jpg)\nissue中并没有给出具体的解决方案；\n![issue](说明1.jpg)\n在framework7关于Dom7的issue中，找到：\n![issue](说明2.jpg)\n\n确保您的webpack / babel还将导入的F7转换为ES5，并解析F7的节点模块\n\n那么基本可以确认ios10.1.1也不支持ES6的语法；\n\n查询一下:\n![class兼容性](class兼容性.jpg)\n可以看到，ES6的class语法是从ios10.3版本开始兼容的，ios10.1.1并不兼容该语法\n\n与印象中不同，实际上几乎所有的ES6语法都是从ios10.3开始兼容的\n![let兼容性](let兼容性.jpg)\n![箭头函数兼容性](箭头函数兼容性.jpg)\n![Generators兼容性](generators兼容性.jpg)\n\n解决方案\n---\n按照issue中所述的解决方案，只需要将ES6的语法转为ES5即可；\n\nwebpack中的babel插件默认是不会对node_modules下的文件进行转换的，因此需要显示的将swiper和dom7的文件进行转换\n![webpack配置](webpack配置.jpg)\n\n","source":"_posts/首页在部分机型下白屏原因分析.md","raw":"---\ntitle: 和生活首页在部分机型下白屏原因分析\ndate: 2018-07-16 16:53:15\ntags:\n---\n问题\n---\n和生活首页在世界杯活动上线后，发现极个别iphone手机（1部iphone6plus、1部iphone7）首页出现白屏，但其他同事的iphone6plus、iphone7正常\n\n问题分析\n---\n出现问题的两部手机分别是：iphone6plus（ios8.2）、iphone7（ios10.1.1）；其他同型号未出现问题的手机，系统均是ios11，因此推断是ios兼容性导致的问题；\n\nios8.2\n---\n借助mac系统的调试工具查看，发现在ios8下首页出现报错信息，信息显示不支持Class语法；\n\nClass语法是ES6标准中新增的，在ios8并不支持；\n\n查找错误信息所在位置，是swiper组件依赖的Dom7库；\n\nswiper是首页改版时引入的新的轮播图插件，也就是说导致ios8，白屏的原因是swiper中有ES6的语法；\n\nios10.1.1\n---\n在swiper的github上找到关于ios10的issue\n![issue](ios10报错.jpg)\nissue中并没有给出具体的解决方案；\n![issue](说明1.jpg)\n在framework7关于Dom7的issue中，找到：\n![issue](说明2.jpg)\n\n确保您的webpack / babel还将导入的F7转换为ES5，并解析F7的节点模块\n\n那么基本可以确认ios10.1.1也不支持ES6的语法；\n\n查询一下:\n![class兼容性](class兼容性.jpg)\n可以看到，ES6的class语法是从ios10.3版本开始兼容的，ios10.1.1并不兼容该语法\n\n与印象中不同，实际上几乎所有的ES6语法都是从ios10.3开始兼容的\n![let兼容性](let兼容性.jpg)\n![箭头函数兼容性](箭头函数兼容性.jpg)\n![Generators兼容性](generators兼容性.jpg)\n\n解决方案\n---\n按照issue中所述的解决方案，只需要将ES6的语法转为ES5即可；\n\nwebpack中的babel插件默认是不会对node_modules下的文件进行转换的，因此需要显示的将swiper和dom7的文件进行转换\n![webpack配置](webpack配置.jpg)\n\n","slug":"首页在部分机型下白屏原因分析","published":1,"updated":"2018-07-17T07:36:30.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11xn000j2om2wsia4go9","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>和生活首页在世界杯活动上线后，发现极个别iphone手机（1部iphone6plus、1部iphone7）首页出现白屏，但其他同事的iphone6plus、iphone7正常</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>出现问题的两部手机分别是：iphone6plus（ios8.2）、iphone7（ios10.1.1）；其他同型号未出现问题的手机，系统均是ios11，因此推断是ios兼容性导致的问题；</p>\n<h2 id=\"ios8-2\"><a href=\"#ios8-2\" class=\"headerlink\" title=\"ios8.2\"></a>ios8.2</h2><p>借助mac系统的调试工具查看，发现在ios8下首页出现报错信息，信息显示不支持Class语法；</p>\n<p>Class语法是ES6标准中新增的，在ios8并不支持；</p>\n<p>查找错误信息所在位置，是swiper组件依赖的Dom7库；</p>\n<p>swiper是首页改版时引入的新的轮播图插件，也就是说导致ios8，白屏的原因是swiper中有ES6的语法；</p>\n<h2 id=\"ios10-1-1\"><a href=\"#ios10-1-1\" class=\"headerlink\" title=\"ios10.1.1\"></a>ios10.1.1</h2><p>在swiper的github上找到关于ios10的issue<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/ios10报错.jpg\" alt=\"issue\"><br>issue中并没有给出具体的解决方案；<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/说明1.jpg\" alt=\"issue\"><br>在framework7关于Dom7的issue中，找到：<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/说明2.jpg\" alt=\"issue\"></p>\n<p>确保您的webpack / babel还将导入的F7转换为ES5，并解析F7的节点模块</p>\n<p>那么基本可以确认ios10.1.1也不支持ES6的语法；</p>\n<p>查询一下:<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/class兼容性.jpg\" alt=\"class兼容性\"><br>可以看到，ES6的class语法是从ios10.3版本开始兼容的，ios10.1.1并不兼容该语法</p>\n<p>与印象中不同，实际上几乎所有的ES6语法都是从ios10.3开始兼容的<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/let兼容性.jpg\" alt=\"let兼容性\"><br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/箭头函数兼容性.jpg\" alt=\"箭头函数兼容性\"><br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/generators兼容性.jpg\" alt=\"Generators兼容性\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>按照issue中所述的解决方案，只需要将ES6的语法转为ES5即可；</p>\n<p>webpack中的babel插件默认是不会对node_modules下的文件进行转换的，因此需要显示的将swiper和dom7的文件进行转换<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/webpack配置.jpg\" alt=\"webpack配置\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>和生活首页在世界杯活动上线后，发现极个别iphone手机（1部iphone6plus、1部iphone7）首页出现白屏，但其他同事的iphone6plus、iphone7正常</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>出现问题的两部手机分别是：iphone6plus（ios8.2）、iphone7（ios10.1.1）；其他同型号未出现问题的手机，系统均是ios11，因此推断是ios兼容性导致的问题；</p>\n<h2 id=\"ios8-2\"><a href=\"#ios8-2\" class=\"headerlink\" title=\"ios8.2\"></a>ios8.2</h2><p>借助mac系统的调试工具查看，发现在ios8下首页出现报错信息，信息显示不支持Class语法；</p>\n<p>Class语法是ES6标准中新增的，在ios8并不支持；</p>\n<p>查找错误信息所在位置，是swiper组件依赖的Dom7库；</p>\n<p>swiper是首页改版时引入的新的轮播图插件，也就是说导致ios8，白屏的原因是swiper中有ES6的语法；</p>\n<h2 id=\"ios10-1-1\"><a href=\"#ios10-1-1\" class=\"headerlink\" title=\"ios10.1.1\"></a>ios10.1.1</h2><p>在swiper的github上找到关于ios10的issue<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/ios10报错.jpg\" alt=\"issue\"><br>issue中并没有给出具体的解决方案；<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/说明1.jpg\" alt=\"issue\"><br>在framework7关于Dom7的issue中，找到：<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/说明2.jpg\" alt=\"issue\"></p>\n<p>确保您的webpack / babel还将导入的F7转换为ES5，并解析F7的节点模块</p>\n<p>那么基本可以确认ios10.1.1也不支持ES6的语法；</p>\n<p>查询一下:<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/class兼容性.jpg\" alt=\"class兼容性\"><br>可以看到，ES6的class语法是从ios10.3版本开始兼容的，ios10.1.1并不兼容该语法</p>\n<p>与印象中不同，实际上几乎所有的ES6语法都是从ios10.3开始兼容的<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/let兼容性.jpg\" alt=\"let兼容性\"><br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/箭头函数兼容性.jpg\" alt=\"箭头函数兼容性\"><br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/generators兼容性.jpg\" alt=\"Generators兼容性\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>按照issue中所述的解决方案，只需要将ES6的语法转为ES5即可；</p>\n<p>webpack中的babel插件默认是不会对node_modules下的文件进行转换的，因此需要显示的将swiper和dom7的文件进行转换<br><img src=\"/blog/2018/07/17/首页在部分机型下白屏原因分析/webpack配置.jpg\" alt=\"webpack配置\"></p>\n"},{"title":"营销活动规则配置VUE实现","date":"2018-08-02T18:16:47.000Z","_content":"#### 背景\n山西移动电子渠道营销项目中，需要实现营销活动的可视化配置能力\n![语境图](语境图.jpg)\n\n其中一部分重点内容是如何实现活动规则的可视化配置；\n\n#### 功能描述\n* 营销活动通常意味着需要条件，满足某些条件，才可以参加活动，这些条件我称之为“规则”\n* 在营销能力提升项目中，需要在后台编辑营销活动时，同时给营销活动设置“规则”；发布至前台工程后，可根据后台配置的“规则”进行验证；\n![规则配置流程](规则配置流程.jpg)\n\n#### 需求细化\n* 此功能并不是针对某个营销活动，而是通用型的解决方案；“规则”要不断添加积累\n* 已有“规则”需要支持各种排列组合；\n* “规则”的编辑和修改需要实时生效，以应对营销活动的频繁变化；\n\n#### 界面设计\n![规则配置界面](规则配置界面设计.jpg)\n* 规则分为基础规则（必选规则），以及其他规则（可选规则）\n* 可选规则可动态添加删除\n* 部分规则可重复添加\n* 每个规则都需要进行输入验证\n* 提交时要对所有规则进行验证\n\n#### 接口设计\n![规则列表查询接口](规则列表查询接口.png)\n![规则配置保存接口](规则配置保存接口.png)\n\n#### 前端设计重点\n##### 每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\n动态组件可以通过 Vue 的 `<component>` 元素加一个特殊的 is 特性来实现：\n```\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n在上述示例中，currentTabComponent 可以包括\n\n* 已注册组件的名字，或\n* 一个组件的选项对象\n\n##### 如何获取界面上已经添加的组件\n可以通过给子组件增加ref属性，为这个子组件赋予一个ID引用。\n```\n<base-input ref=\"usernameInput\"></base-input>\n```\n现在已经定义了这个 ref 的组件里，可以使用：\n```\nthis.$refs.usernameInput\n```\n来访问这个 `<base-input>` 实例\n\n通过这种方式，我们可以在添加组件是记录组件的ref，在提交验证时，通过记录的ref属性，找到页面上已经添加的子组件（规则组件）\n```\nfor (let ref in refs) { // 查找页面中存在的子组件\n    if (Object.prototype.toString.call(refs[ref]) === '[object Object]') {\n        refs[ref].submitForm()\n    }\n    if (Object.prototype.toString.call(refs[ref]) === '[object Array]' && refs[ref].length > 0) {\n        refs[ref].forEach((each) => {\n            each.submitForm()\n        })\n    }\n}\n```\n\n##### 规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\n规则的输入校验如果都放在父组件进行，需要处理太多的交互逻辑，不利于代码的维护；\n因此，我把每个规则的输入校验，都放在各子组件内部进行，父组件只需要知道结果就可以了\n\n当父组件需要发起验证时，向各个子组件发起验证请求，子组件收到请求后，执行输入校验，并把验证结果通过emit事件通知给父组件；父组件收集子组件的通知，并判断是否全部通过，只有全部通过才可以继续执行；\n![父子组件交互](父子组件交互设计.jpg)\n\n```父组件\nsubmit () {// 向子组件发起验证请求\n    let resCollect = this.checkResult = {}\n    let refs = this.$refs\n    this.ruleMap = {}\n    this.dataItems = []\n    for (let ref in refs) {// 向子组件发起验证请求\n        if (Object.prototype.toString.call(refs[ref]) === '[object Object]') {\n            refs[ref].submitForm()\n        }\n        if (Object.prototype.toString.call(refs[ref]) === '[object Array]' && refs[ref].length > 0) {\n            refs[ref].forEach((each) => {\n                each.submitForm()\n            })\n        }\n    }\n}\ncheckResultFn (res) { // 接收子组件的通知，并记录结果\n    if (this.checkResult[res.name] !== undefined) {\n        this.checkResult[res.name] = this.checkResult[res.name] && res.result\n    } else {\n        this.checkResult[res.name] = res.result\n    }\n}\n```\n\n```子组件\nsubmitForm() { \n\t// 执行表单输入检测\n    this.$refs['form'].validate((valid) => {\n    \t// 将结果通知给父组件\n        this.$emit('checkResult', {\n            name: this.name,\n            result: valid,\n            data: this.form.checkedChannels\n        })\n    })\n}\n```\n\n\n","source":"_posts/规则配置界面设计.md","raw":"---\ntitle: 营销活动规则配置VUE实现\ndate: 2018-08-02 18:16:47\ntags:\n---\n#### 背景\n山西移动电子渠道营销项目中，需要实现营销活动的可视化配置能力\n![语境图](语境图.jpg)\n\n其中一部分重点内容是如何实现活动规则的可视化配置；\n\n#### 功能描述\n* 营销活动通常意味着需要条件，满足某些条件，才可以参加活动，这些条件我称之为“规则”\n* 在营销能力提升项目中，需要在后台编辑营销活动时，同时给营销活动设置“规则”；发布至前台工程后，可根据后台配置的“规则”进行验证；\n![规则配置流程](规则配置流程.jpg)\n\n#### 需求细化\n* 此功能并不是针对某个营销活动，而是通用型的解决方案；“规则”要不断添加积累\n* 已有“规则”需要支持各种排列组合；\n* “规则”的编辑和修改需要实时生效，以应对营销活动的频繁变化；\n\n#### 界面设计\n![规则配置界面](规则配置界面设计.jpg)\n* 规则分为基础规则（必选规则），以及其他规则（可选规则）\n* 可选规则可动态添加删除\n* 部分规则可重复添加\n* 每个规则都需要进行输入验证\n* 提交时要对所有规则进行验证\n\n#### 接口设计\n![规则列表查询接口](规则列表查询接口.png)\n![规则配置保存接口](规则配置保存接口.png)\n\n#### 前端设计重点\n##### 每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\n动态组件可以通过 Vue 的 `<component>` 元素加一个特殊的 is 特性来实现：\n```\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n在上述示例中，currentTabComponent 可以包括\n\n* 已注册组件的名字，或\n* 一个组件的选项对象\n\n##### 如何获取界面上已经添加的组件\n可以通过给子组件增加ref属性，为这个子组件赋予一个ID引用。\n```\n<base-input ref=\"usernameInput\"></base-input>\n```\n现在已经定义了这个 ref 的组件里，可以使用：\n```\nthis.$refs.usernameInput\n```\n来访问这个 `<base-input>` 实例\n\n通过这种方式，我们可以在添加组件是记录组件的ref，在提交验证时，通过记录的ref属性，找到页面上已经添加的子组件（规则组件）\n```\nfor (let ref in refs) { // 查找页面中存在的子组件\n    if (Object.prototype.toString.call(refs[ref]) === '[object Object]') {\n        refs[ref].submitForm()\n    }\n    if (Object.prototype.toString.call(refs[ref]) === '[object Array]' && refs[ref].length > 0) {\n        refs[ref].forEach((each) => {\n            each.submitForm()\n        })\n    }\n}\n```\n\n##### 规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\n规则的输入校验如果都放在父组件进行，需要处理太多的交互逻辑，不利于代码的维护；\n因此，我把每个规则的输入校验，都放在各子组件内部进行，父组件只需要知道结果就可以了\n\n当父组件需要发起验证时，向各个子组件发起验证请求，子组件收到请求后，执行输入校验，并把验证结果通过emit事件通知给父组件；父组件收集子组件的通知，并判断是否全部通过，只有全部通过才可以继续执行；\n![父子组件交互](父子组件交互设计.jpg)\n\n```父组件\nsubmit () {// 向子组件发起验证请求\n    let resCollect = this.checkResult = {}\n    let refs = this.$refs\n    this.ruleMap = {}\n    this.dataItems = []\n    for (let ref in refs) {// 向子组件发起验证请求\n        if (Object.prototype.toString.call(refs[ref]) === '[object Object]') {\n            refs[ref].submitForm()\n        }\n        if (Object.prototype.toString.call(refs[ref]) === '[object Array]' && refs[ref].length > 0) {\n            refs[ref].forEach((each) => {\n                each.submitForm()\n            })\n        }\n    }\n}\ncheckResultFn (res) { // 接收子组件的通知，并记录结果\n    if (this.checkResult[res.name] !== undefined) {\n        this.checkResult[res.name] = this.checkResult[res.name] && res.result\n    } else {\n        this.checkResult[res.name] = res.result\n    }\n}\n```\n\n```子组件\nsubmitForm() { \n\t// 执行表单输入检测\n    this.$refs['form'].validate((valid) => {\n    \t// 将结果通知给父组件\n        this.$emit('checkResult', {\n            name: this.name,\n            result: valid,\n            data: this.form.checkedChannels\n        })\n    })\n}\n```\n\n\n","slug":"规则配置界面设计","published":1,"updated":"2018-08-24T10:57:04.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrbr11xp000k2om24y68suzw","content":"<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>山西移动电子渠道营销项目中，需要实现营销活动的可视化配置能力<br><img src=\"/blog/2018/08/03/规则配置界面设计/语境图.jpg\" alt=\"语境图\"></p>\n<p>其中一部分重点内容是如何实现活动规则的可视化配置；</p>\n<h4 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h4><ul>\n<li>营销活动通常意味着需要条件，满足某些条件，才可以参加活动，这些条件我称之为“规则”</li>\n<li>在营销能力提升项目中，需要在后台编辑营销活动时，同时给营销活动设置“规则”；发布至前台工程后，可根据后台配置的“规则”进行验证；<br><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置流程.jpg\" alt=\"规则配置流程\"></li>\n</ul>\n<h4 id=\"需求细化\"><a href=\"#需求细化\" class=\"headerlink\" title=\"需求细化\"></a>需求细化</h4><ul>\n<li>此功能并不是针对某个营销活动，而是通用型的解决方案；“规则”要不断添加积累</li>\n<li>已有“规则”需要支持各种排列组合；</li>\n<li>“规则”的编辑和修改需要实时生效，以应对营销活动的频繁变化；</li>\n</ul>\n<h4 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h4><p><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置界面设计.jpg\" alt=\"规则配置界面\"></p>\n<ul>\n<li>规则分为基础规则（必选规则），以及其他规则（可选规则）</li>\n<li>可选规则可动态添加删除</li>\n<li>部分规则可重复添加</li>\n<li>每个规则都需要进行输入验证</li>\n<li>提交时要对所有规则进行验证</li>\n</ul>\n<h4 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h4><p><img src=\"/blog/2018/08/03/规则配置界面设计/规则列表查询接口.png\" alt=\"规则列表查询接口\"><br><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置保存接口.png\" alt=\"规则配置保存接口\"></p>\n<h4 id=\"前端设计重点\"><a href=\"#前端设计重点\" class=\"headerlink\" title=\"前端设计重点\"></a>前端设计重点</h4><h5 id=\"每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\"><a href=\"#每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\" class=\"headerlink\" title=\"每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\"></a>每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；</h5><p>动态组件可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is 特性来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在上述示例中，currentTabComponent 可以包括</p>\n<ul>\n<li>已注册组件的名字，或</li>\n<li>一个组件的选项对象</li>\n</ul>\n<h5 id=\"如何获取界面上已经添加的组件\"><a href=\"#如何获取界面上已经添加的组件\" class=\"headerlink\" title=\"如何获取界面上已经添加的组件\"></a>如何获取界面上已经添加的组件</h5><p>可以通过给子组件增加ref属性，为这个子组件赋予一个ID引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在已经定义了这个 ref 的组件里，可以使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$refs.usernameInput</span><br></pre></td></tr></table></figure></p>\n<p>来访问这个 <code>&lt;base-input&gt;</code> 实例</p>\n<p>通过这种方式，我们可以在添加组件是记录组件的ref，在提交验证时，通过记录的ref属性，找到页面上已经添加的子组件（规则组件）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let ref in refs) &#123; // 查找页面中存在的子组件</span><br><span class=\"line\">    if (Object.prototype.toString.call(refs[ref]) === &apos;[object Object]&apos;) &#123;</span><br><span class=\"line\">        refs[ref].submitForm()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (Object.prototype.toString.call(refs[ref]) === &apos;[object Array]&apos; &amp;&amp; refs[ref].length &gt; 0) &#123;</span><br><span class=\"line\">        refs[ref].forEach((each) =&gt; &#123;</span><br><span class=\"line\">            each.submitForm()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\"><a href=\"#规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\" class=\"headerlink\" title=\"规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\"></a>规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定</h5><p>规则的输入校验如果都放在父组件进行，需要处理太多的交互逻辑，不利于代码的维护；<br>因此，我把每个规则的输入校验，都放在各子组件内部进行，父组件只需要知道结果就可以了</p>\n<p>当父组件需要发起验证时，向各个子组件发起验证请求，子组件收到请求后，执行输入校验，并把验证结果通过emit事件通知给父组件；父组件收集子组件的通知，并判断是否全部通过，只有全部通过才可以继续执行；<br><img src=\"/blog/2018/08/03/规则配置界面设计/父子组件交互设计.jpg\" alt=\"父子组件交互\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submit () &#123;// 向子组件发起验证请求</span><br><span class=\"line\">    let resCollect = this.checkResult = &#123;&#125;</span><br><span class=\"line\">    let refs = this.$refs</span><br><span class=\"line\">    this.ruleMap = &#123;&#125;</span><br><span class=\"line\">    this.dataItems = []</span><br><span class=\"line\">    for (let ref in refs) &#123;// 向子组件发起验证请求</span><br><span class=\"line\">        if (Object.prototype.toString.call(refs[ref]) === &apos;[object Object]&apos;) &#123;</span><br><span class=\"line\">            refs[ref].submitForm()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Object.prototype.toString.call(refs[ref]) === &apos;[object Array]&apos; &amp;&amp; refs[ref].length &gt; 0) &#123;</span><br><span class=\"line\">            refs[ref].forEach((each) =&gt; &#123;</span><br><span class=\"line\">                each.submitForm()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkResultFn (res) &#123; // 接收子组件的通知，并记录结果</span><br><span class=\"line\">    if (this.checkResult[res.name] !== undefined) &#123;</span><br><span class=\"line\">        this.checkResult[res.name] = this.checkResult[res.name] &amp;&amp; res.result</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.checkResult[res.name] = res.result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submitForm() &#123; </span><br><span class=\"line\">\t// 执行表单输入检测</span><br><span class=\"line\">    this.$refs[&apos;form&apos;].validate((valid) =&gt; &#123;</span><br><span class=\"line\">    \t// 将结果通知给父组件</span><br><span class=\"line\">        this.$emit(&apos;checkResult&apos;, &#123;</span><br><span class=\"line\">            name: this.name,</span><br><span class=\"line\">            result: valid,</span><br><span class=\"line\">            data: this.form.checkedChannels</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>山西移动电子渠道营销项目中，需要实现营销活动的可视化配置能力<br><img src=\"/blog/2018/08/03/规则配置界面设计/语境图.jpg\" alt=\"语境图\"></p>\n<p>其中一部分重点内容是如何实现活动规则的可视化配置；</p>\n<h4 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h4><ul>\n<li>营销活动通常意味着需要条件，满足某些条件，才可以参加活动，这些条件我称之为“规则”</li>\n<li>在营销能力提升项目中，需要在后台编辑营销活动时，同时给营销活动设置“规则”；发布至前台工程后，可根据后台配置的“规则”进行验证；<br><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置流程.jpg\" alt=\"规则配置流程\"></li>\n</ul>\n<h4 id=\"需求细化\"><a href=\"#需求细化\" class=\"headerlink\" title=\"需求细化\"></a>需求细化</h4><ul>\n<li>此功能并不是针对某个营销活动，而是通用型的解决方案；“规则”要不断添加积累</li>\n<li>已有“规则”需要支持各种排列组合；</li>\n<li>“规则”的编辑和修改需要实时生效，以应对营销活动的频繁变化；</li>\n</ul>\n<h4 id=\"界面设计\"><a href=\"#界面设计\" class=\"headerlink\" title=\"界面设计\"></a>界面设计</h4><p><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置界面设计.jpg\" alt=\"规则配置界面\"></p>\n<ul>\n<li>规则分为基础规则（必选规则），以及其他规则（可选规则）</li>\n<li>可选规则可动态添加删除</li>\n<li>部分规则可重复添加</li>\n<li>每个规则都需要进行输入验证</li>\n<li>提交时要对所有规则进行验证</li>\n</ul>\n<h4 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h4><p><img src=\"/blog/2018/08/03/规则配置界面设计/规则列表查询接口.png\" alt=\"规则列表查询接口\"><br><img src=\"/blog/2018/08/03/规则配置界面设计/规则配置保存接口.png\" alt=\"规则配置保存接口\"></p>\n<h4 id=\"前端设计重点\"><a href=\"#前端设计重点\" class=\"headerlink\" title=\"前端设计重点\"></a>前端设计重点</h4><h5 id=\"每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\"><a href=\"#每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\" class=\"headerlink\" title=\"每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；\"></a>每个规则抽象为单独的VUE组件，需要在父组件中动态加载子组件；</h5><p>动态组件可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is 特性来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在上述示例中，currentTabComponent 可以包括</p>\n<ul>\n<li>已注册组件的名字，或</li>\n<li>一个组件的选项对象</li>\n</ul>\n<h5 id=\"如何获取界面上已经添加的组件\"><a href=\"#如何获取界面上已经添加的组件\" class=\"headerlink\" title=\"如何获取界面上已经添加的组件\"></a>如何获取界面上已经添加的组件</h5><p>可以通过给子组件增加ref属性，为这个子组件赋予一个ID引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在已经定义了这个 ref 的组件里，可以使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$refs.usernameInput</span><br></pre></td></tr></table></figure></p>\n<p>来访问这个 <code>&lt;base-input&gt;</code> 实例</p>\n<p>通过这种方式，我们可以在添加组件是记录组件的ref，在提交验证时，通过记录的ref属性，找到页面上已经添加的子组件（规则组件）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let ref in refs) &#123; // 查找页面中存在的子组件</span><br><span class=\"line\">    if (Object.prototype.toString.call(refs[ref]) === &apos;[object Object]&apos;) &#123;</span><br><span class=\"line\">        refs[ref].submitForm()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (Object.prototype.toString.call(refs[ref]) === &apos;[object Array]&apos; &amp;&amp; refs[ref].length &gt; 0) &#123;</span><br><span class=\"line\">        refs[ref].forEach((each) =&gt; &#123;</span><br><span class=\"line\">            each.submitForm()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\"><a href=\"#规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\" class=\"headerlink\" title=\"规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定\"></a>规则内容校验，每个规则都需要进行输入验证，组件动态加载过程如何与验证逻辑绑定</h5><p>规则的输入校验如果都放在父组件进行，需要处理太多的交互逻辑，不利于代码的维护；<br>因此，我把每个规则的输入校验，都放在各子组件内部进行，父组件只需要知道结果就可以了</p>\n<p>当父组件需要发起验证时，向各个子组件发起验证请求，子组件收到请求后，执行输入校验，并把验证结果通过emit事件通知给父组件；父组件收集子组件的通知，并判断是否全部通过，只有全部通过才可以继续执行；<br><img src=\"/blog/2018/08/03/规则配置界面设计/父子组件交互设计.jpg\" alt=\"父子组件交互\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submit () &#123;// 向子组件发起验证请求</span><br><span class=\"line\">    let resCollect = this.checkResult = &#123;&#125;</span><br><span class=\"line\">    let refs = this.$refs</span><br><span class=\"line\">    this.ruleMap = &#123;&#125;</span><br><span class=\"line\">    this.dataItems = []</span><br><span class=\"line\">    for (let ref in refs) &#123;// 向子组件发起验证请求</span><br><span class=\"line\">        if (Object.prototype.toString.call(refs[ref]) === &apos;[object Object]&apos;) &#123;</span><br><span class=\"line\">            refs[ref].submitForm()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Object.prototype.toString.call(refs[ref]) === &apos;[object Array]&apos; &amp;&amp; refs[ref].length &gt; 0) &#123;</span><br><span class=\"line\">            refs[ref].forEach((each) =&gt; &#123;</span><br><span class=\"line\">                each.submitForm()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkResultFn (res) &#123; // 接收子组件的通知，并记录结果</span><br><span class=\"line\">    if (this.checkResult[res.name] !== undefined) &#123;</span><br><span class=\"line\">        this.checkResult[res.name] = this.checkResult[res.name] &amp;&amp; res.result</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        this.checkResult[res.name] = res.result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submitForm() &#123; </span><br><span class=\"line\">\t// 执行表单输入检测</span><br><span class=\"line\">    this.$refs[&apos;form&apos;].validate((valid) =&gt; &#123;</span><br><span class=\"line\">    \t// 将结果通知给父组件</span><br><span class=\"line\">        this.$emit(&apos;checkResult&apos;, &#123;</span><br><span class=\"line\">            name: this.name,</span><br><span class=\"line\">            result: valid,</span><br><span class=\"line\">            data: this.form.checkedChannels</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/gitflow工作流程使用经验/sourceTree.jpg","slug":"sourceTree.jpg","post":"cjrbr11nv00012om2zqibxaid","modified":0,"renderable":0},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程--增加数字证书流程.jpg","slug":"签名验签流程--增加数字证书流程.jpg","post":"cjrbr11ug00082om2rhbd5lqn","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/jenkins配置图.png","slug":"jenkins配置图.png","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/md5戳不一致.jpg","slug":"md5戳不一致.jpg","post":"cjrbr11ng00002om2gcbsclmj","modified":0,"renderable":0},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/require引入方式.jpg","slug":"require引入方式.jpg","post":"cjrbr11ng00002om2gcbsclmj","modified":0,"renderable":0},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/修正后.jpg","slug":"修正后.jpg","post":"cjrbr11ng00002om2gcbsclmj","modified":0,"renderable":0},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译前.jpg","slug":"编译前.jpg","post":"cjrbr11ng00002om2gcbsclmj","modified":0,"renderable":0},{"_id":"source/_posts/fis发布过程给文件增加md5戳导致文件加载404异常问题分析解决/编译后.jpg","slug":"编译后.jpg","post":"cjrbr11ng00002om2gcbsclmj","modified":0,"renderable":0},{"_id":"source/_posts/gitflow工作流程使用经验/gitBash.jpg","slug":"gitBash.jpg","post":"cjrbr11nv00012om2zqibxaid","modified":0,"renderable":0},{"_id":"source/_posts/gitflow工作流程使用经验/gitBranch.jpg","slug":"gitBranch.jpg","post":"cjrbr11nv00012om2zqibxaid","modified":0,"renderable":0},{"_id":"source/_posts/gitflow工作流程使用经验/gitflow.png","slug":"gitflow.png","post":"cjrbr11nv00012om2zqibxaid","modified":0,"renderable":0},{"_id":"source/_posts/vue渲染机制/$mount使用方法.jpg","slug":"$mount使用方法.jpg","post":"cjrbr11u600062om2z3j2gu7m","modified":0,"renderable":0},{"_id":"source/_posts/vue渲染机制/vue渲染机制.png","slug":"vue渲染机制.png","post":"cjrbr11u600062om2z3j2gu7m","modified":0,"renderable":0},{"_id":"source/_posts/vue渲染机制/事件循环.png","slug":"事件循环.png","post":"cjrbr11u600062om2z3j2gu7m","modified":0,"renderable":0},{"_id":"source/_posts/vue渲染机制/效果图.jpg","slug":"效果图.jpg","post":"cjrbr11u600062om2z3j2gu7m","modified":0,"renderable":0},{"_id":"source/_posts/拼团购活动开发总结/拼团购活动模型.png","slug":"拼团购活动模型.png","post":"cjrbr11xk000h2om29z82xhrd","modified":0,"renderable":0},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程--应对大量数据传输时的加密效率问题.jpg","slug":"签名验签流程--应对大量数据传输时的加密效率问题.jpg","post":"cjrbr11ug00082om2rhbd5lqn","modified":0,"renderable":0},{"_id":"source/_posts/加密签名与解密验签总结/签名验签流程.jpg","slug":"签名验签流程.jpg","post":"cjrbr11ug00082om2rhbd5lqn","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/FTP任务配置.jpg","slug":"FTP任务配置.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/FTP配置.jpg","slug":"FTP配置.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/git配置.jpg","slug":"git配置.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/git配置异常.jpg","slug":"git配置异常.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/jenkins插件.jpg","slug":"jenkins插件.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/nodejs配置.jpg","slug":"nodejs配置.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/新建任务.jpg","slug":"新建任务.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建.jpg","slug":"构建.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建日志.jpg","slug":"构建日志.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/构建环境.jpg","slug":"构建环境.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/源码管理.jpg","slug":"源码管理.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/界面化操作.jpg","slug":"界面化操作.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/邮件提醒.jpg","slug":"邮件提醒.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/jenkins持续集成前端项目实践/邮件配置.jpg","slug":"邮件配置.jpg","post":"cjrbr11uf00072om2fxwrjb9t","modified":0,"renderable":0},{"_id":"source/_posts/基于vue的管理系统权限管控方案/SequenceDiagram.png","slug":"SequenceDiagram.png","post":"cjrbr11x1000d2om2e6epaex4","modified":0,"renderable":0},{"_id":"source/_posts/基于vue的管理系统权限管控方案/menu.jpg","slug":"menu.jpg","post":"cjrbr11x1000d2om2e6epaex4","modified":0,"renderable":0},{"_id":"source/_posts/前端导出csv/excel打开.jpg","slug":"excel打开.jpg","post":"cjrbr11wy000b2om2s0m3n0p5","modified":0,"renderable":0},{"_id":"source/_posts/前端导出csv/table.jpg","slug":"table.jpg","post":"cjrbr11wy000b2om2s0m3n0p5","modified":0,"renderable":0},{"_id":"source/_posts/前端导出csv/test.jpg","slug":"test.jpg","post":"cjrbr11wy000b2om2s0m3n0p5","modified":0,"renderable":0},{"_id":"source/_posts/前端导出csv/保存.jpg","slug":"保存.jpg","post":"cjrbr11wy000b2om2s0m3n0p5","modified":0,"renderable":0},{"_id":"source/_posts/前端导出csv/导出excel.jpg","slug":"导出excel.jpg","post":"cjrbr11wy000b2om2s0m3n0p5","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/父子组件交互设计.jpg","slug":"父子组件交互设计.jpg","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/规则列表查询接口.png","slug":"规则列表查询接口.png","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/规则配置保存接口.png","slug":"规则配置保存接口.png","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/规则配置流程.jpg","slug":"规则配置流程.jpg","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/规则配置界面设计.jpg","slug":"规则配置界面设计.jpg","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/规则配置界面设计/语境图.jpg","slug":"语境图.jpg","post":"cjrbr11xp000k2om24y68suzw","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/class兼容性.jpg","slug":"class兼容性.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/generators兼容性.jpg","slug":"generators兼容性.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/ios10报错.jpg","slug":"ios10报错.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/let兼容性.jpg","slug":"let兼容性.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/webpack配置.jpg","slug":"webpack配置.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/箭头函数兼容性.jpg","slug":"箭头函数兼容性.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/说明1.jpg","slug":"说明1.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/首页在部分机型下白屏原因分析/说明2.jpg","slug":"说明2.jpg","post":"cjrbr11xn000j2om2wsia4go9","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/approval.jpg","slug":"approval.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/approvalProcess.jpg","slug":"approvalProcess.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/flow.jpg","slug":"flow.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/history.jpg","slug":"history.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/imageManage.jpg","slug":"imageManage.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/issue.jpg","slug":"issue.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/preview.jpg","slug":"preview.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/preview2.jpg","slug":"preview2.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/qrcode.jpg","slug":"qrcode.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/snapshot.jpg","slug":"snapshot.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/workflow.jpg","slug":"workflow.jpg","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0},{"_id":"source/_posts/可视化编辑系统实践/workflow.png","slug":"workflow.png","post":"cjrbr11ww000a2om25aatb4hk","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}